[{"id":0,"href":"/docs/git/sections/basics/","title":"Basics: repository, commits and branches","section":"git","content":" # Basics: repository, commits and branches ## Repository A git **repository** is a folder that stores a project. It is identical to a regular folder, except for a hidden folder named `.git`. This folder stores (among others) the whole history of the project. ## Commit A **commit** is a snapshot of a repository. Each commit has medatada associated to it. In particular: - an ID, - the name of the commit's author, - a timestamp, - a message that describes the commit. For instance, Alice may create a fresh git repository, add some files to it, and commit these files. After this step, Alice's repository may be pictured as follows. ![](/img/git/first_commit_verbose.svg) Next, Alice may modify some of these files (and/or add new ones), and commit these changes: ![](/img/git/second_commit_verbose.svg) **_Notation._** In the figures below, for readability, we will omit the commits' metadata. So the above repository will be represented as: ![](/img/git/second_commit_no_pointer.svg) ## Main branch By default, Alice's commits belong the **main branch** of her repository (often called `main` or `master`). You can think of a branch as a timeline. Git keeps tack of the latest commit on this branch with a so-called \"pointer\" (you can think of it as a variable) to that commit: ![](/img/git/second_commit_no_head.svg) ## Time travel Alice can load any previous snapshot of her repository. The history of the repository will _not_ be affected. To achieve this, Git uses another \"pointer\" called `HEAD`, which intuitively keeps track of the current position of Alice in the commit's history. By default, `HEAD` points to the main pointer: ![](/img/git/second_commit.svg) If Alice decides to load her previous snapshot (thanks to the `git checkout` command), then `HEAD` will instead point to the corresponding commit: ![](/img/git/detached_head.svg) In this case (i.e. when it does not point to a branch pointer, but directly to a commit), the HEAD pointer is said to be in a **detached** state. ## Branching time Alice may want to work on an experimental feature of her project. She can develop this feature in an \"alternative timeline\", a.k.a. another branch. Before creating this new branch, Alice most likely wants to travel back to her latest commit. This will move the HEAD pointer back to where it was: ![](/img/git/second_commit.svg) Now Alice may create a new branch, and name it `myFeature`. This will create a new branch pointer: ![](/img/git/create_feature_branch.svg) Alice can also specify that she want to work on this new branch (using the `git checkout` command still). This will affect the `HEAD` pointer: ![](/img/git/switch_to_feature_branch.svg) Next, Alice may implement (part of) her new feature, and commit these changes. This will move the `myfeature` pointer forward: ![](/img/git/commit_to_feature_branch.svg) Now Alice may need to fix an urgent bug on her main branch. If she switches to the main branch (again, with `git checkout`), then `HEAD` will point to it: ![](/img/git/back_to_main_branch.svg) Alice may fix the bug and commit her changes. This will create a commit and move the `main` pointer as expected. The two branches now **diverge**: ![](/img/git/diverging.svg) Then Alice may switch back to the `myFeature` branch to resume her work: ![](/img/git/back_to_feature_branch.svg) And add a commit to this branch: ![](/img/git/second_commit_to_feature_branch.svg) ## History The **history** of a branch consists of all commits on a path from the branch's pointer to the original commit. For instance, this is the history of the `myFeature` branch: ![](/img/git/history_feature_branch.svg) And this is the history of `main` branch: ![](/img/git/history_main_branch.svg) ## Merging branches We left Alice's repository in this situation: ![](/img/git/second_commit_to_feature_branch.svg) Alice is now satisfied with her new feature, and she wants to incorporate it into her main branch. To do so, she first switches to the _receiving_ branch (in this case, the `main` branch): ![](/img/git/switch_to_merge_recipient.svg) Then she can **merge** the branch `myFeature` _into_ the branch `main`. Because the two branches have diverged, this will generate a new commit, called a **merge commit**: ![](/img/git/after_merge.svg) Before she can create a merge commit, Alice may need to fix potential **conflicts** between the diverging branches. In this happens, then git will provide Alice a list of files that contain so-called \"merge conflicts\". In each of theses files, each conflict will be identified as follows: ``` \u003c\u003c\u003c\u003c\u003c\u003c\u003c HEAD ======= \u003e\u003e\u003e\u003e\u003e\u003e\u003e ``` ## After a merge Observe that a merge commit (usually) has _two_ parent commits. More generally: - a repository with merge commits is _not_ a tree. - in such a repository, the history of a \"branch\" may consists of commits from _different paths_. For instance, here is the history of the main branch: ![](/img/git/history_after_merge.svg) Note that after this merge, all commits of the `myFeature` branch are part of the history of the branch `main`. Alice may keep the `myFeature` branch for some future usage, or she may decide to delete it. In the latter case, the `myFeature` pointer will simply be deleted: ![](/img/git/after_branch_deletion.svg) ## Fast-forward merge If two branches have _not_ diverged, then there is a simpler way to merge them. For instance, consider Carol's repository: ![](/img/git/non_diverging.svg) The branches `main` and `experimental` have not diverged. So `experimental` can be merged into `main` by simply moving the `main` pointer: ![](/img/git/fast-forward.svg) In this case, _no merge commit is needed_. This is called a **fast-forward merge**. "},{"id":1,"href":"/docs/errors/sections/callstack/","title":"Call stack","section":"Errors","content":" # Call stack A **call stack** is a [stack](http://localhost:44407/docs/abstractdatatypes/sections/queue/#stack) that keeps track of the methods that are active during the execution of a program. By \"active\", we mean that an execution of the method has started and has not terminated yet. When the execution of a method starts, it is \"added\" to the stack. When it terminates, the method is \"removed\" from the stack, and control is passed back to the method that called it. A **debugger** provides a representation of the successive states of a call stack, with references to the source code. This gives the illusion of source code being interpreted verbatim. **_Example._** In our game, consider the following implementation of the method `callReinforcement`: ```java {linenos=true} public class Backend implements EventHandler { Snapshot currentSnapshot; ... @Override public void callReinforcement() { Player activePlayer = currentSnapshot.getActivePlayer(); int unitsToInsert = currentSnapshot.getSizeOfReinforcement(activePlayer); while (unitsToInsert \u003e 0){ Unit unit = generateRandomUnit(); TileCoordinates coordinates = findInsertionSpot(unit); if(coordinates != null) { addUnit(coordinates, unit); unitsToInsert--; } } } private Unit generateRandomUnit() { ... } private TileCoordinates findInsertionSpot(Unit unit) { ... } private void addUnit(TileCoordinates coordinates, Unit unit) { currentSnapshot.getBoard().addUnit(coordinates.rowIndex(), coordinates.columnIndex(), unit); performUnitMerges(); } private void performUnitMerges() { ... } } ``` When the method `callReinforcement` is called, it is added (a.k.a. [pushed](http://localhost:44407/docs/abstractdatatypes/sections/queue/#stack)) on top of the call stack. This is rendered by a debugger as: ``` callReinforcement ``` If execution \"reaches\" Line 11, then the method `generateRandomUnit` is called and added to the stack: ``` generateRandomUnit callReinforcement: 11 ``` When the method `generateRandomUnit` terminates, it passes control (as well as a `Unit`) back to the method that called it, namely `callReinforcement`, which can resume its execution: ``` callReinforcement ``` Similarly, when execution \"reaches\" Line 12, `findInsertionSpot` is added to the stack, executed, and then removed from the stack, passing control back to `callReinforcement`. Then if execution \"reaches\" Line 14, `addUnit` is executed, which in turn calls `performUnitMerges`: ``` performUnitMerges addUnit: 28 callReinforcement: 14 ``` etc. **_Note._** If a method is recursive (i.e. if it calls itself, _directly or indirectly_), then it may appear multiple times in the call stack. E.g.: ``` method1 method2: 16 method1: 8 ``` **_Definition._** A **stack overflow** occurs when the size of the call stack exceeds the capacity allowed by the execution environment. This is generally due to a non-terminating recursive method. "},{"id":2,"href":"/docs/background/sections/problem/","title":"Computational problem","section":"Background","content":" # Computational problem A **computational problem** is (usually) specified as: - a set of possible **inputs**, and - the expected **outputs** (for these inputs). ## Problem vs algorithm For instance, here is a problem that you may have encountered already: \u003e - **_Input:_** a sorted array _A_ of integers, an integer _a_ \u003e - **_Output:_** true if _a_ appears in _A_, false otherwise There are (infinitely) many algorithms that can solve this problem. But some of them are more efficient than others. **Efficiency** (a.k.a. **computational cost**) refers to the time and/or memory needed to execute an algorithm, expressed as a _function of the size of the input_ (more on this later). Exercise Can you think of (or do you already know) an algorithm that can solve this problem efficiently? Why is it efficient? Solution **_Algorithm._** Let _n_ be the size of _A_, and let us assume for simplicity that arrays are 1-indexed and that _A_ is nonempty. - If _n_ = 1, then check whether _A_[1] = _a_. - Otherwise: - check whether _A_[_n_/2] = _a_ (where \"/\" is integer division, rounded up or down if _n_ is odd), - depending on the result, repeat on either the left or the right half of _A_. **_Cost._** If _A_ has length _n_, then the number of iterations of the procedure is (in the order of) log*2 \\_n* in the worst case (e.g. if _a_ does not appear in _A_). Here is another problem that you may know: \u003e - **_Input:_** an array of integers \u003e - **_Output:_** an array with the same values, but sorted in ascending order And yet another: \u003e - **_Input:_** a solvable grid of sudoku \u003e - **_Output:_** the same grid, solved **_Note._** A problem specifies _what_ a program should do, not _how_ to do it. In other words, a computational problem is _not an algorithm_. For instance, the following is _not_ a computational problem: - **_Input:_** an array of integers. - **_Algorithm:_** initialize a counter to 1. Then iterate through the array, and: - increment the counter each time 2 consecutive numbers are encountered, and - reset the counter to 1 otherwise. Exercise Which problem does this algorithm solve? Solution - **_Input:_** an array _A_ of integers - **_Output:_** the length of the longest suffix of _A_ that consists of consecutive numbers ## Formulating a problem When developing a project, it can be helpful to express some sub(tasks) as computational problems. This is also a common way to _document_ your code. For instance the [Javadoc]() of a class may consist of computational problems (e.g. the Javadoc for the method `indexOf` of the class `String` in Java). When formulating a problem, make sure that: - the output is specified for _all_ inputs, and - the formulation is _non-ambiguous_, meaning that it should clearly specify whether any given pair (input, output) is correct. Exercise Consider the class `Unit` (and its subclasses), as defined in [the section about inheritance](http://localhost:44407/docs/objects/sections/inheritance/). The following problem is not properly defined. Can you see why? - **_Input:_** a nonempty array _A_ of instances of the class `Unit` - **_Output:_** the unicorn with highest health in _A_ Solution There may be no unicorn in _A_, or several healthiest unicorns. Exercise The following problem is not properly defined. Can you see why? - **_Input:_** a (finite) family of (finite) sets - **_Output:_** the smallest set that has a nonempty intersection with each of the input sets (where \"smallest\" here refers to the _size_ of a set) For instance, for the input ``` { {a,c,k}, {a,b}, {a,m}, {c,d,f}, {c,e} } ``` the expected output is ``` {a,c} ``` Solution Some inputs admit more than one solution (the simplest example is the input `{a,b}`). **_Note._** A problem may admit several outputs for the same input _without being ambiguous_. For instance: - **_Input._** a graph _G_, two nodes _s_ and _t_ in _G_, - **_Output:_** one of the shortest paths from _s_ to _t_ in _G_ if any, and `null` otherwise. A problem may be [undecidable](), meaning that for any algorithm attempting to solve this problem, there (provably) exist (infinitely many) inputs for which the algorithm either produces an incorrect output or does not terminate. A problem may be decidable but [intractable](), meaning that (provably) no _efficient_ algorithm can solve it (where cost is once again measured as a function of the size of the input). "},{"id":3,"href":"/docs/recursion/sections/linear/","title":"Linear recursion","section":"Recursion","content":" # Linear recursion **_Definition._** A recursive method is **linear recursive** if it performs at most _one_ recursive call each time it is executed. **_Terminology._** The term **unary recursion** is sometimes used to refer to linear recursive algorithms (as opposed to [n-ary recursion](http://localhost:44407/docs/recursion/sections/nary/)). **_Hint._** A linear recursive algorithm is often easy to transform into an iterative one (i.e. an algorithm that uses only loops). ## Example Exercise Write in pseudocode a (linear) recursive algorithm for a method `int occ(char[] A, char c)` that: - takes as input a (non-null) array `A` of characters and a character `c`, and - returns the number of occurrences of `c` in `A`. Possible solution ```java int occ(char[] A, char c) { return occRec(A, c, 0) } int occRec(char[] A, char c, int i) { // Base case: the segment under consideration is empty if(i == A.length){ return 0 } // Inductive case. // Count the number of occurrences of c in the \"suffix\" segment A[i+1 .. A.length-1] int occInSuffix = occRec(A, c, i + 1) return A[i] == c ? // If the current character is c, then return this value + 1, occInSuffix + 1 : // otherwise return this value as it is. occInSuffix } ``` ## Tail recursion ### Motivation Consider a (not necessarily recursive) method `method1` that calls a method `method2`, for instance: ```perl method1() { ... method2() ... } ``` The execution of `method1` is interrupted when it calls `method2`. During this interruption, the [call stack](http://localhost:44407/docs/errors/sections/callstack/) contains: ``` method2 method1 ``` Variables that are local to the execution of a method are allocated on the so-called [stack](https://en.wikipedia.org/wiki/Stack-based_memory_allocation) memory. In this example, variables that are local to `method1` remain in memory during the execution of `method2` (because they may be needed when the execution of `method1` resumes). However, if no instruction in `method1` needs to be executed _after_ the call to `method2`, then there is no need to maintain this information in memory. ```perl method1() { ... method2() } ``` In other words, the call stack in this case could be safely be reduced to: ``` method2 ``` This optimization technique is known as [tail-call elimination](https://en.wikipedia.org/wiki/Tail_call). Some compilers apply it (but most Java compilers do not). During the execution of a recursive algorithm, the size of the call stack may become important, therefore also the amount of stack memory required. Therefore identifying calls that may be safely be removed from the stack can significantly reduce memory consumption. ### Definition A linear recursive method is **tail recursive** if no instruction in this method can be executed _after_ a recursive call. A tail recursive algorithm can easily be transformed into an iterative one. This transformation can be viewed as a \"manual\" form of tail-call elimination. Exercise The algorithm above for the method `int occ(char[] A, char c)` is linear recursive, but not tail-recursive. Rewrite it into a tail-recursive algorithm. Then convert it into an iterative algorithm. Possible solution Tail recursive algorithm: ```java int occ(char[] A, char c) { return occRec(A, c, 0, 0) } int occRec(char[] A, char c, int i, int occurences) { // Base case: the segment under consideration is empty if(i == A.length){ return 0; } // Inductive case. // If the current character is c, then increment the number of occurrences. if (A[i] == c) { occurrences++; } // Recursive call return occRec(A, c, i + 1, occurrences) } ``` Iterative algorithm: ```java int occ(char[] A, char c) { int occurrences = 0 for (int i = 0; i \u003c A.length; i++) { if (A[i] == c) { occurrences++ } } return occurrences } ``` A common strategy to convert a linear recursive method into a tail-recursive one consists in using additional arguments (like the argument `occurrences` in the above example). These extra arguments are sometimes called **accumulators**. ## Usage Linear recursive implementations are not very frequent, because most of them can be easily converted into iterative ones, as illustrated above. Besides, as we explained above, the iterative solution is often more efficient (at least memory-wise) for large inputs. However, some problems can be easier to solve in a linear recursive form (e.g. as a first attempt). This may also produce code that is easier to read and/or debug. In particular, it may be the case when manipulating linked lists. ### Linked list **_Definition._** A **linked list** is a set of objects organized in a _sequence_, such that each object (except for the last one) points to its successor. Equivalently, a linked list is a unary tree (and conversely), i.e. a tree where each node has exactly one (possibly null) child. For instance: ![](/img/linkedLists/unlabeled/list.svg) **_Terminology._** - the first object in a linked list is often called the **head** of the list, and - the rest of the list (i.e. the sublist with the second object as head) is often called the **tail** of the list. #### Example Exercise Consider linked lists that consist of instances of the following class: ![](/img/diagrams/plantuml/listNode_labeled.svg) Write (in pseudocode) a linear recursive algorithm `Node removeDuplicates(Node head)` that: - takes as input the head of a list with nodes sorted according to their label (in alphabetical order), - returns the head of a list with the same labels, in alphabetical order, but where each label appears exactly once. For instance, for the following input list: ![](/img/linkedLists/labeled/char/withDup/list.svg) the algorithm should output a list with labels: ![](/img/linkedLists/labeled/char/noDup/list.svg) Possible solution ```java Node removeDuplicates(Node head) { // Base case: empty list. if(head == null) { return null } // Inductive case. // Remove all duplicate in the tail. Node tailHead = removeDuplicates(head.next) // Compare the head with the (possibly new) head of the tail. if (tailHead != null \u0026\u0026 head.label == tailHead.label) { // If they have the same label, then return the tail. return tailHead } // Otherwise add the head to the returned list. head.next = tailHead return head } ``` "},{"id":4,"href":"/docs/abstractdatatypes/sections/list/","title":"List","section":"Abstract data types","content":" # List The abstract data type **list** simulates a [tuple](http://localhost:44407/docs/background/sections/set_tuple_map/#tuple). Accordingly, a list may contain _duplicates_. A list may expose the following methods: - **isEmpty** is self-explanatory, - **append** adds an element at the end of the list, - **prepend** adds an element at the beginning of the list, - **tail** returns the sub-list identical to the current one, but without its first element, - etc. **_Note._** The _size_ of a list is often unbounded (as opposed to the size of an array for instance). This can be implemented in different ways, for instance with a [dynamic array](https://en.wikipedia.org/wiki/Dynamic_array) or a [linked list](https://en.wikipedia.org/wiki/Linked_list). ## in Java Java has an interface `List` with 8 native implementations (i.e. 8 different _classes_ that implement this interface). The most commonly used are `ArrayList` and `LinkedList`. The interface `List` extends the interface `Collection`. ### Syntax Here are code snippets for a few operations specified in the interface `List`. - Create a `List` and populate it: ```java City milan = new City(\"milan\", 20100); City florence = new City(\"Florence\", 50100); // Creates an empty list of cities List myList = new ArrayList(); // Appends Milan to the list myList.add(milan); // Appends Florence to the list myList.add(florence); // Appends Milan again to the list myList.add(milan); // Creates a list identical to the previous one, but immutable List myOtherList = List.of(milan, florence, milan); City[] myArray = new City[]{milan, florence,}; // Creates a fixed-lenght \"wrapper\" list around the array. // No data is duplicated. List yetAnotherList = Arrays.asList(myArray); ``` - Retrieve the size of a list: ```java // Outputs 3 System.out.println(myList.size()); ``` - Retrieve the element at index _i_ (the first index being `0`, like in an array): ```java // Contains (a reference to) Florence City secondCity = myList.get(1); ``` - Insert an element at index _i_ (shift the position of all subsequent elements by 1). ```java City trento = new City(\"Trento\", 38100); myList.add(1, trento); // Now contains (a reference to) Trento secondCity = myList.get(1); // contains (a reference to) Florence City thirdCity = myList.get(2); ``` - Remove the element a index _i_ (shift the position of all subsequent elements by -1), and return it ```java myList.remove(1); // Outputs 3 Sysetm.out.println(myList.size()); // Now contains (a reference to) Florence secondCity = myList.get(1); ``` - Remove the first occurrence of an object in the list (shift the position of all subsequent elements by -1): ```java myList.remove(milan); // contains (a reference to) Florence City firstCity = myList.get(0); ``` For more operations, consult the [Javadoc](https://docs.oracle.com/javase/8/docs/api/java/util/List.html) of the interface `List`. "},{"id":5,"href":"/docs/objects/sections/objects/","title":"Objects","section":"Objects and classes","content":" # Objects An object is a way to group data in a meaningful way. ## A simple example: JSON objects Here is a JSON object (in Javascript syntax) that describes the city of Florence: ```javascript { name: \"Florence\", zipcode: 50100 } ``` A JSON object may contain other objects, as well as arrays (of values, objects or arrays). For instance: ```javascript { name: \"Alice\", age: 26, birthPlace: { name: \"Florence\", zipcode: 50100 }, jobs: [ { employer: \"Kolping\", start: 2021, end: 2022 }, { employer : \"Eurac\", start: 2023 } ] } ``` In JSON: - an **element** can be either: - a scalar (e.g. an integer), or - an array of elements, or - an object, - an **object** is a finite set of key-value pairs, where keys are distinct, and each value is an element. Equivalently, a JSON object can be viewed as a function (with finite domain) that maps keys to JSON elements. ## Objects and programming languages JSON objects do not exactly correspond to the objects that can be created in Java (and many other programming languages). We highlight here two important differences. ### Types Exercise Find a JSON object that satisfies the above description but _cannot_ be represented as an object in a (strongly) _typed_ language such as Java, C/C++, C#, etc. Possible solution ```javascript { key: [1, \"a\"]; } ``` In a typed language (like Java), the elements of an array must be of the _same type_.\nThis is not required in Javascript, Python, etc. ### References {#objectRef} A Java (or Python, C#, etc.) object does not contain objects or arrays, but **references** to objects or arrays. For instance, the equivalent in Java of the above object may be pictured as follows (abusing notation): ```javascript _1: { name: _2, age: 26, birthPlace: _3, jobs: _4, } _2: ['A','l','i','c','e'] _3: { name: _5, zipcode: 50100 } _4: [ _6, _7 ] _5: ['F','l','o','r','e','n','c','e'] ``` ```javascript _6: { employer: _8, start: 2021, end: 2022 } _7: { employer: _9, start: 2023 } _8: ['K','o','l','p','i','n','g'] _9: ['E','u','r','a','c'] ``` Each object or array has an ID (e.g. `_1` in this example), which can be used to refer to it (you can think of this ID as an address in memory). As a consequence, some objects can be created in Java that have _no finite representation_ in JSON. Exercise Find one of these objects. Possible solution ```javascript _1: { name: _2, friends: _3 } _2: ['A','l','i','c','e'] _3: [ _4, _7 ] _4: { name: _5, friends: _6 } _5: ['B','o','b'] _6: [ _1, _8 ] ``` If we try to represent this object in JSON, we get (assuming that we start with Alice): ```javascript { name: \"Alice\", friends: [ { name: \"Bob\", friends: [ { name: \"Alice\", friends: [ ... ]}]}]} ``` Cyclic references (like in this exercise) naturally occur in object-oriented code. Identifying them may be essential to debug a program that does not terminate or runs out of memory (stack overflow, ...). "},{"id":6,"href":"/docs/project/sections/free_project/","title":"Option 1: free project","section":"Project","content":" # Option 1: free project The first option available to you for your project consists in developing a Java application _of your choice_. This application is only a prototype, so it does _not_ need a comprehensive list of features or functionalities. The evaluation of your project will be mostly based on its **backend** (rather than the frontend). This means that your application: - does _not_ necessarily need a graphical user interface (but you may choose to develop one), - should perform _non-trivial_ backend task(s) (e.g. writing and/or reading to/from files is not sufficient). ## Guidelines ### Motivation A good projects is driven by an _idea_. Feel free to design your application so that it matches your own interests. For instance: - relate it to a hobby (music, cinema, fashion, sport, games, social media, astronomy, etc.), - use the project as an _opportunity_ to explore a topic that you are curious about (natural language processing, computer vision, recommender systems, robotics, etc.), - develop a functionality that one of your favorite applications is missing. Do not hesitate to be _ambitious_ at first. You can restrict the scope of your project (to certain features or components) later on. ## Specification A frequent source of failure for this course is students focusing on tools (e.g. following tutorials) without having a precise _objective_. The short deadline (June 2024) does not give you this flexibility. Besides, without a precise objective, the amount of libraries that are available to you (especially in Java) can be overwhelming. So we recommend you to clarify _what_ your application should do, before thinking about _how_ you could implement it. In other words, [specify](http://localhost:44407/docs/interfaces/sections/specification/) which problem(s) (i.e. _input_ and _expected output_) your program and/or components should solve. _Then only_ think about algorithms, libraries, tools and/or tutorials that can help you solve these problems. In order to determine whether your specification is precise enough, you may check whether it leaves some doubt as to whether an output is correct or not. ## User interface Developing a Graphical User Interface (GUI) requires familiarity with a [graphical framework](https://en.wikipedia.org/wiki/List_of_widget_toolkits). Learning the details of such a framework (terminology, syntax, setup, etc.) can be an _important time investment_, and this knowledge may not transfer to other graphical frameworks. In other words, developing a GUI may not require lot of thinking, but a lot of _reading_ (and web browsing). Beware also that GUIs technologies are still rapidly evolving, and that recent innovation has largely been driven by _web development_. So learning a graphical framework for Java may not be a strategic investment of your time (compared to learning a Javascript framework like React or Angular). Note that even desktop and mobile applications are increasingly relying on web technologies for their GUIs (thanks to frameworks like Electron or React Native). This is why we recommend you to _think carefully_ before committing to a Java GUI, and to _keep it minimal_ if you do. Note also that we will _not_ evaluate your project based on aesthetic criteria. So in order to design your interface, you may follow the following guidelines: 1. Ask yourself whether your application really needs a GUI. A command-line interface (CLI) may be sufficient, because: - your program takes files as input and produces files as output, or - your program is (primarily) meant to be used by other programs (rather than human beings), or - your program is meant to be used by other developers, or - external programs with GUIs (such as IDEs) can easily call your application, or - you leave the GUI for future work (again, your application is just a prototype), - etc. 2. If you really need a GUI, then: - **decouple** frontend and backend (whenever possible), so that the backend could be used with another frontend, and conversely. **_Example._** Many applications accessible via GUI have a natural decoupling of frontend and backend. For instance, consider an application that allows booking hotel rooms. The backend takes as input some _data_ (e.g. number or guests, duration, etc.), and outputs data as well (available rooms, prices, etc.). These input and output are independent of the aspect or structure of the GUI (windows, menus, buttons, fields, etc.). **_Example._** Even for some games, frontend and backend can easily be decoupled. Consider for instance a program that plays chess against a human opponent. The backend: - keeps track of the current state of the board, - takes as input either a move from the white player, or a request to play as the black player, - outputs the next state of the board. These input and output do not depend on a specific GUI (they can for instance be encoded using [algebraic notation]()). So the backend can be implemented _without_ any reference to graphical elements or controller inputs (mouse clicks, etc.). - develop the _backend first_ (and write [unit tests](http://localhost:44407/docs/unittests/) for it), - develop the _frontend afterwards_ (if you have time for it). 3. If you really need a GUI, then try to keep it _minimal_. In particular, _restrict the input_ to what is essential for your application. The more freedom the user is given, the more likely he/she is to input a _sequence of actions_ that your program cannot handle. ### Examples Here are some examples of (past and imaginary) possible projects: - a program that detects texts generated by a large language model, - a program that takes as input a [dataset of Tweets](https://imerit.net/blog/top-25-twitter-datasets-for-natural-language-processing-and-machine-learning-all-pbm/) and identifies communities and/or influencers based on the network formed by re-tweets, - a program that retrieves news articles about an input topic (using web APIs), and analyses their polarity (via [sentiment analysis](https://blogs.oracle.com/javamagazine/post/java-sentiment-analysis-stanford-corenlp)) together with their provenance (news outlet, country, etc.), - a (toy) [recommender system](https://en.wikipedia.org/wiki/Recommender_system), - a program that generates (solvable) sudoku grids with different sizes and/or level of difficulty, - a game to help people improve their typing speed, - a web crawler that retrieves sport-related statistics from various websites and exposes them via a web API, - a classroom reservation system for the Unibz that can computes a default schedule for a whole semester, satisfying a set of constraints (room capacity, etc.) and/or preferences (minimize days of presence per week of a same group, etc.), - a flashcard app that incorporates answers produced by a chatbot, - an ([Obsidian](https://obsidian.md/)-like) note management application, - a program to organize and manage coding contests (similar to [this one](https://open.kattis.com/contests)), - a password manager (with encryption), for instance similar to [pass](https://www.passwordstore.org/), where password update and synchronization are performed via git, - a program that analyzes the commit and/or branching history of a git repository (e.g. contributions of the different users, frequency of commits, percentage of preserved code, etc.). "},{"id":7,"href":"/docs/build/sections/packaging/","title":"Packaging a Java application","section":"Build automation","content":" # Packaging a Java application Java (like C# or Python) is a precompiled language, meaning that source code is compiled into a _machine-independent_ representation called **bytecode**. Bytecode can be distributed and executed _on any machine_. In Java, by convention, a source file `MyClass.java` is compiled into a bytecode file `MyClass.class`. A **Java Virtual Machine** (JVM) is a program in charge of executing Java bytecode. A **packaged** Java program is usually a zip file that contains: - bytecode, - metadata, and possibly: - [dependencies](http://localhost:44407/docs/build/sections/dependencies/), - other resources (data, images, etc.). ## Jar file {#jar} A **jar** (for [Java ARchive](https://docs.oracle.com/en/java/javase/13/docs/specs/jar/jar.html)) file is a zip file with extension `.jar`. This is the most common packaging format for Java applications. A jar can be: - a **thin** jar (i.e. excluding dependencies) or a **fat** (a.k.a. **_über_**) jar (i.e. including dependencies), - **runnable** or **non-runnable**. A jar contains a text file `META-INF/MANIFEST.MF` that provides metadata about the package, as a set of `key: value` pairs (one per line). Among others, it may contain: - the name, version and author(s) of the program, - the entry point of the program (i.e. the class that contains the `main` method), - paths to additional `.class` files that are part of the program, - etc. Details can be found [here](https://docs.oracle.com/javase/tutorial/deployment/jar/manifestindex.html). **_Note._** A jar for an application (including the `META-INF/MANIFEST.MF` file) is usually created via a build automation tool (like Maven or Gradle). But if you are curious, you can also build a (toy) jar via command line. A good illustration can be found [on the website of last year's course](https://programming-project-2022-23.github.io/maven/compiling/#creating-jar-files-from-the-command-line). **_Note._** Unit tests (and test-related resources) are usually _not_ included in the release of a program. Therefore in Java, these are generally absent from a jar. "},{"id":8,"href":"/docs/input/sections/files/","title":"Paths and files in Java","section":"I/O and serialization","content":" # Paths and files in Java Java's initial package for input/output (I/O) is called `java.io`. A central class in this package is [File](https://docs.oracle.com/javase/8/docs/api/java/io/File.html). Over the years, programmers realized that this package had limitations: limited error handling, limited support for file metadata (owner, access rights, etc.), and some performance issues. With Java 7 (2011), A new I/O package called NIO2 was released, with additional features (and in some cases a more concise syntax). A central interface (resp. class) in this package is [Path](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Path.html) (resp. [Files](https://docs.oracle.com/javase/8/docs/api/java/nio/file/Files.html)). However, the package `java.io` is still part of the latest Java release (it has _not_ been deprecated), in part for backward compatibility reasons. In this chapter, we will focus whenever possible on NIO2's classes and methods, rather than `java.io`. In particular, we will use the `Path` when possible rather than `File`. Note also that some external libraries (notably Apache [commons.io](https://commons.apache.org/proper/commons-io/description.html) and [Guava](https://github.com/google/guava/wiki/IOExplained)) provide additional methods for I/O, sometimes with a more concise syntax. **_Warning._** Many native Java methods that involve path or file manipulation may throw a [checked exception](http://localhost:44407/docs/errors/sections/checked/#checked) (generally an `IOException`). For instance, among the methods below, this is the case of: - `Path.toRealPath`, - `Files.size`, - `Files.walk`, - etc. As a reminder, when such a method is used, checked exceptions must be either [caught](http://localhost:44407/docs/errors/sections/exceptions/#catch) or [explicitly rethrown](http://localhost:44407/docs/errors/sections/checked/#rethrow), otherwise the program will not compile. ## Paths An instance of `Path` represents a [path](http://localhost:44407/docs/env/sections/files/#path) in the hierarchical file system. An instance of `Path` can be created in multiple ways. For instance: ```java Path myPath = Path.of(\"path/to/file.txt\"); Path samePath = Path.of(\"path\", \"to\", \"file.txt\"); // Extend a path Path folder = Path.of(\"path/to\"); // identical to myPath Path myPathAgain = folder.resolve(\"file.txt\"); ``` ### Path names **_Note._** If the string `path/to/file.txt` is used to create a Java `Path` (or a Java `File`), then the `/` symbol is interpreted (at runtime) as the path separator _of the operating system_ (OS) that executes the program. So you can safely use this syntax, _regardless of your OS_. Precisely: - if the program is executed on macOS, Linux, Android, etc., then this string will be interpreted as is, - if the program is executed on Windows, then this string will be interpreted as `path\\to\\file.txt`. **_Warning._** If the string `path\\to\\file.txt` is used to create a Java `Path`, then this string will be interpreted _as is_. So the program may run on Windows, but fail on other systems. **_Warning._** Paths are _case sensitive_ on Linux, Android, etc., but _case insensitive_ on Windows and macOS. For maximal compatibility, make sure that path names in your code respect the case of your file and directory names. **_Warning._** Do _not_ use [absolute paths](http://localhost:44407/docs/env/sections/files/#absolute) in your code (e.g. `/home/Alice/workspace/javaProject/myFile.txt`, or `C:\\Users\\Alice\\workspace\\javaProject\\myFile.txt`). Your program may run on your own computer, but will fail on others. ### Working directory **_Warning._** When a Java program is executed, relative paths are understood as paths _from_ the current [working directory](http://localhost:44407/docs/env/sections/files/#wd) (WD). If you need to know the WD, you can use the following (among other possibilities): ```java Paths.get(\"\").toAbsolutePath(); ``` This instruction returns an absolute `Path` to the WD. For instance, ```java System.out.println(Paths.get(\"\").toAbsolutePath()); ``` may output on Windows: ``` C:\\Users\\Alice\\workspace\\javaProject ``` or on macOS: ``` /Users/Alice/workspace/javaProject ``` or on Linux: ``` /home/Alice/workspace/javaProject ``` ### The Path interface Here are examples of outputs for some methods of the `Path` interface (assuming that the WD is `/home/Alice/workspace/javaProject`): ```java Path path = Path.of(\"src/main/../main/resources/myFile.txt\"); // Outputs '/home/Alice/workspace/javaProject/src/main/../main/resources/myFile.txt' System.out.println(path.toAbsolutePath()); // Outputs '/home/Alice/workspace/javaProject/src/main/resources/myFile.txt' System.out.println(path.toRealPath()); // Outputs 'myFile.txt' System.out.println(path.getFileName()); // Outputs 'false' System.out.println(path.isAbsolute()); ``` **_Hint._** The method `String.endsWith` can be used to check whether a file has a certain extension. E.g. ```java // Outputs 'true' path.toString().endsWith(\".txt\"); ``` ## Existence and metadata Static methods of the class `Files` can be used to check whether a file or directory exists, and retrieve metadata about it: ```java Path path = Path.of(\"src/main/resources/myFile.txt\"); System.out.println(\"Exists = \" + Files.exists(path)); System.out.println(\"Is directory = \" + Files.isDirectory(path)); System.out.println(\"Is file = \" + Files.isRegularFile(path)); System.out.println(\"Is hidden = \" + Files.isHidden(path)); System.out.println(\"Size = \" + Files.size(path) + \" bytes\"); System.out.println(\"Last modified = \" + Files.getLastModifiedTime(path)); ``` ## Navigation {#navigation} ```java Path path = Path.of(\"src/main/resources/myFile.txt\"); // Get the parent directory 'src/main/resources' Path dir = path.getParent(); // Contains all files and folders in 'src/main/resources' List children = Files.list(dir).toList(); // Contains all files and folders that have 'src/main/resources' // as ancestor, including 'src/main/resources' itself. List descendents = Files.walk(dir).toList(); ``` ## Manipulation {#manipulation} ```java // Create a directory Path folder = Path.of(\"myFolder\"); Files.createDirectory(folder); // Create nested directories Path subfolder = Path.of(\"myFolder/sub1/sub2\"); Files.createDirectories(subfolder); // Create a file Path file = Path.of(\"myFolder/hello.txt\"); Files.createFile(file); // Move/rename a file Path destination = Path.of(\"myFolder/sub1/bye.txt\"); Files.move(file, destination); // Copy a file Path copy = Path.of(\"myFolder/sub1/sub2/bybye.txt\"); Files.copy(renamedFile, copy); // Delete a file. Files.delete(copy); // Delete a directory. // The directory must be empty. Files.delete(subfolder); ``` "},{"id":9,"href":"/docs/intro/sections/schedule/","title":"Schedule","section":"This course","content":"\n# Schedule\n\nThe course consists of 60 hours of lectures and 30 hours of labs.\n\n## Lectures\n\nBy default, lectures are scheduled:\n\n- Tuesday 10:00 - 12:00\n- Wednesday 08:00 - 10:00\n- Thursday 10:00 - 12:00\n\nAll students attend the same lectures.\n\nOne lecture (to be determined) will be dedicated to a visit to [Raiffeisen Information Service](https://www.ris.bz.it/it/) in Bolzano.\n\n## Labs\n\nBy default, labs are scheduled:\n\n- Tuesday 16:00 - 18:00\n- Friday 14:00 - 16:00\n\nStudents are split in two groups (to be determined) for the labs, with identical content.\nStudents who collaborate on the same [group project](../3-evaluation#group-project) are expected to attend the same lab.\n\nMost labs will be dedicated to the [assignments](../3-evaluation#assignments) for this course.\nTwo or three labs will be dedicated to a presentation and discussion of the advancement of the different [group projects](../3-evaluation#group-project).\n\n## Timetable\n\nSome weeks will see fewer lectures/labs, and schedules or room numbers may vary from one week to the other.\nSo make sure to check the [timetable](http://www.unibz.it/en/timetable/?searchByKeywords=programming+project\u0026sourceId=unibz\u0026fromDate=2024-03-01\u0026toDate=2024-08-31) regularly.\n"},{"id":10,"href":"/docs/interfaces/sections/specification/","title":"Specification and programming interface","section":"Interfaces","content":" # Specification and programming interface ## Specification {#specification} The **specification** of a _method_ usually consists of: - the [computational problem]() that the method solves (if any), and - (if needed,) a description of the _format_ of the input and expected output, and - (if applicable,) a description of the behavior of the program for _invalid_ inputs (e.g. errors thrown by the method), and - (_if useful_,) information about the implementation (e.g. if this may have an impact on performance for certain inputs). **_Example._** ``` boolean isSolvable(int[][] grid) ``` - **_Input:_** a 9 x 9 array of integers with numbers between 0 and 9 - **_Output:_** true is this array represents a sudoku grid with a unique solution (where 0 stands for the absence of value) - **_Errors:_** - if the array's size is not 9 x 9 - if the array contains a number smaller that 0 or greater than 9 If a method has no return type or is not a [pure function](), then the specification may indicate the effect the method on its environment. The specification of a _command_ (for a program with a command line interface) is similar, but may include additional information about the _syntax_ of the command (options, arguments, etc.) ## Programming interface {#programmingInterface} In its simplest form, a **programming interface** is a set of method/command specifications. "},{"id":11,"href":"/docs/intro/","title":"This course","section":"Docs","content":"\n# Structure and organization of the course\n\nThis chapter explains how the course is structured and briefly summarizes its content.\n"},{"id":12,"href":"/docs/git/sections/collaboration/","title":"Basics: network and collaboration","section":"git","content":" # Basics: network and collaboration ## Network In the previous section, Alice created and manipulated a git repository (with two branches). She may also want to _backup_ her work. To this end, she can upload some of her branches to a **remote** machine (often called \"a remote\"). For instance use a cloud hosting service for git repositories (such as GitHub, Gitlab, Bitbucket, etc.). Whenever Alice wants to upload the content of a branch, she can **push** this branch to the remote. Alice may also want to work from another computer (or a virtual machine). She can achieve this by **cloning** the repository from the remote to this second machine. **_Warning._** By default, cloning a repository will only clone the main branch. But other branches (or all branches) can also be cloned explicitly. **_Note._** When two machines share a git branch, each of them has a copy of the _full history_ of the branch. **_Note._** A branch can be shared with _several remote servers_ (e.g. one for releases and one for development or continuous integration). For these two reasons, git is sometimes called a \"distributed\" versioning system. ## Collaboration Enters Bob... Bob may want to collaborate with Alice on her project. He can clone Alice's repository, and add his own commits. In order to synchronize their work, Alice and Bob may agree to share the content of one or several branches (for instance the main branch). **_Warning._** For a smooth collaboration, code on a shared branch is expected to: - compile and - pass all [unit tests]() defined for the project. ### A basic workflow {#workflow} Alice and Bob share the main branch of their repository, and this branch is called `main`. This generally means that there are (at least) 3 copies of this branch: one on Alice's machine, one on Bob's machine, and one on the remote. However Alice and Bob, do _not_ work directly on this branch. Instead, each of them works on his/her own development branch (e.g. called `alice` and `bob` respectively). #### Backup Alice regularly pushes the content of the branch `alice` to the remote, _for backup purposes only_. And so does Bob for the branch `bob`. However, Alice does not need a local copy of `bob`, and Bob does not need a local copy of `alice`. #### Sharing Bob has been working on a new feature, on the branch `bob`. His code compiles and passes all unit tests. He now feels ready to share this code with Alice (via the branch `main`). However, Alice may have added commits to the `main` branch since Bob last looked at it. In order to share his work, Bob: 1. switches to (his local copy of) `main` (with the `git checkout` command), then 1. _updates_ his local copy of `main` (with the `git pull` command), then 1. merges `main` into `bob` (this may require fixing merge conflicts), then 1. merges `bob` into `main`, then 1. pushes `main` to the remote. And Alice follows the same procedure to share her code (using `alice` instead of `bob`). ### To go further There is a vast literature (and diverging opinions) on collaborative git workflows. This is beyond the scope of this course. Note that many of these workflows incorporate so-called \"pull requests\", which are a mechanism for to notify team members of your team that you have completed a feature. Pull requests are not a functionality of git itself, but of (some) git hosting services. To learn more about pull requests, you may consult the corresponding [GitHub](https://docs.github.com/en/get-started/using-github/github-flow) or [Atlassian](https://www.atlassian.com/git/tutorials/making-a-pull-request) guides. "},{"id":13,"href":"/docs/objects/sections/classes/","title":"Class and instance","section":"Objects and classes","content":" # Class and instance A **class** can be viewed as a _blueprint_ for a set of similar objects. For instance, consider the two objects: ```javascript { name: \"Florence\", zipCode: 50100, region: \"Tuscany\" } ``` ```javascript { name: \"Rome\", zipCode: 00100, region: \"Lazio\" } ``` Each of these objects describes a city, and they share the same keys (`name`, `zipCode` and `region`). A possible class for these two objects may enforce this structure, and it could be named `City`. An object that follows this blueprint is called an **instance** of this class. ## Declaration In a typed language (like Java), a class must specifies not only the \"keys\" of its instances, but also their types. For instance, the class City could be declared as follows in Java: ```java public class City { String name; int zipCode; String region; ... } ``` In Java, a class is often declared in a dedicated file. This file must have the _same name_ as the class (e.g. `City.java` in this example). The three variables (`name`, `zipCode` and `region`) are called **attributes** (or sometimes **member variables**). ## Constructor {#constructor} A class also needs a special method called a **constructor**.\nThe constructor is in charge of creating a (fresh) instance of the class.\nIn Java (as in Python, C#, etc.), the constructor does not return the instance itself, but a [reference](http://localhost:44407/docs/objects/sections/objects/#objectRef) (sometimes called \"pointer\") to this instance. **_Note._** A class may have several constructors (with different signatures). ### Writing a constructor in Java The constructor of a Java class must have the _same name_ as the class. For instance: ```java public class City { String name; int zipCode; String region; public City(String n, int z, String r){ name = n; zipCode = z; region = r; } ... } ``` **_Note._** In this example, the variable names `n`, `z` and `r` are not very explicit. However, using `name`, `zipCode` and `region` would be ambiguous (because these names are already used for the attributes of the class). In Java, we can use the prefix `this.` to refer to attribute names, thus eliminating the ambiguity. For instance: ```java public class City { String name; int zipCode; String region; public City(String name, int zipCode, String region){ this.name = name; this.zipCode = zipcode; this.region = region; } ... } ``` ### Calling a constructor in Java A Java constructor is called with the keyword `new`. For instance: ```java City myCity = new City(\"Florence\", 50100, \"Tuscany\"); City yourCity = new City(\"Rome\", 00100, \"Lazio\"); ``` **_Note._** The object that is created in memory contains extra information, in particular a reference to its class. This allows type checking, casts, etc. (more on this later). ## Accessing an object in Java The attributes of an object can be accessed like regular variables, using `.`, followed by the name of the attribute. For instance, ```java City thatCity = new City(\"Siena\", 53100, \"Lazio\"); System.out.println(\"Wrong region: \" + thatCity.region); thatCity.region = \"Tuscany\"; System.out.println(\"Better now: \" + thatCity.region); ``` will output ```java Wrong region: Lazio Better now: Tuscany ``` ## Reference type vs primitive type {#refType} Recall that a Java constructor returns a [reference](http://localhost:44407/docs/objects/sections/objects/#objectRef) to the object that it creates. So in the example above, the value of each variable (`myCity` and `yourCity`) is a reference, not the object itself. This also holds for: - variables of type `String`, - variable with an array type (like `int[] myArray`). The types of these variables (e.g. `City`, `String` or `int[]`) are called **reference types**. **_Syntax._** In Java, types that start with a _capital letter_ (like `City` or `Array`) are usually reference types. Types that are not references types (like `int` or `char`) are called **primitive types**. The _value_ of a reference _cannot_ be output (printed, displayed, etc.) by a program. But this value can be modified or compared to another. Exercise What is the output of the following program? ```java City aCity = new City(\"Matera\", 75100, \"Basilicata\"); City theSameCity = new City(\"Matera\", 75100, \"Basilicata\"); System.out.println(aCity == theSameCity); System.out.println(aCity.zipCode == theSameCity.zipCode); System.out.println(aCity.name == theSameCity.name); ``` Solution ```java false true false ``` Exercise What is the output of the following program? ```java City anotherCity = new City(\"Bologna\", 40100, \"Emilia-Romagna\"); City yetAnotherCity = new City(\"Mantua\", 46100, \"Emilia-Romagna\"); yetAnotherCity.name = anotherCity.name; System.out.println(yetAnotherCity.name); anotherCity = yetAnotherCity; System.out.println(anotherCity.zipCode); System.out.println(anotherCity == yetAnotherCity); ``` Solution \u003e Exercise 2. \u003e \u003e ```java \u003e \"Bologna\" \u003e 46100 \u003e true \u003e ``` ## Passing by value or by reference Programming languages differ in the way arguments are passed to methods. Two common strategies are: - **passing by value**: the method receives as input a _copy_ of each argument, - **passing by reference**: the method receives as input a _reference_ to each argument. Consider for instance the following program (in pseudocode): ```java int myInteger = 0 myMethod(myInteger) print(myInteger) void myMethod(int argument){ argument += 1 } ``` - If the argument is passed by value, then the program will print `0`. - If the argument is passed by reference, then the program will print `1`. ### Java passes by value {#javaByValue} In Java (and many other programming languages, like C, Python, Javascript, etc.), arguments are [passed by value](https://www.javadude.com/articles/passbyvalue.htm). So the above program translated in Java will print `0`. **_Warning._** Consider a method with a [reference type](#refType) argument. Because Java passes by value, this method will receive a copy of this argument. But this is a copy _of the reference_, not a copy of the object itself. Exercise What does the following Java program print? ```java int myInteger = 0; City myFirstCity = new City(\"Florence\", 50100, \"Tuscany\"); City mySecondCity = new City(\"Mantua\", 46100, \"Emilia-Romagna\"); myMethod(myInteger, myFirstCity, mySecondCity); System.out.println(myInteger); System.out.println(myFirstCity.zipCode); System.out.println(mySecondCity.zipCode); public void myMethod(int integer, City firstCity, City secondCity){ integer += 1; System.out.println(integer); firstCity.zipCode = 20590; System.out.println(firstCity.zipCode); secondCity = new City(\"Rome\", 00100, \"Lazio\"); System.out.println(secondCity.zipCode); } ``` Solution ```java 1 20590 00100 0 20590 46100 ``` "},{"id":14,"href":"/docs/unittests/sections/structured/","title":"Code units","section":"Unit tests","content":" # Code units A unit test is meant to test to a small unit of code. This is only possible if the program contains small units of code. Therefore unit testing is closely related to _decomposing_ complex problems into smaller ones (and creating methods that solve these smaller problems). ## Benefits Possible benefits of decomposing complex methods into smaller ones are: - readability, - easier debugging, - opportunities to factorize code (the same small methods can be called in several places), - easier collaboration (two person modifying the same method in parallel is less likely if the method is small), Some good indicators that auxiliary methods may be helpful are: - multiple levels of nested blocks (\"curly braces\" in Java), - a loop that contains a important amount of code. Exercise Simplify (and factorize) the following pseudocode using auxiliary methods: ```perl if(){ while(){ if(){ } else { } } } else { if(){ } else { } } ``` Possible solution ```perl method1() method1(){ if(){ method2() } else { method3() } } method2(){ while(){ method3() } } method3(){ if(){ } else { } } ``` "},{"id":15,"href":"/docs/unittests/sections/tdd/","title":"Development driven by unit tests","section":"Unit tests","content":" # Development driven by unit tests **Test-driven development (TDD)** consists in converting a program's requirements into test cases, _before_ the program is fully developed. Note that this approach is _not_ restricted to unit tests. ## In practice For a _non-trivial_ method: 1. Create a method stub (e.g. `return null` is the method's return type is a reference type). 2. [Specify](http://localhost:44407/docs/interfaces/sections/specification/) the expected behavior (input and expected output) of the method. 3. Write one or several test(s) for this method, _illustrating_ the specification. 4. Implement the method until the test(s) is (are) successful. **_Hint._** Your IDE can generate method stubs. **_Note._** This implementation may be temporary. For instance, it may be refactored later on (moving code where it logically belongs, factorizing duplicate code, etc.). However, the tests that were written before refactoring are (usually) still relevant afterwards, because they correspond to functional requirements. ## Benefits Some benefits of TDD are: 1. Starting from an _example_ often helps clarifying what a method should do. 1. TDD provides intermediate _objectives_ (milestones) to a developer. 1. The sooner a bug is identified (during the development process), the easier it is to fix. 1. The program is likely to be more _robust_, because development was guided by requirements (rather than technologies or algorithmic considerations). 1. Each unit test created during TDD provides an alternative _entry point_ (\"green arrow\" in an IDE) into the codebase (in addition to the \"main\" method). This allows experimenting with a specific feature _in isolation_, ignoring aspects that are not relevant for this feature (e.g. GUI, network, data storage, etc.). ## Example In our game, let us consider once again the method `EventHandler.deleteUnit`, which modifies the current board when a unit deletion instruction is received. ### Problem decomposition First, let us decompose this method into simpler ones. For instance as follows: ```java public class Backend implements EventHandler { private Snapshot currentSnapshot; ... void deleteUnit(int rowindex, int columnIndex) { // reduce by 1 the number of remaining actions for the active player decrementNumberOfRemainingActions(); // delete the unit (leaving a blank tile) currentSnapshot.getBoard().removeUnit(rowIndex, columnIndex); // shift up or down the units that followed it (if any) shiftUnitsInColumn(columnIndex); // perform resulting unit merges (if any) performUnitMerges(); // if there is no more action for the active player, then end the turn if (currentSnapshot.getNumberOfRemainingActions() == 0){ endTurn(); } } ... } ``` At first sight, the auxiliary method `decrementNumerOfRemainingActions` seems trivial, so it may not benefit from unit tests. The method `shiftUnitsInColumn` seems relatively simple as well. However, the two remaining ones (`performUnitMerges` and `endTurn`) seem more complex. So it could be helpful to decompose them and/or devise unit tests for them. Let us focus on `endTurn`. It may for instance be decomposed as follows: ```java void endTurn() { // perform attacks for units whose counter is 1 // (on the active player's side) performAttacks(); // change the active player swapActivePlayer(); } ``` And `performAttacks` may in turn be decomposed as follows: ```java void performAttacks() { int maxColumnIndex = currentSnapshot.getBoard().getMaxColumnIndex(); // for each column for (int columnIndex = 0; columnIndex \u003c= maxColumnIndex; columnIndex++){ performAttacks(columnIndex); } } ``` ```java void performAttack(int columnIndex) { // for each combined unit in this column (for the active player), // starting from front units for (Unit unit: getCombinedUnits(columnIndex)){ int countdown = unit.getAttackCountdown(); // if the unit is ready to attack if(countdown \u003e 1) { unit.setAttackCountdown(countdown - 1); } else { attack(columnIndex); } } } ``` ### Unit test The auxiliary method `attack` seems non-trivial, so it may be a good candidate for unit testing. One possible (\"happy path\") test could be: Input (for column 1): ![](/img/test/board_input.png) ![](/img/test/bob_input.png) ![](/img/test/alice_input.png) Expected output: ![](/img/test/board_output.png) ![](/img/test/bob_output.png) ![](/img/test/alice_output.png) "},{"id":16,"href":"/docs/errors/sections/exceptions/","title":"Exceptions","section":"Errors","content":" # Exceptions Programming languages may significantly differ in the way they support errors messages. Java relies on a mechanism called _exceptions_. Several other languages use exceptions, for instance C++, C#, PHP, Python or Ruby. However, the purpose of exceptions may vary from one language to another. An **exception** is an object or data structure that stores information about an exceptional condition encountered during the execution of a program. ## in Java In Java, an exception is an _object_, instance of the native class `Exception`. All exception types (e.g. `IOException`) are subclasses of `Exception`. By convention, a class name for an exception: - ends with the word `Exception`, and - provides information about the cause of the exception. ### Stack trace By default, when an exception is **thrown**, the program interrupts its execution, and the current [call stack](http://localhost:44407/docs/errors/sections/callstack/) is sent to an output stream called `System.error`. This output is called the **stack trace** (because it allows tracing back the method calls that led to the exception being thrown). For instance, consider the following class: ```java {linenos=true} public class MyClass{ void myMethod(){ Integer.parseInt(\"clearlyNotANumber\"); } } ``` When `myMethod` is executed, the following stack trace is printed to `System.error`: ``` java.lang.NumberFormatException: For input string: \"clearlyNotANumber\" at java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67) at java.base/java.lang.Integer.parseInt(Integer.java:668) at java.base/java.lang.Integer.parseInt(Integer.java:786) at Myclass.myMethod(Myclass.java:4) ``` The explanation is the following: - `myMethod` (Line 4) calls `Integer.parseInt(String string)`, - `Integer.parseInt(String string)` calls `Integer.parseInt(String string, int radix)` with the same string as argument, and a value of `10` for the [radix](https://en.wikipedia.org/wiki/Radix) (meaning that the string should represent an integer in base 10). - `Integer.parseInt(String string, int radix)` throws an exception, because the string \"clearlyNotANumber\" does not represent a (base 10) number. **_Hint._** Your IDE allows you to navigate through Java's source code to trace the cause of an exception. **_Hint._** To debug your code, by default: 1. find the _last_ method (from bottom to top) in the stack trace that was written by you (in this example `Myclass.myMethod`), 2. using our IDE, create a breakpoint at the indicated line for this class (4 in this example), 3. run your program in debug mode (e.g. clicking on the \"bug\" icon of your IDE). ### Throwing an exception {#throw} An exception can be thrown with the keyword `throw`, as follows: ```java boolean isSolvable(int[][] sudokuGrid){ if(sudokuGrid.length != 9){ throw new IllegalArgumentException(\"A sudoku grid should have 9 rows\"); } if(sudokuGrid[0].length != 9){ throw new IllegalArgumentException(\"A sudoku grid should have 9 columns\"); } ... } ``` Classes for native Java exceptions usually have several constructors, one of which takes a string as input. For instance, in the example above, we used the constructor `IllegalArgumentException(String errorMessage)`. ### Catching an exception {#catch} When a runtime exception is thrown by a method, the method immediately below it in the stack trace can either **rethrow** the exception, or **catch** it. If some method in the call stack catches the exception, then the program is _not interrupted_. Instead, control is passed to the catching method. In other words, when an exception is thrown, the JVM \"pops\" method calls from the call stack, until either: - a catching method is found, or - the call stack is empty (in which case the program is interrupted). For instance, let us modify `myMethod` above so that: - it takes as input a string (maybe supplied at run time), - if this string can be converted to an integer, then it returns this integer, - otherwise it returns `0`. This can be achieved by catching the exception thrown by `Integer.parseInt`. Syntactically, this is done with a `try/catch` block, as follows: ```java int myMethod(String inputString){ try{ return Integer.parseInt(inputString); } catch (NumberFormatException e) { return 0; } } ``` In this example: - the code inside the `try` block is always executed, - the code inside the `catch` block is only executed if a `NumberFormatException` is thrown during the execution of the `try` block, - the program is _not_ interrupted. ### Chaining The `catch` clause may itself throw an exception. This is a very common pattern. In particular, it can be used to add information about the context in which an error occurred. In such a case, a common practice consists in **chaining** these two exceptions. Most native Java classes for exceptions have a dedicated constructor for this purpose: it takes as input a string (for the error message), and the exception that was caught. For instance, we can modify our example in such a way that if the input string cannot be converted to an integer, then the program gets interrupted, but with a less generic error message: ```java {linenos=true} public class MyClass{ int myMethod(String inputString){ try{ return Integer.parseInt(inputString); } catch (NumberFormatException e) { throw new IllegalArgumentException(\"Please provide a valid number\", e); } } } ``` Note in this example the second argument `e` of the constructor for `IllegalArgumentException`. If the method is called as follows, ```java myMethod(\"notANumberEither\"); ``` then the program will be interrupted, with the following stack trace: ``` Java.lang.IllegalArgumentException: Please provide a valid number at MyClass.myMethod(MyClass.java:6) Caused by: java.lang.NumberFormatException: For input string: \"notANumberEither\" at java.base/java.lang.NumberFormatException.forInputString(NumberFormatException.java:67) at java.base/java.lang.Integer.parseInt(Integer.java:668) at java.base/java.lang.Integer.parseInt(Integer.java:786) at MyClass.myMethod(MyClass.java:4) ``` "},{"id":17,"href":"/docs/env/sections/files/","title":"Hierarchical file system","section":"Development environment","content":" # Hierarchical file system ## Tree Most operating system expose files as a _tree_ (or possibly several trees for Windows). **_Definition._** A (nonempty) **tree** is either: - a single node (called a **leaf**), or - a node with one or several children that are trees. In this tree, non-leaf nodes are directories, and the leaves can be files, executables, links, empty directories, etc. For instance: ```bash ├── bin │ ├── echo │ └── ... ├── home │ ├── alice │ │ ├── .bashrc │ │ ├── .m2 │ │ │ └── ... │ │ ├── Desktop │ │ │ └── ... │ │ ├── music │ │ │ └── thatSong.mp3 │ │ └── workspace │ │ └── pp │ │ ├── assignments │ │ │ └── ... │ │ └── project │ │ ├── .git │ │ │ └── ... │ │ ├── src │ │ │ └── HelloWorld.java │ │ └── test │ │ └── testHelloWorld.java │ └── bob │ ├── .bashrc │ ├── Desktop │ │ └── ... │ └── music │ ├── thatSong.mp3 │ └── anotherSong.mp3 └── ... ``` **_Terminology._** In this course, we will use the terms \"folder\" and \"directory\" interchangeably. **_Terminology._** \"File\" is sometimes used (e.g. in the Linux documentation) as a generic term for all nodes in this tree (in combination with \"directory file\", \"executable file\", \"regular file\", etc.) We will _not_ follow this terminology. Windows may expose several trees (e.g. one per physical device). ## Path {#path} **_Definition._** In such a tree, a **path** from a directory _s_ to an arbitrary node _t_ is either: - `.` if _s_ and _t_ are the same node, or - `..` if _t_ is the parent of _s_, or - the name of _t_ if _s_ is the parent of _t_, or - a path from _s_ to some node _i_, followed by `/` (or `\\`on Windows), followed by a path from _i_ to _t_. For instance (on macOS, Linux, etc.), in the tree above: - `home/alice/workspace/pp/project/src/HelloWorld.java` is a path from the root to the file `HelloWorld.java`, - `workspace/pp/project/src/HelloWorld.java` is a path from the directory `alice` to the file `HelloWorld.java`, - `../../bob/Desktop` is a path from Alice's Desktop to Bob's Desktop, - `../../bob/../bob/./Desktop` is another path from Alice's Desktop to Bob's Desktop. Exercise How many paths are there from a directory to an arbitrary node? Solution (Countably) infinitely many. **_Warning._** Some operating system (Windows, macOS) use _case-insensitive_ paths, whereas others (Linux, Android) use _case-sensitive_ paths (this may also vary depending on physical storage devices). For instance, on Windows, `src/HelloWorld.java` and `src/helloworld.java` are the _same path_. In order to make sure that your code is portable: - always use _case-sensitive_ paths in your code (i.e. respect the names of your files, folders, executables, etc.), - do not create two files (or subfolders, executables, etc.) in the _same_ folder with identical names modulo upper/lower case (e.g. `Readme.md` and `README.md`). **_Convention._** In what follows (unless explicitly stated), we will adopt by default the conventions for path names adopted on Linux. In particular, we will use `/` as a separator, and case-sensitive file and folder names. ### Absolute path {#absolute} **_Definition._** An **absolute path** is a path prefixed with: - `/` on macOS, Linux, Android, IOs, etc. - a capital letter followed by `:\\` on Windows, where the letter identifies a physical device, disk partition, etc. In particular, the identifier of the main partition is often the letter `C`, in which case absolute paths (within this partition) are prefixed with `C:\\`. An absolute path is always a path _from the root of the tree_. For instance (on macOS, Linux, etc.), `/home/alice/workspace/pp/project/src/HelloWorld.java` is an absolute path to the file `HelloWorld.java` A few simple observations: - two different files may share the _same name_ (but cannot share an absolute path), and - two files with the same name _may or may not_ be identical. E.g. in the above example, the two files named `thatSong.mp3` may or may not be identical. ### Relative path **_Definition._** A **relative path** is a path that is not absolute. For instance (on macOS, Linux, etc.), `../../bob/Desktop` is a path to to Bob's Desktop _relative to_ Alice's Desktop. Note that if _p_ is a relative path, then _p_ prefixed with `./` (or `.\\` on Windows) is a path equivalent to _p_. This prefix is sometimes used to emphasize that a path is relative (among other purposes). ## Working directory {#wd} Each _process_ (e.g. a process that executes a Java program) has a **working directory**, which is a directory of the hierarchical file system. This directory may vary depending on the program and/or how it was started. Many programs (implicitly) interpret a relative path as _relative to their working directory_, regardless of whether the path is prefixed with `./` (or `.\\` on Windows). In particular, this is the case of: - Java programs, - file browsers, - shells. ## Home directory Each user of a system has its own **home directory**. E.g. in this example: - `/home/alice/` for Alice - `/home/bob/` for Bob **_Warning._** The home directory is usually _not_ the root of the tree (even if there is a single user on the machine). ### Absolute paths to the home directory The home directory (of a regular user) is normally: - `/home/` on Linux/BSD, - `/Users/` on macOS, - `/User/` on iOS, - `/data/media/⟨userId⟩` on Android, - `:\\Users\\` on Windows (e.g. `C:\\Users\\`). On Linux and macOS, the alias `~` can be used as an absolute path to the current user's home directory. For instance, in the above example, if Alice is logged in, then `~/music/thatSong.mp3` and `/home/alice/music/thatSong.mp3` are two absolute paths to the same file. ### Access restriction Files and programs within the home directory of a user can usually be accessed by this user (or a system admin). Therefore programs that can be executed by _all users_ are usually located in _other directories_ (e.g. the program `/bin/echo` in the example above). Access restrictions (read, write and/or execute) may apply to the content of such directories. Notably, on Linux systems, (most of) the content of these directories can only be modified by a system admin. ### Hidden files and directories The home directory often contains files (resp. directories) whose names are preceded with a `.` (e.g. the file `/home/alice/.bashrc` in the above example). These are sometimes called \"dot files\" (resp. \"dot folders\"). On Linux and macOS, dot files and dot folder are [hidden](https://en.wikipedia.org/wiki/Hidden_file_and_hidden_directory) by default in a terminal or a file browser. On Windows, a (dot or not) file or folder can also be hidden, via a dedicated \"hidden\" attribute. Hidden files and directories may be used to store (user-specific) parameters or options for a program. For instance, the [configuration file](https://en.wikipedia.org/wiki/Configuration_file) `~/.gitconfig` can be used to declare parameters (e.g. user identifier, etc.) or options (e.g. disable default fast-forward merge, etc.) to be used with git. **_Hint._** Configuration files are a convenient way to save your personal preferences and use them on several machines. For instance, you may need to logging to a remote server via [ssh](https://en.wikipedia.org/wiki/Secure_Shell) to perform some tasks (e.g. deploy a database or run costly computations). In such a scenario, you can upload dot files to your home directory on this server. Hidden files or directories may serve other purposes. For instance, the dot folder `~/.m2` is used by Maven to store (in one place) the Java libraries that are required (as dependencies) by any Java project present in the home directory. Hidden files or directories may also contain information specific to a subdirectory. For instance, every git [repository]() (a.k.a. \"project\") contains a dot folder `.git` that stores the full history of modification made to the repository. ### Usage and layout Your home directory is where you generally want to store your projects, documents, scripts, etc. You are free to structure it as you like (using sub-directories). Make sure that this structure allows you to _retrieve your own work_ easily. **_Warning_**. When you download or create a project/document in your home directory, _choose its location_. Do _not_: - let an application decide this location for you, - rely exclusively on the \"recently opened\" feature of an app to locate your files, - store files and project directly at the root of your home directory. **_Warning_**. Aside from a few exceptional cases, your home directory should _not_ contain multiple copies of a project or document. **_Hint._** It can be difficult for a new developer to figure out when to accept the default directory or layout suggested by a program, and when to overwrite it. As a (soft) rule of thumb, you generally want to _choose the location_ of: - a file downloaded from your browser (or mail client), - a project created with your IDE, - a cloned git repository, - a file created with an app, - etc. Conversely, it is generally recommended to _follow suggestions_ in the following cases: - internal structure of a project (typically the one generated by an IDE): e.g. the [standard directory layout](https://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html) for a Maven project, or the [standard directory structure](https://www.geeksforgeeks.org/folder-structure-for-a-node-js-project/) of a Node JS project. - software installed outside of your home directory, - location of dot files and folders, - etc. "},{"id":18,"href":"/docs/interfaces/sections/java_interfaces/","title":"Java interfaces","section":"Interfaces","content":" # Java interfaces A Java interface is a [programming interface](http://localhost:44407/docs/interfaces/sections/specification/#programmingInterface) with additional (object-oriented) features. Syntactically, a Java interface is similar to a class. But (in its simplest form), it contains no code. Instead, it [specifies](http://localhost:44407/docs/interfaces/sections/specification/#specification) the behavior of some methods (which are **implemented** in some _classes_). ## Examples {#snapshotExample} The implementation of our game contains an interface called `Snapshot`, which describes what a game snapshot is. This interface specifies (among others) a method called `getSizeOfReinforcement`, as follows: ```Java public interface Snapshot { ... /** * Returns the number of units that will enter the board if reinforcement * is called for the input player. */ int getSizeOfReinforcement(Player player); ... } ``` Note that this description contains _no code_. A Java interface acts not only as documentation, but also as a _contract_ : any (non-abstract) class that implements this interface must implement all methods declared in the interface (otherwise the program will not compile). A Java interface can be used to specify how two components of a system _communicate_ (before the interface is even implemented!). For instance, the `Snapshot` interface specifies which information must be provided by our backend to the component in charge of displaying the game on screen. The name of an interface can be used as a [reference type]() (similarly to the name of a class). For instance, the `Snapshot` interface also specifies a method ```java Board getBoard(); ``` which must return an object of type `Board`. And `Board` is itself an interface, which specifies the information needed to draw the game board (units, position, etc). Here is for instance a fragment of the `Board` interface: ```Java /** * Board for an ongoing game. * This is a two-dimensional grid. * * Tile coordinates are natural numbers and start at 0. * The top left tile has coordinates (0,0). */ public interface Board { ... /** * Returns true if the input coordinates are within the board's boundaries */ boolean areValidCoordinates(int rowIndex, int columnIndex); /** * Removes the unit standing at the input coordinates, and does nothing * if there is none. */ void removeUnit(int rowIndex, int columnIndex) throws CoordinatesOutOfBoardException; ... } ``` Finally, the interface `DisplayManager` specifies a method that can be called (e.g. from the backend) to draw a `Snapshot` on screen (together with a message): ```Java public interface DisplayManager { ... /** * Displays the input snapshot on screen, as well as the input message. */ void drawSnapshot(Snapshot snapshot, String message); ... } ``` Observe that these interfaces only specify _what_ classes should implement, not _how_. In other words, these interfaces specify how components can communicate without exposing unnecessary implementation details. ## When to use a Java interface? Technically, Java interfaces are not needed in a project. But they can make collaboration within a team of developers significantly easier. In particular: - An interface is a convenient way to expose what is needed to interact with your code, while hiding the details of your implementation. For instance, the method `drawSnapshot` (mentioned above) can be called to draw a snapshot on screen, without knowing how this method is implemented. - As a _contract_, an interface allows two programmers to work independently, ensuring interoperability between the methods and/or components that they are respectively developing. ## Inheritance An interface in Java can extend another interface, like a class can extend another class, with the same keyword `extends`. However, Java interfaces support _multiple inheritance_ (whereas java classes do not). This means that an interface _A_ can extend two interfaces _B_ and _C_ even if _B_ and _C_ do not extend each other. ## Implementing an interface In Java, the keyword `implements` is used to indicate that a class implements an interface. For instance: ```Java public class SnapshotImpl implements Snapshot { ... } ``` **_Note._** It is good practice to avoid a class and an interface with the same name (even if they describe the same objects). To differentiate them, you may for instance use the suffix `Impl`, as illustrated above. Consider a class _C_ that implements an interface _I_ : - if _C_ is abstract, then it **_can_** implement some of the methods declared in _I_ - if _C_ is not abstract, then each method declared in _I_ **_must_** be implemented in _C_ (or some superclass of _C_ ), otherwise the program will not compile. Exercise The program represented by the following diagram does not compile. Can you see why? ![](/img/diagrams/plantuml/abstract_inherit.svg) Solution The class `Butterfly` does not implement the method `sleep`. \u003e **_Note._** \u003e In this example, the class `Butterfly` inherits an implementation of `boost` (from `AbstractUnit`), and [overrides](http://localhost:44407/docs/objects/sections/methods/#overriding) it. \u003e This is _not_ an error. Since Java interfaces support multiple inheritance, a Java class can implement several interface that do not extend each other. For instance, the class `Unicorn` could implement an interface `Animal` and another interface `ImaginaryCreature`, even though none of these two interfaces extends the other (not all animals are imaginary, and not all imaginary creatures are animals). This would be declared as follows: ```Java public class Unicorn extends MobileUnit implements Animal, ImaginaryCreature { ... } ``` Exercise The program represented by the following diagram does not compile. Can you see why? ![](/img/diagrams/plantuml/multiple_inherit.svg) Solution The class `Unicorn` does not implement the method `hide`. ## Interfaces vs abstract classes In theory, Java's interfaces and abstract classes serve different purposes: - abstract classes are meant to factorize code (i.e. avoid redundant code), whereas - interfaces are meant to document code and act as a contract. However, in practice, they have partially overlapping features, which may be confusing. In particular: - an abstract class can have [abstract methods](), which behave similarly to interface methods (with the additional constraint that an abstract method must be implemented by _at least one_ subclass). - Since Java 8 (2014), interfaces can carry code, in so-called [default methods](). This feature was introduced for backward compatibility reasons, but arguably contradicts the meaning of the term \"interface\". An benefit of default methods (i.e. methods implemented in interfaces) is that they allow multiple inheritance of implemented methods (since interfaces allow multiple inheritance), which is not possible with classes. For this reason, some authors (like Joshua Bloch) recommend using default methods instead of abstract methods. However, a program where interfaces play the role of abstract classes may be confusing for less experienced Java developers. For this course, we chose to present Java interfaces from a more traditional (pre-Java 8) perspective, because this perspective is arguably easier to understand, and because this is still the dominant usage of Java interfaces. However, for your project, feel free to deviate from this model if you think that this is appropriate (in particular if you need multiple inheritance). "},{"id":19,"href":"/docs/build/sections/layout/","title":"Layout","section":"Build automation","content":" # Layout ## The standard directory layout By default, a Maven project is expected to comply with the so-called \"standard directly layout\". **_Warning._** We restrict here the layout to files and folders that you are likely to use in your project. A comprehensive description can be found [here](https://maven.apache.org/guides/introduction/introduction-to-the-standard-directory-layout.html). ```bash ├── pom.xml ├── README.md ├── src │ ├── main │ │ ├── java │ │ │ └── ... │ │ └── resources │ │ └── ... │ └── test │ ├── java │ │ └── ... │ └── resources │ └── ... ... ``` Here is the intended purpose of these files and directories (all [paths](http://localhost:44407/docs/env/sections/files/#path) are from the root of the project): | file or directory | content | | ----------------------- | ------------------------------------------------------------------ | | `pom.xml` | Maven configuration for the project | | `README` or `README.md` | (human readable) description of the project | | `src/main/java` | source code of the project | | `src/main/resources` | resources for the project (e.g. configuration files, images, etc.) | | `src/test/java` | source code for unit tests | | `src/test/resources` | resources for unit tests (e.g. data) | **_Note._** By default, the content of the `src/main/resources` directory is automatically included in a [jar](http://localhost:44407/docs/build/sections/packaging/#jar) generated with Maven. **_Hint._** Your IDE can generate this folder structure (together with a minimal `pom.xml` file). For instance, with IntelliJ, click on `File/New/Project`, and then select \"Maven\" as the \"Build system\": ![](/img/build/maven_project.png) **_Hint._** In some cases, a folder structure and `pom.xml` file that are tailored to a certain framework (like JavaFX or JSP) can be generated. This is called a **_maven archetype_**. ## The `target` directory When building a Maven project, some files and directories are _generated_. By default, the directory called `target` (at the root of the project) contains the output of the build, in particular: - the bytecode (i.e. `.class` files), - the generated `.jar` file(s), if any. **_Hint._** Since it is automatically generated, the `target` directory can be safely deleted. ## Maven and Git The `pom.xml` file should usually be committed. However, the following should _not_ be committed (i.e. should be ignored via `.gitignore`): - the `target` directory, - any other content generated during the build (e.g. generated source code, etc.). "},{"id":20,"href":"/docs/recursion/sections/nary/","title":"N-ary recursion","section":"Recursion","content":" # N-ary recursion **_Definition._** A recursive method that is _not_ linear recursive uses **n-ary recursion**. Specific cases include: - **binary recursion** if a method performs up to two recursive calls each time it is executed, - **ternary recursion** if it performs up to three recursive calls each time it is executed, - etc. **_Examples._** The algorithm seen [earlier](http://localhost:44407/docs/recursion/#printFiles) to print all files in a folder uses n-ary recursion. All the binary tree algorithms seen [earlier](http://localhost:44407/docs/recursion/#binaryTrees) use binary recursion. ## Divide and conquer The **divide-and-conquer** paradigm is a variation of the methodology seen [earlier](http://localhost:44407/docs/recursion/#methodology) to solve a problem recursively. In the divide-and-conquer approach, the smaller inputs $I_1$, .., $I_k$ usually have (nearly) the _same size_. Divide-and-conquer has been instrumental in discovering efficient solutions to pervasive computational problems. Well-known examples include: - the [Karatsuba algorithm](https://en.wikipedia.org/wiki/Karatsuba_algorithm) for multiplying two numbers, - the [Strassen algorithm](https://en.wikipedia.org/wiki/Strassen_algorithm) for matrix product, - Mergesort for (stable) sorting. ### Example: Mergesort Mergesort is one of (many) algorithms commonly used to sort an array, i.e. to solve the following problem: \u003e **_Input:_** an array $A$ \u003e \u003e **_Output:_** a sorted array with the same elements as $A$ **_Observation._** As we saw [already](http://localhost:44407/docs/abstractdatatypes/sections/sorting/), the array can be of any type (int, String, City, Unit, etc.), and the sorting criterion can be any [total preorder](http://localhost:44407/docs/background/sections/order/#preorder) over this type. The Mergesort algorithm may be summarized as follows: - **_(Base case)._** If $A$ has size $1$, then return it ($A$ is already sorted). - **_(Inductive case)_**. Otherwise: - _(divide):_ partition $A$ into its left half $A_1$ and its right half $A_2$, - _(solve):_ sort $A_1$ and sort $A_2$ (recursively), - _(combine):_ merge (the sorted versions of) $A_1$ and $A_2$. Here is a naive implementation, in pseudocode: ```java // Returns a sorted array that contains the same elements as A. Type[] mergesort(Type[] A) { // Base case: the input array has size 1, it is already sorted. if(A.length == 1){ return A } // Inductive case (the input array has size \u003e 1) // Compute the middle index (rounded down) int middleIndex = (A.length - 1) / 2 // Copy the left half of A into a new array Type[] leftHalf = copy(A[0 .. middleIndex]) // Sort it leftHalf = mergesort(leftHalf) // Copy the right half of A into a new array Type[] rightHalf = copy(A[middleIndex + 1 .. A.length - 1]) // Sort it rightHalf = mergesort(rightHalf) // merge the two sorted halves return merge(leftHalf, rightHalf) } ``` **_Warning._** This implementation is suboptimal (some arrays can be reused). We only used it to keep the explanation simple. Exercise To complete this algorithm, implement (in pseudocode) the auxiliary method ```java Type[] merge(Type[] A, Type[] B) ``` that takes as input two sorted arrays `A` and `B`, and returns a sorted array that contains their values. Possible solution Iterate over `A` and `B` in parallel: - if `A[0]` (resp. `B[0]`) is smaller than `B[0]` (resp. `A[0]`), then: - add `A[0]` (resp. `B[0]`) to the output array, and - repeat with `A[1]` and `B[0]` (resp. `A[0]` and `B[1]`), - etc. - when reaching the end of `A` (resp. `B`), add the remaining elements of `B` (resp. `A`) to the output array. More precisely: ```java Type[] merge(Type[] A, Type[] B){ // Output array Type[] C = new Type[A.length + B.length] // Index to iterate over A int a = 0 // Index to iterate over B int b = 0 // Index to iteratate over O int c = 0 while (a \u003c A.length \u0026\u0026 b \u003c B.length) { if(A[a] \u003c B[b]) { C[c] = A[a] a++ } else { C[c] = B[b] b++ } // If we reached the end of A, if(a == A.length){ // append all remaining elements of B to the output array. append(B, b, C, c) } else // Otherwise we reached the end of B. // So append all remaining elements of A to the output array. append(A, a, C, c) } } append (Type[] A, int a, Type[] C, int c) { while (a \u003c A.length){ C[c] = A[a] a++ } } ``` **_Merge sort in action._** You can find visual illustrations of the execution of merge sort online. For instance [this animation](https://imgur.com/gallery/HU2tfzo), or [this (more accurate) one](https://willrosenbaum.com/blog/2022/merge-sort/). **_Observation._** Merge sort is a [stable](http://localhost:44407/docs/abstractdatatypes/sections/sorting/#stable) sorting algorithm. ## Tree and graph traversal [Earlier](http://localhost:44407/docs/recursion/#binaryTrees) in this chapter, we used different algorithms to traverse a binary tree, where nodes were instances of the following class: ![](/img/diagrams/plantuml/nodeWithChar.svg) One of these algorithms was the so-called \"pre-order traversal\": ```java traverse(Node root){ // inductive case only (do nothing in the base case) if (root != null){ print(root.label) traverse(root.leftChild) traverse(root.rightChild) } } ``` This algorithm naturally generalizes to trees where nodes may have more than two children. Nodes in such a tree can be represented as instances of the following class: ![](/img/diagrams/plantuml/node_nary.svg) And the algorithm becomes: ```java traverse(Node root){ if (root != null){ print(root.label) foreach child in root.children { traverse(child) } } } ``` This algorithm can in turn be adapted to traverse a _graph_. More precisely, to explore all nodes reachable (directly or transitively) from a given source node in the graph. **_Warning._** When applied to a graph, the algorithm above: - may not terminate (if the graph contains a loop), - may process some nodes multiple times (even if the graph is acyclic). ![](/img/graphs/graph_labeled_small.svg) In order to avoid this, a common technique consists in labelling nodes in a graph with an additional boolean attribute `visited`, which indicates whether a node has already been visited during a traversal: ![](/img/diagrams/plantuml/node_nary_visited.svg) And the algorithm becomes: ```java traverse(Node root){ if (root != null \u0026\u0026 !root.visited){ root.visited = true print(root.label) foreach child in root.children { traverse(child) } } } ``` **_Terminology._** This approach is often called **depth-first** exploration of a graph. Exercise Consider the following graph. ![](/img/graphs/graph_labeled.svg) What does the above algorithm print for input node A, assuming that the children of each node are sorted in label's alphabetical order? Solution A B D F C E ## Minimax Minimax (or Min-max) is a recursive algorithm with applications in games, robotics, decision making, etc. Intuitively, Minimax models taking a conservative decision, i.e. a decision that minimizes risk, assuming that the worst will happen if it can. Numerous extensions and heuristics have been devise for Minimax. Here we only focus on the algorithm in its basic form. Minimax is easy to explain in the context of a turn-based two-player game like chess. In the base case, To each board state, one associates a Assume that Player A needs to decide his/her next move. Given the current board state, consider the set of board states that can be reached in one move. If any of these states is a winning one (e.g. check mate), then select player can take any any of them. Consider the set of board states that the If there is no winning move, then consider the set And assume that Consider a two-player game like chess, where each player plays in alternation. We assume a heuristic function `score` that assigns a score to each board state Here is a naive algorithm (in pseudocode) to enumerate all possible states of the game that are reachable after exactly $k$ moves: ``` enumerate(State currentState){ foreach state in legalMoves(currentState){ } } ``` A minimax algorithm selects the next move for Player 1 in a two-player game, assuming that Player 2 two will always take the the next In its simplest form, it models a two-player game "},{"id":21,"href":"/docs/project/sections/board_game/","title":"Option 2: board game","section":"Project","content":" # Option 2: board game The second project option available to you consists in developing a video game with mechanics analogous to the ones of [Might \u0026 Magic: Clash of Heroes](https://www.dotemu.com/games/might-magic-clash-of-heroes-definitive-edition/) or [Legend of Solgard](https://snowprintstudios.com/solgard/). If you choose this option, you will be provided: - a basic graphical user interface (GUI) that you can reuse and/or customize, - examples during lectures that you may adapt to your project. ## Requirements The minimal requirement to submit your project is a _player vs player_ game playable on a _single machine_. But of course, you are free to go further and add your own features. Among other possibilities, you could _for instance_: - implement new mechanics (e.g. a rock-paper-scissor logic for unit encounters, events that may affect the board, etc.), - make the game deterministic (i.e. eliminate randomness), - create units with specific behaviors, - implements scripted encounters (\"boss fights\"), - implement a story, character progression, etc., - develop a _player vs bot_ mode, - etc, **_Note._** If you choose the last options in the list above (player vs bot), then you may benefit from an algorithm seen in the chapter on [recursion](http://localhost:44407/docs/recursion/). Besides, if several groups choose this option, we may organize a competition between bots (provided that they play by the same rules). ## Guidelines ### GUI The source code for the GUI can be cloned from [GitHub](). The project is designed so that: - you can develop a fully functional game (player vs player or player vs bot) by focusing exclusively on the _backend_ (i.e. the mechanics of the game), without modifying the GUI. - backend and frontend are _decoupled_. Communication between frontend and backend is specified via [Java interfaces](http://localhost:44407/docs/interfaces/). It revolves around the notion of a game _snapshot_, which contains all the information needed to describe a state of the game (equivalently, you can think of a snapshot as a save state). In particular, snapshots are independent of a specific GUI. For instance, a method is available that allows you to pass a snapshot to the GUI component. When you call this method, the snapshot will be drawn on screen, replacing the previous one (if any). As input, your code receives the next action of the active player (for instance, delete the unit present on a specific tile). These are again specified by an interface. Your code should react accordingly: modify the current snapshot, and then send it the GUI component for display. The `README.md` file (at the root of the project) contains a description of the different components and interfaces, as well as building instructions, and explains where your code could fit. _Read it carefully_ before you start working on your project! **_Note._** You are of course free to modify the interfaces that come with the project. But this may require modifying the implementation of the GUI. **_Disclaimer._** By design, the project compromises _performance_ for _simplicity_ and _modularity_. This is _not_ how a resource intensive game would be implemented. More generally, this exercise is not meant to teach you game development, but general-purpose programming and problem solving. "},{"id":22,"href":"/docs/project/","title":"Project","section":"Docs","content":" # Project Students enrolled in this course are expected to deliver a **group project**. ## Two alternative options You can develop either: 1. A [project of your choice](http://localhost:44407/docs/project/sections/free_project/), or 2. Your own version of the [board game](http://localhost:44407/docs/project/sections/board_game/) used as our [running example](http://localhost:44407/docs/intro/sections/board_game/). If you choose the second option (board game), then: - you will be provided a _graphical user interface_ (so that you only need to implement the mechanics of the game), - additional content will be provided during the lectures (as illustrations) that you can incorporate to your project. ## Requirements Here are some requirements common to both options (free project or board game). ### Source code The source code for the project must be written in Java 17 or lower. The code should be _yours_ (or mostly yours). If you incorporate external code, make sure to _reference_ it clearly in the `README.md` file of your project. If you took inspiration from a tutorial or the source code of another project, then reference it as well. The source code must be submitted as a GitHub repository. The [commit history](http://localhost:44407/docs/git/) must reflect the _individual contribution_ of each member of the group. Once again, make sure that: - each student uses a different (and only one) GitHub account, and - each student commits his/her _own code_. The repository should contain at its root a `.gitignore` file hat indicates files that should not be tracked. As a result, your repository should _not_ contain compiled classes, jars, logs, run-time files, IDE-generated files (e.g. `.idea/`), OS-generated files (e.g. `.DS_Store`), etc. ### Dependencies, build and packaging You are free to use any additional Java library in your project. The project should be build with either [Maven]() or [Gradle](). It should run on the [evaluation environment](http://localhost:44407/docs/env/sections/eval/) via _command line_ instructions. For instance (depending on how you designed your project), the instructions to build the executable may be: ```bash mvn package ``` and the instruction to run the executable may be (assuming that the executable is called `myJar.jar` and that your program takes two strings as input): ```bash java -jar myJar.jar \"firstInput\" \"secondInput\" ``` If the executable cannot be built in the evaluation environment, then you should at least provide an [über-jar]() that can run in this environment (via command line still). In this case, you may use a [GitHub release](https://docs.github.com/en/repositories/releasing-projects-on-github/managing-releases-in-a-repository#creating-a-release) to share this über-jar. ### Documentation Your git repository should contain at its root a `README.md` file (written in [Markdown](https://docs.gitlab.com/ee/user/markdown.html)). This file should contain _at least_ the following information: - members of the group and their respective GitHub identifiers, - clear instructions for building and running the project, - a description of the project, - a user's guide for the project (either a written guide, or a link to a video), - a brief overview of the implementation of your project. This should include information on: - the different (high-level) _components_ and interfaces between components, - which third-party _libraries_ you used (if any), and - some programming _techniques_ (seen in the course or not) that were particularly relevant for this project. - a description of your human experience in this project. This should include information on: - how the workload was distributed between the members of the project, - how you used git, and - challenges that each member faced (at least one per person). For further information about what a `README.md` file usually contains, you may look at [this web page](https://meakaakka.medium.com/a-beginners-guide-to-writing-a-kickass-readme-7ac01da88ab3). "},{"id":23,"href":"/docs/input/sections/read/","title":"Reading from and writing to a file in Java","section":"I/O and serialization","content":" # Reading from and writing to a file in Java There are numerous ways to [read](https://www.baeldung.com/reading-file-in-java) from or [write](https://www.baeldung.com/java-write-to-file) to a file in Java, using either native of external libraries. We highlight here some of the simplest ones (syntactically), even though they may not be the most efficient. We also restrict our scope to: - reading and writing _text_ (but Java also offers multiple ways to read or write sequences of bytes), - reading sequentially and writing by appending (but some classes like [RandomAccessFile](https://docs.oracle.com/javase/8/docs/api/java/io/RandomAccessFile.html) allow accessing any position in a file). ## Reading {#read} ### Reading a text file line by line Here is one way to process the content of a text file line by line: ```java try (BufferedReader reader = Files.newBufferedReader(Path.of(\"path/to/file.txt\"))){ String line = reader.readLine(); while (line != null){ System.out.println(line); line = reader.readLine(); } } catch (IOException e) { throw new RuntimeException(e); } ``` ### Reading an entire text file Alternatively, if the file is small, its whole content can be stored as a list of strings (one per line), as follows: ```java List lines = null; try (Stream stream = Files.lines(Path.of(\"path/to/file.txt\"))){ lines = stream.toList(); } catch (IOException e) { throw new RuntimeException(e); } ``` Or even as a single string: ```java String text; try { text = Files.readString(Path.of(\"path/to/file.txt\")); } catch (IOException e) { throw new RuntimeException(e); } ``` ### Splitting The method `String.split` can be used to decompose a string into an array of substring, based on some delimiter. For instance, in a csv file, each line can be decomposed using a comma (`,`), as follows: ```java String line = \"Alice,Bob,Carol\"; // Contains [\"Alice\", \"Bob\", \"Carol\"] String[] names = line.split(\",\"); ``` We will see in the chapter dedicated to [regular expressions]() that more expressive delimiters can be used. ### Reading with a scanner The class `Scanner` is a versatile tool that allows reading from the standard input, but also from a file. We refer to [last year's course](https://programming-project-2022-23.github.io/io/reading-scanner/) for an overview. ## Writing {#write} **_Warning._** In Java, methods that write an (underspecified) line separator produce a (sequence of) character(s) that depends on the operating system running the program: `\\r\\n` on Windows, and `\\n` on most other modern operating systems. This is the case in all three examples below, with the methods `BufferedWriter.newLine`, `PrintWriter.println` and `Files.write`. ### Writing incrementally A common way to write to a file consists in using a `BufferredWriter`. For instance: ```java try(BufferedWriter writer = new BufferedWriter(new FileWriter(\"path/to/file.txt\"))){ writer.write(\"Hi\"); writer.newLine(); } catch (IOException e) { e.printStackTrace(); } ``` A `PrintWriter` offers additional methods to easily format the output, such as `print`, `println` or `printf`, analogous to the methods of the standard output stream `System.out`. It is often used as a wrapper around another writer, for instance a `BufferedWriter`: ```java try(PrintWriter writer = new PrintWriter(new BufferedWriter(new FileWriter(\"path/to/file.txt\")))){ writer.println(\"Hi\"); } catch (IOException e) { e.printStackTrace(); } ``` ### Writing an entire list The method `Files.write` can be used to write all elements of a list to a file (one per line): ```java List strings = List.of(\"foo\", \"bar\"); try { Files.write( Path.of(\"path/to/file.txt\"), strings ); } catch (IOException e) { throw new RuntimeException(e); } ``` ### Writing a single string The method `Files.writeString` can be used to write a single string to a file ```java try { Files.writeString( Path.of(\"path/to/file.txt\"), \"foo\" ); } catch (IOException e) { throw new RuntimeException(e); } ``` Note that this will overwrite the content of the file. Instead, in order to _append_ a string to a file, a third argument can be added to the method `Files.writeString`: ```java try { Files.writeString( Path.of(\"path/to/file.txt\"), \"foo\", StandardOpenOption.APPEND ); } catch (IOException e) { throw new RuntimeException(e); } ``` "},{"id":24,"href":"/docs/regex/sections/practice/","title":"Regexes in practice","section":"Regular expressions","content":"\n# Regular expressions in practice\n\nIn practice, regular expressions deviate from the theoretical ones in several ways.\nIn particular:\n\n1. Regex engines support a wide range of syntactic sugar, i.e. operators that could in theory be expressed in terms of the three operators of abstract regexes.\n   Syntactic sugar is a necessity for most practical uses of regexes.\n   For instance, most regex engines have a concise syntax for a range of characters, like `[A-Z]` for \"any capital letter between A and Z\",\n   which syntactic sugar for $A | B | C |..| Z$.\n\n2. Most regex engines offer functionalities (such as backreferences) that go beyond the expressivity of theoretical regexes.\n\n3.\n\nhttps://gist.github.com/CMCDragonkai/6c933f4a7d713ef712145c5eb94a1816\n"},{"id":25,"href":"/docs/abstractdatatypes/sections/set/","title":"Set","section":"Abstract data types","content":" # Set The abstract data type **set** simulates a (usually finite) mathematical [set](http://localhost:44407/docs/background/sections/set_tuple_map/#set). A set may expose the following methods: - **add**: adds an element to the set if it was not present already (and returns true iff this was the case), - **contains**: checks whether an element belongs to the set, - **size**: returns the cardinality of the set, - etc. **_Warning._** A set provides no guarantee on the _order_ of its elements! ## in Java Java provides an interface `Set` with 8 native implementations (i.e. different _classes_ that implement this interface). The most commonly used are `HashSet` and `TreeSet`. The interface `Set` extends the interface `Collection`. ### Syntax Here are code snippets for a few simple operations specified in the interface `Set`. - Create a `Set` and populate it: ```java City milan = new City(\"Milan\", 20100); City florence = new City(\"Florence\", 50100); // Creates an empty set of cities Set mySet = new HashSet\u003c\u003e(); // Adds Milan to the set mySet.add(milan); // Adds Florence to the set mySet.add(florence); // Tries to add Milan again; this has no effect. mySet.add(milan); // Creates a set identical to the previous one, // but immutable Set myOtherSet = Set.of(milan, florence); ``` - Remove an element from a set: ```java mySet.remove(milan); ``` - Check whether a set contains an certain element: ```java // Outputs false System.out.println(mySet.contains(milan)); // Outputs true System.out.println(mySet.contains(florence)); ``` - Retrieve the cardinality of a set: ```java // Outputs 1 System.out.println(mySet.size()); ``` - Compute the intersection of two sets: ```java mySet.add(new City(\"Bologna\", 40100)); mySet.retainAll(myOtherSet); // Outputs 1 System.out.println(mySet.size()); ``` - Add a collection to a set: ```java mySet.addAll(myOtherSet); // Outputs 2 System.out.println(mySet.size()); ``` For more operations, consult the [Javadoc](https://docs.oracle.com/javase/8/docs/api/java/util/Set.html) of the interface `Set`. ### Duplicates By definition, a set cannot contain identical elements. But what does \"identical\" mean for two objects? In Java, the method `equals` is (implicitly) used to determine whether two elements added to a `Set` should be considered identical. **_Warning._** [Recall](http://localhost:44407/docs/objects/sections/comparing/#equals) that the method `equals` should be overridden _together with_ the method `hashCode` (more on this later). This is essential for a `HashSet` to behave as expected (more on this later). For instance, consider a naive implementation of the class `City`, which does _not_ override `equals` (or `hashCode`): ```java public class City { String name; int zipcode; public City(String name, int zipCode){ this.name = name; this.zipCode =zipCode; } } ``` [Recall](http://localhost:44407/docs/objects/sections/comparing/#equals) that every class inherits a default implementation of `equals` (and `hashCode`), from the class `Object`. According to this default implementation, `equals` behaves like `==`. ```java City trento = new City(\"Trento\", 38100); City trentoAgain = new City(\"Trento\", 38100); Set cities = Set.of(trento, trentoAgain); // Outputs 2 System.out.println(cities.size()); ``` Now consider a class `SmartCity` identical to `City`, but that overrides `equals` (and`hashCode`) in the standard way: ```java public class SmartCity { String name; int zipCode; public SmartCity(String name, int zipCode) { this.name = name; this.zipCode = zipCode; } @Override public boolean equals(Object o) { if (this == o) return true; if (o == null || getClass() != o.getClass()) return false; SmartCity smartCity = (SmartCity) o; return zipCode == smartCity.zipCode \u0026\u0026 name.equals(smartCity.name); } @Override public int hashCode() { return Objects.hash(name, zipCode); } } ``` A Java `Set` cannot contain two instances of `SmartCity` that have the same name and zip code: ```java SmartCity smartTrento = new SmartCity(\"Trento\", 38100); SmartCity smartTrentoAgain = new SmartCity(\"Trento\", 38100); Set smartCities = new HashSet\u003c\u003e(); smartCities.add(smartTrento); smartCities.add(smartTrentoAgain); // Outputs 1 System.out.println(smartCities.size()); // Outputs false System.out.println(smartCities.add(smartTrentoAgain)); ``` **_Note._** Recall that many native Java classes already override `equals` (and `hashCode`). Among others: `String`, boxed types (like `Integer`), but also most implementations of the `Collection` interface (including `HashSet`). **_Note._** Some implementations of `List` also provide methods that perform \"set-like\" comparisons. E.g. `containsAll`, `removeAll`, `retainAll`, etc. Again, we refer to the [Javadoc](https://docs.oracle.com/javase/8/docs/api/java/util/List.html) for an exhaustive documentation. ## Usage Implementations of the ADT set can be useful in a variety of contexts. For instance, remove duplicates from an array (assuming that the order of elements in the array is irrelevant): ```java Integer[] myArray = new Integer[]{1,2,3,1,2}; List tuple = List.of(myArray); Set set = new HashSet\u003c\u003e(tuple); // Outputs 3 System.out.println(set.size()); ``` Or check whether two lists contain the same (distinct) elements: ```java SmartCity mantova = new SmartCity(\"Mantua\", 46100); SmartCity bergamo = new SmartCity(\"Bergamo\", 24100); List list1 = List.of(mantova, bergamo); List list2 = List.of(bergamo, mantova); Set set1 = new HashSet\u003c\u003e(list1); Set set2 = new HashSet\u003c\u003e(list2); // Outputs true System.out.println(set1.equals(set2)); ``` Exercise In our game, a same unit may sit on two (or more) adjacent tiles. Consider an implementation where: - a board consists of a two-dimensional array with type `Unit[][]`, and - if a same unit sits on several tiles, then these tiles contain (a reference to) the same (instance of) `Unit`, and - `Unit` does _not_ override `equals` (neither do its sub or superclasses). Write a Java method `int countUnits(Unit[][] board)` that takes such an array as input, and returns the number of different units on the board. For instance, with the board below as input, the method should return 5. ![](/img/adt/miniboard.png) Possible solution ```java int countUnits(Unit[][] board) { Set units = new HashSet\u003c\u003e(); for (Unit[] row : board) { for (Unit unit : row) { if (unit != null) { units.add(unit); } } } return units.size(); } ``` Exercise What dose the following program output? ```java Set aSet = new HashSet\u003c\u003e(); Set anotherSet = new HashSet\u003c\u003e(); aSet.add(1); aSet.add(2); anotherSet.add(1); Set"},{"id":26,"href":"/docs/background/sections/set_tuple_map/","title":"Set, tuple, function","section":"Background","content":" # Set, tuple, function ## Set {#set} A **set** can be informally viewed as a collection of elements with _no duplicate_ and in _no specific order_. **_Definition._** The **power set** $\\mathcal{P}(S)$ of a set $S$ is the set of all subsets of $S$. For instance, if \\(S = \\{a,b\\}\\) , then \\( \\qquad \\qquad \\qquad \\mathcal{P}(S) = \\Big\\{ \\{\\}, \\{a\\}, \\{b\\}, S \\Big\\} \\) **_Note._** An alternative notation for the power set of $S$ is $2^S$. If $S$ is finite with size $n$, then $\\mathcal{P}(S)$ has size $2^n$. **_Definition._** The **product** $S_1 \\times S_2$ of two sets $S_1$ and $S_2$ is the set of all pairs $(s_1, s_2)$ such that $s_1 \\in S_1$ and $s_2 \\in S_2$. For instance, if \\( S_1 = \\{a,b\\} \\) and \\(S_2 = \\{1,2,3\\} \\) , then \\(\\qquad \\qquad S_1 \\times S_2 = \\{ \\ (a,1), (a,2), (a,3), (b,1), (b,2), (b,3)\\ \\}\\) **_Notation._** Similarly to $S_1 \\times S_2$: - $S_1 \\times S_2 \\times S_3$ denotes the set of all triples $(s_1, s_2, s_3)$ such that $s_1 \\in S_1, s_2 \\in S_2$ and $s_3 \\in S_3$. - $S_1 \\times .. \\times S_k$ denotes the set of all tuples $(s_1, .., s_k)$ such that $s_1 \\in S_1, .., s_k \\in S_k$. **_Notation._** - $S^2$ is sometimes used for $S \\times S$, - $S^3$ is sometimes used for $S \\times S \\times S$, - etc. ## Tuple {#tuple} **_Definition._** A **tuple** (or **list**) over a set $S$ is a finite sequence of (possibly repeated) element of $S$. For instance: - \\(()\\) is the 0-tuple or **empty tuple**, - \\((a)\\) is a 1-tuple, - \\((b,a)\\) is a 2-tuple or **pair**, - \\((a,b,a)\\) is a 3-tuple or **triple**, etc. ## Function {#function} A **function** (or **map**) $f\\colon X \\to Y$ maps each element $x$ of its **domain** $X$ to an element $f(x)$ of its **codomain** $Y$. A function \\(f\\colon X \\to Y\\) can equivalently be viewed as a set of \"key-value\" pairs, namely the set of all pairs \\((x, f(x))\\) such that \\(x \\in X\\) . **_Definition._** A function $f\\colon X \\to Y$ is: - **injective** is no two elements in its domain have the same image, i.e. if for all $ x_1, x_2 \\in X$, $\\qquad \\qquad x_1 \\neq x_2$ implies $f(x_1) \\neq f(x_2)$ - **surjective** if every element in its codomain has a preimage, i.e. if $\\qquad \\qquad$ for each $y \\in Y$, there is a $x \\in X$ such that $y = f(x)$. - **bijective** if it is injective and surjective. A function \\(f\\) with _finite_ domain can be represented extensionally, as a set of pairs of the form \\(\\qquad \\qquad x \\mapsto f(x)\\) For instance, the function \\(f\\colon \\{a,b,c\\} \\to \\mathbb{N}\\) defined by \\(\\qquad f(a) = 1,\\ f(b) = 1\\) and \\(f(c) = 2\\) can be represented as the set: \\(\\qquad \\{\\ a \\mapsto 1,\\ b \\mapsto 1,\\ c \\mapsto 2\\ \\}\\) ## Multiset A **multiset** (or **bag**) is a finite collection of elements in no specific order, _possibly with duplicates_. Square bracket are sometimes uses to distinguish a multiset from a set or a tuple. For instance: \\([b,b,c]\\) and \\([a,b]\\) are multisets (the latter is also a set). \\([a,b,a]\\) and \\([b,a,a]\\) denote the same multiset. Exercise A multiset can equivalently be viewed as one of the mathematical objects seen above. Can you identify which one? Solution A multiset can be viewed as a function that maps each element to its number of occurrences. For instance, the multiset [a, b, a] can be viewed as the function { a ↦ 2, b ↦ 1 } "},{"id":27,"href":"/docs/intro/sections/lecturers/","title":"Teaching staff","section":"This course","content":"\n# Teaching staff\n\n[Julien Corman](https://www.unibz.it/it/faculties/engineering/academic-staff/person/37010-julien-corman) will teach the lectures and one lab.\n\n[Albulen Pano](https://www.unibz.it/it/faculties/engineering/academic-staff/person/41170-albulen-pano) will teach the other lab.\n\n## Office hours\n\nIf you need additional help with the content of the course, the assignments and/or your project, you can ask for office hours with any (or both) of us.\n\nThese appointments must be scheduled via email (follow the links above for our email addresses).\n"},{"id":28,"href":"/docs/abstractdatatypes/sections/map/","title":"Associative array","section":"Abstract data types","content":" # Associative array An **associative array** (or **dictionary** or **map**) simulates a [function](http://localhost:44407/docs/background/sections/set_tuple_map/#function) with _finite_ domain. A associative array exposes at least the following methods: - **lookup** (or **get**) takes a key as input, and returns the value for this key (if any). - **insert** (or **put** ) inserts a pair _(key, value)_. If an entry for this key was already present, then overwrites its value. - **remove** (or **delete**) deletes the entry for a given key (if any). **_Note._** Associative arrays are pervasive in programming. Many data structures have been designed over the years whose main purpose is to implement associative arrays efficiently (notably hash maps and a variety of search trees). ## in Java Java provides an interface `Map` with 19 native implementations (i.e. 19 different _classes_ that implement this interface). The most commonly used is `HashMap`. **_Note._** The interface `Map` does _not_ extend the interface `Collection`. `Map` is a generic type with _two_ parameters: one for the type of its keys, and one for the type of its values. For instance, a map from integers to strings has type `Map`. ### Syntax Here are code snippets for a few operations specified in the interface `Map`. - Create a `Map` and populate it: ```java City milan = new City(\"Milan\", 20100); City florence = new City(\"Florence\", 50100); // Create an empty map whose keys are zipCodes, // and whose values are cities Map zipCodeToCity = new HashMap\u003c\u003e(); // Adds { 20100 ↦ milan } to the map zipCodeToCity.put(milan.zipCode, milan); // Adds { 50100 ↦ florence } to the map zipCodeToCity.put(florence.zipCode, florence); // Creates a map identical to the previous one, // but immutable Map anotherMap = Map.of( milan.zipCode, milan, florence.zipCode, florence ); ``` - Retrieve the value associated to a given key: ```java // Contains (a reference to) Milan City aCity = zipCodeToCity.get(20100); // Has value null City anotherCity = zipCodeToCity.get(88888); ``` - Check whether a map contains an entry for a given key: ```java // Outputs true System.out.println(zipCodeToCity.containsKey(20100)); // Outputs false System.out.println(zipCodeToCity.containsKey(88888)); ``` - Retrieve the number of entries in a map: ```java // Outputs 2 System.out.println(zipCodeToCity.size()); ``` - Overwrite an entry in a map: ```java City bologna = new City(\"Bologna\", 40100); // Replaces { 20100 ↦ milan } with { 20100 ↦ bologna } zipCodeToCity.put(20100, bologna); // Outputs 2 System.out.println(zipCodeToCity.size()); // Adds { 40100 ↦ bologna } to the map zipCodeToCity.put(bologna.zipCode, bologna); // Outputs 3 System.out.println(zipCodeToCity.size()); // Replaces { 20100 ↦ bologna } with { 20100 ↦ milan } zipCodeToCity.put(milan.zipCode, milan); ``` - Retrieve the set of keys of a map (note that this is an instance of `Set`, where `E` is the type of the keys) ```java Set keys = zipCodeToCity.keySet(); // Outputs true System.out.println(keys.contains(20100)); ``` - Retrieve a collection with all values in the map, in no specific order (may contain duplicates): ```java Collection values = zipCodeToCity.values(); // Outputs true System.out.println(values.contains(milan)); // Outputs 3 System.out.println(values.size()); // Adds { 99999 ↦ milan } to the map zipCodeToCity.put(99999, milan); // Outputs 4 System.out.println(zipCodeToCity.values().size()); ``` - Wrap the map into a _set_ of entries (a.k.a. \"key-value\" pairs): ```java // Creates a \"wrapper\" Set around the map. // No data is duplicated. // Each element of this set has type Entry Set"},{"id":29,"href":"/docs/env/sections/backup/","title":"Backup","section":"Development environment","content":" # Backup Make sure that your work does not depend on your laptop. You should be able to _resume your work_ easily on another computer if your laptop gets lost, damaged, etc. You should also be able to _recover your data_ if you accidentally delete it from your hard drive. ## Which information to back up As a priority, make sure that there exist copies (_outside_ of your hard drive) of: 1. your _passwords_ (and possibly identifiers), and 2. your _own work_ (code, reports, slides, notes, CV, etc.). These copies may be stored on the cloud, an external disk, another computer, etc. Optionally, you may also back up: 3. [configuration files]() present in your home folder. For development purposes, you generally do _not_ need to back up: - generated content (back up the code that generates it instead), - large datasets (these should not be present on your laptop to start with), - programs (they can be reinstalled). ## How to back up ### Password managers For passwords, your [password manager](https://en.wikipedia.org/wiki/List_of_password_managers) may provide an online backup option. Other password managers (like [pass](https://www.passwordstore.org/)) may let you synchronize your passwords via [git](#git). ### Git {#git} For your _own work_ and/or _configuration files_, git can be an option. A git **repository** is (roughly speaking) a directory that can be synchronized across different machines (see the [dedicated chapter]() of this course for an introduction to git). For instance, you may create a (private) git repository for each course that you follow and/or each project that you start. Several providers (GitHub, Gitlab, Bitbucket, etc.) can host copies of your (public or private) repositories on the cloud for free. The benefits are: - the possibility to recover _any previous state_ of your work (a git repository stores the whole history of modifications made to it), - fine-grained control over your backup: for instance, you can use a [\".gitignore\" file]() to exclude files or subfolder that do not need to be backed up. **_Note._** If a git repository is a subfolder of another git repository, then the inner repository is not included in the history of the outer one. **_Limitation._** Git is _not suited_ to large volumes of data (more than 1 GB in the same repository). This is usually not an issue for your own work (code, notes, reports, etc.) as a student in computer science. However, git should _not_ be used to back up large collections of images, audio files, videos, etc. ### Other solutions [Numerous programs](https://en.wikipedia.org/wiki/List_of_backup_software) allow you to back up (part of) the content of your hard drive. One of them may be pre-installed on your operating system. You can back up content on a device that you own (e.g. on an external hard drive), or on the cloud. In the latter case, some fee may apply (depending on the volume of data). ## Restore points Programs such as [System restore](https://en.wikipedia.org/wiki/System_Restore) (Windows), [macOS Recovery](https://support.apple.com/en-gb/guide/mac-help/mchl338cf9a8/mac) (macOS) or [Timeshift](https://github.com/teejee2008/timeshift) (Linux) allow you to create snapshots of your system (typically for what lives _outside_ of your home folder), and revert your system's state to one of these snapshots. This can be useful in case of a corrupted system. However, it may be difficult to determine at which point in time the system was \"healthy\". Note also that in such scenarios, a fresh re-install may be a simpler to restart on a sane basis. "},{"id":30,"href":"/docs/git/sections/config/","title":"Configuration","section":"git","content":" # Configuration ## Text editor {#texteditor} In some situations (commit without message, merge commit, etc.), git automatically opens a text editor to let you type a message. By default, on most operating systems, git open [vi](https://en.wikipedia.org/wiki/VI) for this purpose. I you have never used vi, we recommend selecting another text editor. You can do this by running: ```bash git config --global core.editor ``` where `` is the command that launches your text editor (for instance `notepad` for Notepad, `open -e -W -n` for TextEdit , `gedit` for gedit, `sublime` for Sublime Text, etc.) ## Protocol Git hosting services (such as GitHub) usually support two alternative protocols for sharing content with a remote: https and ssh. ssh is generally recommended. ### SSH key To share content via ssh, you need a cryptographic key, often called an \"ssh key\" (in practice, this is an [RSA]() key). You may already have an ssh key on your machine. By default, ssh keys are located in the dot folder `/.ssh` (or `\\.ssh` on Windows). If this folder exists, then it should contain (at least) one file with extension `.pub`. Such a file contains a **public RSA key**. You can share this key with a git host for authentication. If you do not have an SSH key on your machine, then you can generate one by running ```bash ssh-keygen ``` in a terminal (Linux and macOS) or in the Windows Power Shell (Windows). If you accept the default location, this command will generate the `.ssh` folder and a key. In order to add a public key to your GitHub account, log in to GitHub, select \"Settings\", then \"SSH and GPG keys\". Click on the \"New SSH key\" button, give a name to your key, and paste your public key (i.e.the content of the file with extension `.pub`) in the field \"Key\". For more details, you can for instance consult [this page](https://docs.github.com/en/authentication/connecting-to-github-with-ssh). ### HTTPS credentials If you prefer, you can interact with (most) git hosting services via HTTPS. By default, this requires entering your credentials for each interaction with a remote. To avoid this, you may consider [caching your GitHub credentials in Git](https://docs.github.com/en/get-started/getting-started-with-git/caching-your-github-credentials-in-git). "},{"id":31,"href":"/docs/build/sections/pom/","title":"Configuration file","section":"Build automation","content":" # Configuration file ## The Project Object Model (POM) The root folder of a Maven project normally contains a configuration file called `pom.xml`. This file provides the information needed to identify and build the project. **_Hint._** Your IDE can generate the backbone of a `pom.xml` file (for instance, when creating a Maven project). For a basic Java project, the `pom.xml` file usually has the following structure: ```xml \u003c?xml version=\"1.0\" encoding=\"UTF-8\"?\u003e 4.0.0 XXX XXX XXX ... ... ... ``` For instance, here is the skeleton of a minimal `pom.xml` file for a Java 17 project: ```xml 4.0.0 it.unibz.pp-23-24 myProject 1.0-SNAPSHOT 17 17 UTF-8 ``` ### Parent POM, super POM, effective POM {#pomInherit} A POM can inherit properties from a **parent POM**, via so-called [project inheritance](https://maven.apache.org/guides/introduction/introduction-to-the-pom.html#project-inheritance). In addition, every POM implicitly inherits from the so-called [super POM](https://maven.apache.org/ref/3.0.4/maven-model-builder/super-pom.html). In case of conflict, the values specified in the child POM have precedence over those specified in the parent POM (analogously to inheritance of attributes in Java). The **effective POM** of a project is the one induced by the project's POM and the properties that it inherits from other POMs. To display the effective POM of a project, from the root of this project, run: ```bash mvn help:effective-pom ``` **_Note._** Inheritance of configuration (where a project-specific or user-specific configuration may partially overwrite a parent configuration) is not specific to Maven, but used by many programs. "},{"id":32,"href":"/docs/recursion/sections/correctness/","title":"Correctness","section":"Recursion","content":"\n# Correctness\n\nTo check whether a recursive method is correct, it is (usually) sufficient to check that the two following properties hold:\n\n1. Base case(s): the method is correct for the smallest possible inputs.\n2. Inductive case: for an arbitrary $n$, _if_ the method is correct for all inputs of size up to $n$, then it is correct for all inputs of size $n+1$.\n\n**_Example._**\n\nConsider the algorithm seen [earlier]() to compute the sum of all nodes in a binary tree.\nFor $n$, we can use the height of the tree (i.e. the length of its longest branch).\n\n1. Base case: the sum of all labels in an empty tree is 0, so the method is trivially correct.\n2. Inductive case: Consider any natural number $n$, and any tree of height $n+1$, with root $r$.\n   And let us assume that the method `sum` is correct for all trees of height $\\le n$.\n   We need to show that under this assumption, the method is correct for the tree rooted in $r$.\n\nObserve that the subtrees rooted in `r.left` and `r.right` have height $\\le n$.\nSo from our assumption, the recursive calls (line XXX) to the method `sum` are correct, meaning that they return the sum of all values in each of these subtrees.\nNext, observe that the sum of all labels in our tree must be equal to the sum all values in these two subtrees, plus the label of $r$.\nWhich is precisely what the method returns.\n\nThese two properties (1 and 2 above) provide an immediate proof by induction that the method is correct for all inputs.\n\nTo see this, partition the set of all possible inputs by size, i.e. (assuming that inputs in outr base case have size 0):\n\n- the set $S_0$ of all inputs of size $0$,\n- the set $S_1$ of all inputs of size $1$,\n- the set $S_2$ of all inputs of size $2$,\n- etc.\n\nIn order to show that the method is correct, it is sufficient to show that it is correct for each $S_i$ (where $i \\in \\mathbf{N}$)\n\nNow let us assume that properties 1 and 2 hold, i.e.:\n\n1. Base case: the method is correct for $S_0$.\n2. Inductive case: for an arbitrary $n$, _if_ the method is correct for $S_0 \\cup S_1 \\cup ... \\cup S_n$, then it is correct for $S_{n+1}$\n\nFrom 1. and 2. , we can infer: 3. the method is correct for $S_1$\n\nThen from 1, 3 and 2 (replacing $n$ by $1$), we can infer:\n\n4. the method is correct for $S_2$\n\netc.\n"},{"id":33,"href":"/docs/intro/sections/evaluation/","title":"Evaluation","section":"This course","content":" # Evaluation Evaluation for this course is based on: - [assignments](#assignments): up to 30 points, - a [group project](#group-project): up to 60 points, and - an [oral exam](#oral-exam): up to 10 points. Your final grade is the sum of the above, multiplied by 0.3. ## Assignments There will be _8 or 9_ assignments for this course. These are standard programming exercises, related to notions seen during the lectures. The [labs](http://localhost:44407/docs/intro/sections/schedule/#Labs) are (mostly) dedicated to these assignments. The release of each assignment is announced via [Teams](https://teams.microsoft.com/l/team/19%3a5nIIq-TkfyJLi3capYBYZG42U0vNmUBTv31Ac7Gqf641%40thread.tacv2/conversations?groupId=b394eaa9-e55c-42ed-be0f-5be013ff2f03\u0026tenantId=92513267-03e3-401a-80d4-c58ed6674e3b). You will also find a link to the released assignments on the [home page](http://localhost:44407/#assignments) of this site. Assignments are submitted via [GitHub classroom](https://classroom.github.com/). You can submit an assignment multiple times (but only before its deadline). **_Note._** In order to submit your assignments (and your project), you will need a [GitHub](https://github.com/) account. If you do not have one already, please create one and communicate it to the lecturer, preferably via [Teams](https://teams.microsoft.com/l/team/19%3a5nIIq-TkfyJLi3capYBYZG42U0vNmUBTv31Ac7Gqf641%40thread.tacv2/conversations?groupId=b394eaa9-e55c-42ed-be0f-5be013ff2f03\u0026tenantId=92513267-03e3-401a-80d4-c58ed6674e3b). Make sure that you use a _single_ GitHub account for all your assignments and your project. ## Group project Guidelines for the _content_ of the project are in the [dedicated chapter](http://localhost:44407/docs/project/). We focus here on organization and evaluation. - Each group must consist of _3 to 4 students_. Groups should be decided by _March 20_, and communicated via mail to the lecturer. - Projects are delivered via GitHub. - Grades for a project are awarded _individually_, based on each student's contribution. Students are expected to work on _different computers_. Make sure that: - each student uses a different (and only one) GitHub account, and - each student commits (via [git](http://localhost:44407/docs/git/)) his/her _own code_. - The project's code is expected to apply techniques seen during the lectures, but only _if relevant_. Please do _not_ add artificial functionalities to your project for the sole purpose of illustrating a certain technique. ## Oral exam The oral exam is _individual_. No revision is needed. We will ask you questions about your code and/or involvement in the project.\nFor instance: - which design choices you made, - which difficulties you encountered, - the expected behavior of a certain method, - how some portions of the code may be improved, - etc. "},{"id":34,"href":"/docs/objects/sections/inheritance/","title":"Inheritance","section":"Objects and classes","content":" # Inheritance ## Subclass In most (class-based) object-oriented languages, a class _A_ can **extend** another class _B_. In this case, _A_ is called a **subclass** of _B_. The intuitive meaning is inclusion between their respective sets of instances, i.e. every instance of _A_ is also an instance of _B_ (but the converse may not hold). This can be paraphrased in English by \"every _A_ is a _B_ \". For instance: - every banana is a fruit - every square is a rectangle - every rectangle is a geometric shape, - etc. ### Transitivity The \"extend\" relation is **transitive**, meaning that if _A_ extends _B_ and _B_ extends _C_, then _A_ extends _C_ (for any classes _A_, _B_ and _C_ ). For instance, from the above examples, one can infer that \"every square is a geometric shape\". ### Inheritance Naturally, if _A_ is a subclass of _B_ then it **inherits** the properties of _B_. For instance, a rectangle has four right angles. Since every square is a rectangle, a square has four right angles as well. ## Factorizing code with a (possibly abstract) superclass Inheritance can be used to avoid [redundant code]() ### Direct inheritance: illustration Let us model the units of our game as objects. Each unit has: - a _type_ (e.g. mage, unicorn, etc.), - a _color_ (at least in the [original game](https://www.dotemu.com/games/might-magic-clash-of-heroes-definitive-edition/)), and - a certain amount of _health_. The behavior and stats of a unit (e.g number of turns before attacking when combined, default health, etc.) are dictated by its type. So it makes sense to group units by type. For instance, one can create a class `Unicorn` whose instances are all units of type unicorn. In Java: ```java public class Unicorn { String color; int health; int attackCountdown; public Unicorn(String color) { this.color = color; health = 1; attackCountdown = -1; } } ``` **_Note._** We used the keyword `attackCountdown` in this example to indicate the number of turns before the unit attacks (and a special value of `-1` when it is not set to attack). But there are of course other ways to model this. **_Note._** In this example, we used the prefix `this.` for the attribute `color` only, because there is no ambiguity for the three other attributes. We can also create a class `Butterfly` on the same model ```java public class Butterfly { String color; int health; int attackCountdown; public Butterfly(String color) { this.color = color; health = 2; int attackCountdown = -1; } } ``` Now consider a method `encounter` that manages an encounter between two units. Without inheritance, one would need to implement four versions of this method: - unicorn vs unicorn, - unicorn vs butterfly, - butterfly vs unicorn, and - butterfly vs butterfly. For instance, the first of these four methods could be implemented as follows: ```java void encounter(Unicorn u1, Unicorn u2) { // save the initial value of the first unit's health int copy = u1.health; u1.health -= u2.health; u2.health -= copy; } ``` More generally, if the game has \\(n\\) types of units, then the code will contain \\(n^2\\) nearly identical `encounter` methods. **_Question._** Can we use inheritance in this example to avoid duplicate code (and how)? Observe that a unicorn and a butterfly (viewed as object) have identical attributes (a.k.a. \"keys\"), namely `String color`, `int health`, and `int attackCountdown`. So we can create a superclass of `Unicorn`and`Butterfly`that carries these attributes, and let the two subclasses inherit it. For instance, this superclass may be called `Unit`. ![](/img/diagrams/plantuml/abstract_inherit_simple.svg) However, we may also want every unit in the game to have a concrete type (like \"unicorn\" or \"butterfly\"), rather than being a generic \"unit\". In Java, this can be achieved with the `abstract` keyword. This keyword ensures that our superclass _cannot_ be directly instantiated (even though it can still have a constructor). For instance: ```java public abstract class Unit { String color; int health; int attackCountdown; public Unit(String color, int health) { this.color = color; this.health = health; int attackCountdown = -1; } } ``` Because this class is abstract, the following code will _not_ compile: ```java Unit myUnit = new Unit(\"green\", 2); ``` Next, we can declare that `Unicorn` extends `Unit`, by using the Java keyword `extends`. We can also use the constructor of `Unit` within the constructor of `Unicorn`, with the Java keyword `super`. **_Note._** In Java (as opposed to C++ for instance), a class can only have _one_ immediate superclass, so the keyword `super` is never ambiguous. This yields: ```java public class Unicorn extends Unit { public Unicorn(String color) { super(color, 1); } } ``` And we can proceed similarly for the class `Butterfly`. Observe that all the attributes are now carried by the superclass `Unit`. However, because they are inherited, these attributes can be accessed as if they were regular attributes of the subclass. For instance, ```java Unicorn myUnit = new Unicorn(\"green\"); System.out.println(myUnit.health); ``` outputs ```java 1 ``` This allows us to write a generic `encounter` method, as follows: ```java void encounter(Unit u1, Unit u2) { // save the initial value of the first unit's health int copy = u1.health; u1.health -= u2.health; u2.health -= copy; } ``` And this method can be used with unicorns and/or butterflies. For instance: ```java Unicorn myUnicorn = new Unicorn(\"green\"); Butterfly myButterfly = new Butterfly(\"yellow\"); encounter(myUnicorn, myButterfly); } ``` ### Transitive inheritance In the example above, we assumed that all units have a color and can attack. What if we also want to create a type of unit called `Wall` that has no color and cannot attack? An instance of this class does not need the attributes `color` and `attackCountdown`. A quick solution here consists is setting `attackCountdown` to -1, and `color` to `null`. However, unnecessary attributes make code harder to understand, and such a design may not scale well if the game is extended with more units types. Exercise Modify our model to accommodate for the class `Wall`, so that an instance of `Wall` only has the `health` attribute. Possible solution One solution (among others) is the following: 1. modify the class `Unit` so that it only carries the attribute `health`, 2. `Wall` extends `Unit`, 3. create an (abstract) subclass of `Unit` (for instance `MobileUnit`) that carries the other two attributes, 4. `Butterfly` and `Unicorn` extend `MobileUnit` (therefore they also extend `Unit`, by transitivity). ![](/img/diagrams/plantuml/abstract_inherit_complex.svg) Or in Java: ```java public abstract class Unit { int health; public Unit(int health) { this.heath = health; } } ``` ```java public class Wall extends Unit { public Wall() { super(5); } } ``` ```java public abstract class MobileUnit extends Unit { String color; int attackCountdown; public MobileUnit(String color, int health) { super(health); this.color = color; this.attackCountdown = -1; } } ``` ```java public class Unicorn extends MobileUnit { public Unicorn(String color) { super(color, 1); } } ``` and similarly for `Butterfy`. "},{"id":35,"href":"/docs/objects/","title":"Objects and classes","section":"Docs","content":"\n# Objects and classes\n\nThis chapter introduces some basic notions of (class-based) object-oriented programming.\n"},{"id":36,"href":"/docs/build/sections/artifact/","title":"Artifact","section":"Build automation","content":" # Artifact A Maven **artifact** is the output of a build process. It can for instance be a [jar](http://localhost:44407/docs/build/sections/packaging/#jar). ## Coordinates A Maven artifact is identified by so-called **coordinates**: - **groupId:** identifier of the organization that created the project (this is usually the organization's reversed domain name), - **artifactId:** identifier of the project within the group, - **version:** version of the artifact. **_Examples._** ```xml com.google.guava guava 33.1.0-jre ``` ```xml com.github.haifengl smile-core 3.1.0 ``` These coordinates are notably used to declare [dependencies](http://localhost:44407/docs/build/sections/dependencies/). ## Versions ### SemVer Maven artifact versions often follow (or loosely follow) the so-called [semantic versioning](https://semver.org/) scheme. ``` MajorVersion.MinorVersion ``` or ``` MajorVersion.MinorVersion.Patch ``` **_Example._** According to the SemVer scheme, Version `3.4.1` means: - major version: `3` - minor version: `4` - patch: `1` By convention: - a new **major version** often signals the absence of backward compatibility, - a new **minor version** often signals (backward compatible) new features, - a **patch** often signals bug (or security-related) fixes. **_Note._** Java has only one major version. For instance \"Java 17\" actually refers to Java `1.17`. ### SNAPSHOT The `SNAPSHOT` qualifier (e.g. in Version `3.4.1-SNAPSHOT`) indicates an _upcoming_ release, still _under development_. The `SNAPSHOT` qualifier is typically used to describe the (current state of) the source code of (a git branch of) a project (e.g. available as a public git repository). For instance, if the latest release of the project was `3.5.2`, and if the developers are working on bug fixes, then the latest source code may have Version `3.5.3-SNAPSHOT`. **_Warning._** A program whose version number has the `SNAPSHOT` qualifier may be modified by it authors, _while keeping the same version number_. In other words, `Version 3.4.1-SNAPSHOT` downloaded today may differ from `Version 3.4.1-SNAPSHOT` downloaded tomorrow. So when releasing a project, it is recommended to avoid dependencies on `SNAPSHOT` versions. "},{"id":37,"href":"/docs/errors/sections/checked/","title":"Checked vs unchecked","section":"Errors","content":" # Checked vs unchecked ## Unchecked exceptions {#unchecked} The simplest type of exception in Java is called an **unchecked** exception. An unchecked exception is an instances of the native class `RuntimeException`. The class `RuntimeException` has several native subclasses. You may be familiar wit some of them: `NullPointerException`, `ArrayIndexOutOfBoundsException`, `IllegalArgumentException`, etc. An unchecked exception that is not caught is _automatically rethrown_. ## Checked exceptions {#checked} In Java, an `Exception` that is not a `RuntimeException` is a **checked** exception. For instance, an `IOException` is a checked exception. ![](/img/diagrams/plantuml/exceptions.svg) A checked exception is _not_ rethrown by default. Instead, it must be _explicitly_ rethrown (or caught), otherwise the program does not _compile_. For instance, the following code does not compile, because the method of `Files.readAllLines` may throw an `IOException`. ```java void someMethod(Path path) { Files.readAllLines(path); } ``` ### Rethrow explicitly {#rethrow} This can be fixed by either [catching](http://localhost:44407/docs/errors/sections/exceptions/#catch) the exception, or _explicitly_ rethrowing it, as follows: ```java void someMethod(Path path) throws IOException { Files.readAllLines(path); } ``` Then a method that calls `myMethod` will in turn have to catch the exception, or rethrow it explicitly, etc. **_Warning._** Checked exceptions add boilerplate code to method signatures (e.g. `throws IOException` in the above example). For this reason, it is often recommended to use unchecked exceptions (i.e. instances of `RuntimeException`) _by default_. In [Effective java](http://localhost:44407/docs/intro/sections/bibliography/#effectiveJava) (Item 71), Joshua Bloch suggests checked exceptions only if some calling method is likely to _catch_ the exception and take a _meaningful action_ when this happens. "},{"id":38,"href":"/docs/input/sections/property/","title":"Configuration files","section":"I/O and serialization","content":" # Configuration files It is common practice for an application to store parameters (e.g. user-specific settings) in [configuration files](https://en.wikipedia.org/wiki/Configuration_file). A configuration file may be edited manually and/or via a graphical interface. Configuration files may use different serialization formats. Some popular formats are INI, JSON, TOML, YAML or XML. ## in Java Java provides native support for at least two configuration file serialization formats: XML and the so-called \"property file\" format. We introduce here the latter. A **property file** usually: - has extension `.properties`, - may have commented line (starting with `#` or `!`), - contains one `key=value` pair per (non-commented) line. **_Example._** In our game, the file `config.properties` has two `key=value` pairs: ``` animationDuration=1 resolution=1920x1080 ``` More details about the syntax of property files (escaped characters, spaces, etc.) can be found [here](https://en.wikipedia.org/wiki/.properties). ### Reading a property file The content of a property file can be loaded in memory and modified as an [associative array](http://localhost:44407/docs/abstractdatatypes/sections/map/) , instance of the class `Properties` (which extends `Map`). For instance, the content of a property file can be loaded as follows: ```java Properties properties = new Properties(); try { properties.load(new FileInputStream(\"path/to/config.properties\")); } catch (IOException e) { throw new RuntimeException(e); } ``` Then a value can be read with the method `getProperty` (among other possibilities), as follows: ```java String resolution = properties.getProperty(\"resolution\"); float duration = Float.parseFloat(properties.getProperty(\"animationDuration\")); ``` ### Writing to a property file The content of a property file can be modified with the methods `setProperty` and `store` (among other possibilities), as follows: ```java String path = \"path/to/config.properties\"; Properties properties = new Properties(); try { // load the file as an associative array properties.load(new FileInputStream(path)); // modify the associative array properties.setProperty(\"animationDuration\", Float.toString(0.5f)); // replace the content of the property file with the // content of the associative array properties.store(new FileOutputStream(path)); } catch (IOException e) { throw new RuntimeException(e); } ``` "},{"id":39,"href":"/docs/intro/sections/content/","title":"Content","section":"This course","content":" # Content of the course This is a beginner's course on **imperative** and (class-based) **object oriented** programming, with an emphasis on _practice_ and _collaboration_. The course relies on Java as main programming language. However, many concepts seen in this course are relevant to other (imperative and/or object-oriented) programming languages: C/C++, C#, Javascript, Go, Kotlin, Lua, Perl, PHP, Python, Rust, Ruby, Typescript, Visual Basic, etc. ## Prerequisites Students are expected to have completed the _Computer Programming_ course (INF/01 76258). Therefore the following topics are _not_ covered in this course: - variables, assignments, variable scope, - basic data types, - conditional statements (\"if/then/else\") and loops, - expression evaluation, - methods/functions, - arrays, - etc. Students are also expected to have played the [board game](http://localhost:44407/docs/intro/sections/board_game/) used as a running example throughout the lectures. ## Outcomes After completing this course, students should be able to: - develop a prototype application in Java, - write structured, documented and easily maintainable code, - collaborate with other developers. ## Focus ### Foundations Most lectures put an emphasis on _problem solving_ rather than syntax. For conciseness, [pseudocode](https://en.wikipedia.org/wiki/Pseudocode) may be used in some sections rather than Java code. Some lectures also focus on more abstract (albeit simple) notions. These includes elementary mathematical objects or structures (set, tuple, map, relation, preorder, graph, tree, etc.), recursion, boolean logic, regular languages, etc. The purpose is twofold: - ease the application of techniques seen in this course to programming languages _other than Java_, - provide a widely accepted _vocabulary_ to document/explain your code. ### Collaboration The course introduces basic coding practices that facilitate development within a _team_. In particular: - structuring a project (components, interfaces, encapsulation, etc.), - [factorizing]() code (inheritance, reuse of methods, etc.), - [test-driven](http://localhost:44407/docs/unittests/) development, - collaboration via [git](http://localhost:44407/docs/git/), - documentation. **_Note._** What is considered _good communication_ in computer science may differ from other disciplines. Emphasis is put on _clarity_, _precision_ and _conciseness_. Exercise Here is a (caricature of) a poorly documented method. Can you improve the method's description and/or signature? ```java /** The algorithm looks at the first collection, and is only guaranteed to * work if no number is present twice in this collection, in which case it * loops over the numbers contained in this collection (in no specific order) * and checks for each number whether it is also present in the second * collection (which is also expected to have distinct numbers). The code * written in this loop adds the current number (from the first collection) * to the output collection if this number is also present in the second * collection, and does nothing otherwise. */ Collection filterNumbersThatAreShared(Collection c1, Collection c2); ``` Solution A simpler signature and description could be: ```java /** * Returns the intersection of sets s1 and s2. */ Set intersection(Set s1, Set s2); ``` However, the following topics are _beyond the scope_ of this course: - continuous integration, - project management (agile methodology, bug tracking, etc.), - advanced git workflows, - advanced design patterns, dependency injection, - etc. ### Quizzes Some lectures will include quizzes. These are _anonymous_, and therefore are _not_ part of your evaluation. The purpose is to: - make lectures more interactive and - adapt the pace of the lectures based on students' answers. It is in your _own interest_ to answer them without external resources (web, chatbots, IDE, etc.). Here is a link to the first quiz: [https://forms.gle/7Y2MpzE7v5xzUJFy7](https://forms.gle/7Y2MpzE7v5xzUJFy7). ![](/img/qr_codes/quiz1_400.svg) ## Topics covered Due to limited time, many notions (such as asymptotic cost, regular languages, hashmaps or multi-threading) are only briefly introduced in this course. However, some of them will be further discussed in other courses of the bachelor. ### Programming concepts and techniques An important part of the lectures is dedicated to the following core topics: - objects, classes and interfaces (inheritance, encapsulation, value vs reference, comparing objects, cloning objects, etc.), - abstract data types (set, list, map, queue, etc.) and data structures (arrays, linked lists, hashmaps, heaps, etc.), - recursion. In addition, the following will be (briefly) introduced: - regular expressions, - generics, - mutability, pure functions, lambda expressions and streams, - multi-threading. **_Note._** Some of these topics pertain to [functional programming](https://en.wikipedia.org/wiki/Functional_programming), but have been incorporated (in some form) to several imperative languages over the years. ### Software engineering - unit tests, - exceptions, - code factorization, - object-oriented design (basic design patterns). ### Java - compilation/interpretation, bytecode, JVM and JDK, - memory (stack VS heap), garbage collection, - input/output, - object serialization, JSON/XML serialization. ### Tools and tutorials - git, - build automation (Maven and Gradle), - using an IDE efficiently (navigation, debugging, autocompletion, etc.), - using a terminal efficiently (introduction), - etc. "},{"id":40,"href":"/docs/git/sections/create/","title":"Create or clone a repository","section":"git","content":" # Create or clone a repository ## From a remote server The most common way to create a repository is to create the remote copy first, using the web interface of your host (Github, Gitlab, Bitbucket, etc.). You will be asked to give the repository a name. Then you will be provided an address that allows use to clone the repository on your own machine (via ssh or https). To do so, navigate on your machine to the folder where you want to clone the repository, and run ```bash git clone ``` **_Note._** After cloning a repository, you can verify that it contains a (hidden) subfolder called `.git`. Recall that this is what distinguishes a git repository from a regular folder. **_Note._** You can safely move a cloned repository to another location on your machine (as long as it contains the `.git` subfolder). With the same command, you can clone any public repository that you find online (e.g. hosted on GitHub). To clone a specific branch, run ```bash git clone -b ``` ## Locally Alternatively, you can create a git repository on your machine with the [git init](https://www.atlassian.com/git/tutorials/setting-up-a-repository) command. This may be convenient if you want to create a git repository from an existing (nonempty) folder. If you create a git repository locally, then you will need to declare your remote(s) manually (with [git remote](https://www.atlassian.com/git/tutorials/syncing)). "},{"id":41,"href":"/docs/objects/sections/methods/","title":"Instance methods","section":"Objects and classes","content":" # Instance methods In most object-oriented languages (like Java), methods are implemented within class declarations. An **instance method** can only be called using an instance of the class where it is declared. For instance, in Java, an instance method declared in `MyClass` can be called by appending `.` to a variable of type `MyClass`. The object referenced by the variable is accessible in the method, as well as its attributes. This intuitively allows us to write methods with one less argument. For instance, consider the following method, which is _not_ and instance method. It verifies whether two instance of `MobileUnit` have the same color: ```Java public boolean sameColor(MobileUnit u1, MobileUnit u2){ return u1.color.equals(u2.color); } ``` This method may be called as follows: ```Java Unicorn myUnicorn = new Unicorn(\"green\"); Butterfly myButterfly = new Butterfly(\"green\"); boolean sameColor = sameColor(myUnicorn, myButterfly); ``` Instead, one may write an equivalent method, as an instance method of our class `MobileUnit`, with one less argument: ```Java public abstract class MobileUnit extends Unit { String color; ... public boolean sameColorAs(MobileUnit otherUnit){ return color.equals(otherUnit.color); } } ``` and we can call this method as follows: ```Java Unicorn myUnicorn = new Unicorn(\"green\"); Butterfly myButterfly = new Butterfly(\"green\"); boolean sameColor = myUnicorn.sameColorAs(myButterfly); } ``` ## Overriding {#overriding} A same instance method can be declared in a class _C_ and a subclass _S_ or _C_. In this case, we say that _S_ **overrides** the method. When such a method is called, the _most specific_ applicable version is executed. For instance, let us extend our example from the previous section with a method `regen`, declared in both `Unit` and `MobileUnit`, as follows: ![](/img/diagrams/plantuml/method_inherit_simple.svg) ```Java public abstract class Unit { int health; ... public void regen(){ if(health \u003c 10){ health += 1; } } } ``` ```Java public abstract class MobileUnit extends Unit { ... public void regen(){ if(health \u003c 10){ health += 1; } health += 1; } } ``` Now consider this program. ```Java Unicorn myUnicorn = new Unicorn(\"green\"); myUnicorn.regen(); ``` This program increases the health of (the object referenced by) `myUnicorn` by 2, because `Unicorn` is a subclass of `MobileUnit`. However, the following program increases the health of (the object referenced by) `myWall` by 1, because `Wall` is a subclass of `Unit`, but not a subclass of `MobileUnit`. ```Java Wall myWall = new Wall(); myWall.regen(); ``` **_Hint._** In Java, you can use the annotation `@Override` to indicate that a method overrides another, as follows: ```Java public abstract class MobileUnit extends Unit { ... @Override public void regen(){ if(health \u003c 10){ health += 1; } health += 1; } } ``` This is not necessary. The benefit is that the program will not compile if the overridden and overriding methods have different signatures. More generally, _syntactic_ mistakes (a.k.a. compile time errors) are easier to fix than _bugs_ (a.k.a. runtime errors). So when possible, it is good practice to use features of a language that prevent compilation if incorrect programs. This is why debugging in an untyped language (like Python, Javascript, Lua, etc.) can be more difficult than in a _typed_ one (such as Java, C#, Typescript, etc.). ## Dynamic dispatch (a.k.a. runtime polymorphism) {#dispatch} **Dynamic dispatch** consists in determining which version of a method must be called when a program is executed (a.k.a. \"at run time\"), when this cannot be determined by analyzing the program alone. This is a feature of most (class-based) object-oriented languages. For instance, in our example, assume a method `generateRandomUnits` that generates a random array of units (butterflies, unicorns or walls). And let us call the method `regen` for each unit in this array: ```java Unit[] ramdomUnits = generateRandomUnits(); for (Unit unit: randomUnits){ unit.regen(); } ``` The most specific applicable version of the method `regen` will be executed for each unit, based on its type, even though this type cannot be determined at compile time. For instance, if there is an instance of `Unicorn` in this array, then the method `MobileUnit.regen()` will be executed for this instance (rather than the method `Unit.regen()`). ## Code factorization An overriding method often extends the functionality of the overridden one. This is a possible source of [duplicate code](https://en.wikipedia.org/wiki/Duplicate_code). For instance, in the example above, both implementations of `regen()` contain: ```java if(health \u003c 10){ health += 1; } ``` A common way to factorize this consists in calling the overridden method inside the overriding one. In Java, the keyword `super` allows us to distinguish the two methods (since they have the same name). For instance, in the above example, the overriding method may be better written as follows: ```Java public abstract class MobileUnit extends Unit { ... public void regen() { super.regen(); health += 1; } } ``` Exercise In this example, what would be the effect of replacing `super.regen()` with `regen()`? Solution The method would not terminate. Exercise Consider the method `encounter` of the previous section. Add it as an instance method to our example, so that: - the method now distinguishes the attacker from the defender, - a wall cannot attack, - a unicorn gets a regen if it defends. Possible solution The trick here consists in viewing an encounter from the point of view of the defender: ![](/img/diagrams/plantuml/method_inherit_complex.svg) ```Java public abstract class Unit { int health; ... public void defend(MobileUnit attacker) { // save the initial value of the first unit's health int copy = health; health -= attacker.health; attacker.health -= copy; } } ``` ```Java public class Unicorn extends Unit { ... public void defend(MobileUnit attacker) { regen(); super.defend(attacker); } } ``` "},{"id":42,"href":"/docs/interfaces/","title":"Interfaces","section":"Docs","content":" # Interfaces The term **interface** is used to refer to a variety of artifacts. For instance (in computer science alone): (graphical) user interface, command-line interface, Application Programming Interface (API), hardware interfaces, etc. What do these have in common? One may think of an interface as a set of _conventions_ adopted by two \"agents\" (human being, program, ...) to communicate. For instance: - if Alice sends a message to Bob, then she has to use a language that Bob can understand, - if Alice uses git via command-line, then she has to use a command that git recognizes as a possible input, - if a program calls git, then it also has to use a command that git recognizes as a possible input, - etc. **_Warning._** A program interface usually specifies communication in _one direction_ only. So when two programs communicate, they may use different interfaces, one in each direction (a rough analogy could be communication between a human being and a dog). "},{"id":43,"href":"/docs/background/sections/order/","title":"Relation, preorder","section":"Background","content":" # Relation, preorder ## Relation **_Definition._** A **relation** over a set $S$ is a set of [tuples](http://localhost:44407/docs/background/sections/set_tuple_map/#tuple) over $S$ with the same arity. In particular: - a **binary relation** over $S$ is a set of [pairs](http://localhost:44407/docs/background/sections/set_tuple_map/#tuple), or equivalently a subset of $S \\times S$, - a **ternary relation** over $S$ is a set of [triples](http://localhost:44407/docs/background/sections/set_tuple_map/#tuple), or equivalently a subset of $S \\times S \\times S$, - etc. For instance, if \\(S = \\{a,b,c,d\\}\\) , then - \\(\\Big\\{ (a,a),\\ (a,b),\\ (b,a),\\ (b,c) \\Big\\}\\) is a binary relation over \\(S\\) , - \\(\\Big\\{ (a,b,a),\\ (c,c,c) \\Big\\}\\) is a ternary relation over \\(S\\) . Exercise If $S$ is finite with size $n$, then how many $k$-ary relations are there over $S$? Solution A $k$-ary relation over $S$ is a subset of $S^k$. So there are $2^{|S^k|} = 2^{n^k}$ $k$-ary relations over $S$. ### Binary relation A binary relation can be represented in multiple ways. In particular, it can be represented as a (directed) **graph** (and conversely). For instance, the relation \\(\\Big\\{ (a,a),\\ (a,b),\\ (b,a),\\ (b,c) \\Big\\}\\) over \\(\\{a,b,c,d\\}\\) can be viewed as the graph: ![](/img/order/graph_basic.svg) A binary relation can also be represented with an infix symbol. For instance, the same relation \\(\\Big\\{ (a,a),\\ (a,b),\\ (b,a),\\ (b,c) \\Big\\}\\) can be represented as \\(a \\preceq a\\) , \\(a \\preceq b\\) , \\(b \\preceq a\\) , \\(b \\preceq c\\) . ### Reflexivity, transitivity, antisymmetry **_Definition._** A binary relation $\\preceq$ over a set $S$ is - **reflexive** if $x \\preceq x$ for all $x \\in S$ - **transitive** if for all $x, y, z \\in S$ $\\qquad \\qquad \\qquad x \\preceq y$ and $y \\preceq z$ imply $x \\preceq z$ - **antisymmetric** if for all $x, y \\in S$ $\\qquad \\qquad \\qquad x \\preceq y$ and $y \\preceq x$ imply $x = y$ Exercise Which of these three properties does the relation below satisfy? ![](/img/order/graph_prop.svg) Solution Only reflexivity. ### Preorder, order {#preorder} **_Definition._** A binary relation is a **preorder** if it is reflexive and transitive. It is an **order** if it is also antisymmetric. ### Total vs partial **_Definition._** A preorder $\\preceq$ over $S$ is **total** if every two elements of $S$ are comparable, i.e. if $ \\qquad \\qquad x \\preceq y$ or $y \\preceq x$ for all $x, y \\in S$. A preoder that is not total is called **partial**. **_Example._** The natural order $\\le$ over $\\mathbb{R}$ is a total order (i.e. total, reflexive, transitive and antisymmetric). **_Example._** If $S$ is a set, then the set inclusion relation $\\subseteq$ over the [power set](http://localhost:44407/docs/background/sections/set_tuple_map/#set) of $S$ is a partial order (i.e. reflexive, transitive and antisymmetric). **_Warning._** The term \"order\" is often used to refer to a _total_ order. ### Sorting If \\(S\\) is a set, then a total preorder over \\(S\\) is intuitively any relation that allows _sorting_ \\(S\\) . **_Example._** Let $P$ be the set of people, and let $\\preceq_{\\text{age}}$ be the relation defined over $P$ by $\\qquad \\qquad p_1 \\preceq_{\\text{age}} p_2$ iff $p_1$ is younger than (or as old as) $p_2$. Then $\\preceq_{\\text{age}}$ is a total preorder (i.e. total, reflexive and transitive), but it is not an order (i.e. not antisymmetric), because two persons can have the same age. ### Lexicographic product {#lexProduct} **_Notation._** If $\\preceq_o$ is a preorder, let us use: - $x \\prec_o y$ as a shortcut for ($ x \\preceq_o y$ and $ y \\not\\preceq_o x$ ), - $x =_o y$ as a shortcut for ($x \\preceq_o y$ and $y \\preceq_o x$ ). **_Definition._** The **lexicographic product** $\\preceq_{1,2}$ of a preorder $\\preceq_1$ by a preorder $\\preceq_2$ is defined by $\\qquad \\qquad x \\preceq\\_{1,2} y$ iff $x \\prec_1 y$ or ( $x =_1 y$ and $x \\preceq_2 y$ ) **_Example._** Let $P$ be the set of people, and let $\\preceq_{\\text{age}}$ and $\\preceq_{\\text{size}}$ be the total preorders defined over $S$ by $\\qquad \\qquad p_1 \\preceq_{\\text{age}} p_2$ iff $p_1$ is younger than (or as old as) $p_2$, and $\\qquad \\qquad p_1 \\preceq_{\\text{size}} p_2$ iff $p_1$ is smaller than (or as tall as) $p_2$. Then the lexicographic product $\\preceq_{\\text{age, size}}$ of $\\preceq_{\\text{age}}$ by $\\preceq_{\\text{size}}$ is defined by $\\qquad p_1 \\preceq_{\\text{age, size}} p_2$ iff $\\qquad \\qquad p_1$ is strictly younger than $p_2$, or $\\qquad \\qquad$ they have the same age and $p_1$ is smaller than (or as tall as) $p_2$. **_Warning._** The lexicographic product of $\\preceq_1$ by $\\preceq_2$ may differ from the lexicographic product of $\\preceq_2$ by $\\preceq_1$. **_Hint._** The lexicographic product of a total preorder by a total preorder (resp. a total order) is itself a total preorder (resp. a total order). "},{"id":44,"href":"/docs/env/sections/install/","title":"Software management","section":"Development environment","content":" # Software management ## Dependencies As a developer, you frequently need to download, install and/or update: - libraries used in your projects (called **dependencies**), - core programming utilities, such as a compiler or interpreter for a given programming language, a package manager, etc. - tools for software development: editor, debugger, visualization tool, etc. These programs have their own dependencies, that have their own dependencies, etc. And two programs may depend on different _versions_ of a same third program. **Dependency management** is a frequent source of complications during software development. Dependency patterns that may occur include: - co-dependencies: For instance, consider the following configuration: - Project \\(P\\) depends on a certain version of Library \\(L_1\\) , - \\(P\\) also depends on Library \\(L_2\\) , which depends on an older version of \\(L_1\\) (and the two versions are not compatible), The build of project \\(P\\) may fail because it can contain only one version of \\(L_1\\) . - cyclic dependencies: - Library \\(L_1\\) depends on a specific version of Library \\(L_2\\) , and - \\(L_2\\) depends on a specific version of \\(L_1\\) . Upgrading one of these two libraries independently may prevent the other one to run. But it may be possible to upgrade both at the same time. - etc. Note that in these two examples, dependencies may be direct or transitive. As a result, it can be very difficult to _diagnose_ such problems. The term [dependency hell](https://en.wikipedia.org/wiki/Dependency_hell) is sometimes used to refer to such situations. Two (non-exclusive) broad approaches are commonly adopted to avoid such issues: - **automated dependency management**, and - **self-containment**: avoid shared libraries, each program having a copy (some of) its own dependencies. ## Automated dependency management ### Definitions {#package} A **package** is a program together with some metadata. These metadata include the program's name, version, release date, authors, licence and _dependencies_ (together with their _versions_). A **software repository** is a collection of packages that comply to the same format of metadata. A software repository (precisely, multiple copies of it) is generally hosted on the cloud. A **package manager** automates the installation (as well as configuration, update and removal) of packages from a software repository (or several) to a user's machine. ### Examples Many _programming languages_ have dedicated package managers. For instance: - Maven for Java, - npm for Node.js (Javascript) - pip for Python, - NuGet for .NET (C#, F#, and Visual Basic) - RubyGems for Ruby, - CPAN for Perl - CRAN for R, - etc. Some _applications_ also have dedicated software repositories for plugins (and plugin managers to handle these plugins). For instance. - The VSCode market place, - CTAN for LateX, - MELPA for Emacs, - etc. Other applications (such as zsh, vim or neovim) only have plugin managers, without a centralized software repository. These managers install plugins directly from hosts (e.g. a GitHub repository) specified by the plugins' authors. Last (but not least), an _operating system_ (OS) may use a package manager and software repositories. Notably, this is the preferred way of installing software on most Linux distributions. Widely used OS package managers include: - apt for Debian and derivatives, - dnf for Fedora and derivatives, - pacman for Arch and derivatives, - homebrew for macOS, - chocolatey (since 2011) and winget (since May 2021) for Windows. ### Usage {#packageManager} Installing, updating and removing software via a package manager is _highly recommended_ in most scenarios. In particular: - _dependencies_ of a package are also installed (or it some cases updated or removed) _transitively_, - some package managers can install and manage _several versions_ of the same package (when needed), - the installation process often uses a _default_ configuration and directory layout (environment variables, etc.) that facilitates interaction with other programs. The installation (or update or removal) procedure is also _significantly simpler_, thus leaving less room for manual errors. As an illustration, here is the full procedure to install Maven with the apt package manager (on Debian and derivatives): ```bash apt install maven ``` and similarly with homebrew (on macOS): ```bash brew install maven ``` or with Chocolatey (on Windows): ```bash choco install maven ``` In comparison, the procedure to install Maven manually on Windows is [more involved](https://phoenixnap.com/kb/install-maven-windows), thus more likely to introduce errors (trough inadvertence, or by following outdated instructions). However, in some (rare) scenarios, a manual installation may be preferred. In particular when the latest version of a program is needed, but not available yet on the software repository. ## Self-containment A variety of strategies can be adopted to build a program so that it runs in partial _isolation_ from the rest of the system that it is deployed on (i.e. in its own environment, and with its _own dependencies_, that cannot be used by other programs). For instance, a Node.js project often includes a _copy_ of all the Javascript libraries that it depends on (transitively). Further self-containment strategies may involve different levels of virtualization (e.g. via Docker). This is one way of avoiding shared dependencies. Other benefits are increased _portability_, and ease of installation by end-users. Drawbacks include and increased workload on the developer's side (e.g. for maintenance), and limited opportunities for integration with other programs. ### Self-containment in Java In Java, self-containment is usually less pronounced during development. Java libraries are typically managed via Maven: - on a _per-user_ basis (which can be viewed as a compromise between per-project and system-wise): each user has a hidden folder `/.m2/` that contains all Java libraries used in his/her projects, and - allowing _multiple versions_ of the same library to coexist. However, a Java application that targets non-developers can be released together with its Java dependencies, as a so-called **über jar** (a.k.a. **fat jar**). "},{"id":45,"href":"/docs/abstractdatatypes/sections/queue/","title":"Stack, queue, priority queue","section":"Abstract data types","content":" # Stack, queue, priority queue Some abstract data types impose strong limitations on the set of operations allowed on a collection. These limitations provide opportunities for _specialized implementations_ (i.e. specialized data structures), which can be very _efficient_ in some contexts. ## Stack A **stack** (or **Last In First Out queue** or **LIFO queue**) simulates a collection organized as a physical stack (for instance a stack of plates). A stack exposes three main methods: - **push** adds an element to the collection, - **pop** removes and returns the most recently added element, - **isEmpty** is self-explanatory. ## Queue A **queue** (or **First In First Out queue** or **FIFO queue**) simulates a collection organized as physical queue (for instance a waiting line). A queue exposes three main methods: - **enqueue** (or **add**) adds an element to the end of the queue, - **dequeue** (or **poll**) removes and returns the earliest enqueued element, - **isEmpty** is self-explanatory. ## Priority queue A **priority queue** simulates a collection equipped with a [total preorder](http://localhost:44407/docs/background/sections/order/#preorder), so that only (one of) the element(s) with highest priority can be retrieved. A priority queue exposes three main methods: - **insert** adds an element to the collection, - **getMaximumElement** removes and returns an element with highest priority, - **isEmpty** is self-explanatory. **_Note._** A regular queue can be viewed as a specific case of priority queue, where each inserted element has (strictly) lower priority than the previous one. "},{"id":46,"href":"/docs/abstractdatatypes/","title":"Abstract data types","section":"Docs","content":" # Abstract data types An **abstract data type** (ADT) is a programming [interface](http://localhost:44407/docs/interfaces/sections/specification/) to access and manipulate a collection of elements. For instance, a _queue_ is an ADT that mimics the behavior of a \"first come first served\" queue (e.g. a waiting line at a post office). This interface typically exposes three methods: - one that checks whether the queue is empty, - one that takes as input an element and adds it to the end of the queue, - one that removes the first element of the queue and returns it. An ADT may have _several implementations_. For instance, a queue may be implemented as an array or as a linked list (among others). Each implementation may have advantages and drawbacks (in terms of performance, memory footprint, parallelization opportunities, etc.) for different tasks (reading, writing, etc.). A **data structure** (e.g. an array, a linked list, a hash map, etc.) is _not_ an ADT, but a (concrete) way to store a collection of elements (values, objects, etc.) in memory. However, a data structure can [implement]() one or several ADT(s). Some ADTs correspond to [basic mathematical objects](http://localhost:44407/docs/background/sections/set_tuple_map/) (set, tuple, function, etc.), and are therefore easy to understand and manipulate. They allow you to easily write code that is _correct_, but may be _inefficient_ if you do not have a good understanding of underlying (concrete) data structure. Another benefit of ADTs is that they can make your code significantly easier to read (thus requiring less documentation). For instance, if your program manipulates a collection of objects without duplicates and whose order is irrelevant, then you can simply use the Java interface `Set`, which is self-explanatory. ## in Java ### Generic types An ADT in Java is usually a [parameterized]() type, meaning that it has one or several types as parameter. For instance, a set of strings in Java has type `Set`. **_Note._** In Java, a primitive type (like `int` or `bool`) _cannot_ be used as a type parameter, but a [boxed type](http://localhost:44407/docs/objects/sections/quasi-objects/#boxedTypes) (like `Integer` or `Boolean`) can. For instance, the type `Set` is valid. ### The interface `Collection` In Java, many ADTs and data structures extend or implement the interface [Collection](https://docs.oracle.com/javase/8/docs/api/java/util/Collection.html) (the only exception in this chapter is `Map`). Among others, the interface `Collection` specifies the following methods (if `E` is the type of the elements in the collection): - `int size()` - `boolean add(E e)` - `boolean contains(Object o)` - `boolean isEmpty()` - `boolean remove(E e)`, - etc. **_Warning._** Some of these methods are so-called \"optional operations\", meaning that they may not be available for some implementations of `Collection`. Like an array, a collection can be iterated over, for instance with a \"foreach\"-like loop: ```java for (E element: myCollection){ ... } ``` Another way to iterate over a collection consists in using an [iterator](https://www.baeldung.com/java-iterator). **_Warning._** Some collections (e.g. some implementations of the subinterface `Set`) do _not_ offer any guarantee on the order of their elements! ### External libraries Some external libraries provide additional implementations of Java's ADTs. For instance, Java has 19 native implementations of the ADT `Map` (e.g. `HashMap`,`TreeMap`, etc.). But [Guava](https://github.com/google/guava) provides additional ones, like `ImmutableMap`, `HashBiMap`, etc. "},{"id":47,"href":"/docs/git/sections/commit/","title":"Add, commit, stash","section":"git","content":" # Add, commit, stash ## Staging files Git lets you to choose which modifications will be part of your next commit. First, run ```bash git status ``` This will show which files have been added or modified since the last commit on the current branch (if any). In order to add (some of) these files to the next commit, you need to **stage** them. If you want to stage _all_ these files, from the root of the repository, run ```bash git add . ``` **_Hint._** You can create a [.gitignore](http://localhost:44407/docs/git/sections/ignore/) file to indicate files of folders that should never be staged. This allows you to use `git add .` without staging by accident compiled files, IDE-generated files, etc. Alternatively, to stage a specific file, run ```bash git add ``` At any moment, you can check which files have been staged with ```bash git status ``` You can also unstage all staged files with ```bash git reset . ``` And unstage a single file with ```bash git reset ``` ## Commit Once you have staged your file, you can commit with ```bash git commit -m \"\" ``` If you do not add the `-m \"\"` option to your command, then git will open a text editor where you can type a commit message. If this happens, then type your commit message, save and close the file. **_Warning._** By default, on most operating systems, git opens [vi](https://en.wikipedia.org/wiki/VI) as a text editor. I you have never used vi, we recommend [selecting another default text editor](http://localhost:44407/docs/git/sections/config/#textEditor). ## Stash ```bash git stash ``` temporarily reverts all modifications made to your repository since the last commit. To apply them back, run ```bash git stash pop ``` "},{"id":48,"href":"/docs/intro/sections/board_game/","title":"Board game","section":"This course","content":" # Board game In order to follow this course, you will need to play one of the two following video games: - [Might \u0026 Magic: Clash of Heroes](https://www.dotemu.com/games/might-magic-clash-of-heroes-definitive-edition/), or - [Legend of Solgard](https://snowprintstudios.com/solgard/). These two games have very similar mechanics. So by default, we will refer to them as a unique game (e.g. when we write \"this game\" or \"our board game\"). ## Why this game Turn-based board games (like chess, go, checkers, etc.) are traditionally a good playground to learn the basics of algorithmic thinking. **_Disclaimer._** This course is _not_ about video game development, but general-purpose programming. This game will only serve as _didactic support_. Precisely, this game will serve two purposes: - we will use it as a running example throughout the lectures, and - you can choose to implement (your own version of) this game as [your project](http://localhost:44407/docs/project/sections/board_game/) By default, we will focus on the _two player_ variant, where both players play by the same rules. These two players may be humans and/or bots. ## How long do I need to play You only need to play long enough to get a reasonable understanding of the mechanics of the game. 1.5 to 2 hours should be sufficient. **_Warning._** In both games, mechanics are introduced gradually, so you are unlikely to get a full overview by playing less than an hour. ## Which game to choose ### Might and Magic clash of heroes (MMCoH) This game was initially released in 2009 for Nintendo DS. It has then been ported to PC and several consoles, as well as Android and iOS. A free demo was available on Steam until July 2023. Unfortunately, the game has been re-released since, by another editor (as a so-called \"definitive edition\"). As a result, the demo is not available on Steam anymore. The Android and iOS versions have also been removed from the Google Play store and App store respectively. **_Advantages._** - The mechanics of this game may be easier to understand (in a short amount of time). - The default mode is the (symmetric) 2 player mode (player vs bot or player vs player) that we will work on. **_Drawbacks._** - The touch-screen interface on Android and iOS is arguably dated. ### Legend of Solgard This game was released in 2016 for Android and iOS. It is still available on the Google Play store and the App store. It is free to play, with optional microtransactions (via so-called [loot boxes](https://en.wikipedia.org/wiki/Loot_box)). **_Warning._** For this course, you do _not_ need to perform any transaction. **_Advantages._** - Animations can be sped up. - The touch-screen interface is more modern than the one of MMCoH for Android and iOS. **_Drawbacks._** - Progression is based on a (complex) system of virtual currencies, which may add noise to the interface. - The game can only be played (for free) a limited amount of time per day (approximately 45 min). - The default mode is _not_ the (symmetric) 2 players mode that we will work on (it requires more playtime to be unlocked). So you will need an extra effort of imagination. "},{"id":49,"href":"/docs/errors/sections/custom/","title":"Custom exceptions","section":"Errors","content":" # Custom exception Custom exceptions can be created by extending one of Java's native exception types. For instance: ```java public class WrongNumberOfRowsException extends IllegalArgumentException { public WrongNumberOfRowsException(int numberOfRows) { super(\"This sudoku grid has \"+numberOfRows+\" rows, whereas it should have 9\"). } } ``` A custom exception can be [thrown](http://localhost:44407/docs/errors/sections/exceptions/#throw) like a regular one: ```java if(sudokuGrid.length != 9){ throw new WrongNumberOfRowsException(sudokuGrid.length); } ``` **_Observation._** In this example, `WrongNumberOfRowsException` extends `IllegalArgumentException`, which extends `RuntimeException`. Recall that an instance of a subclass of `RuntimeException` is [unchecked](http://localhost:44407/docs/errors/sections/checked/#unchecked). Therefore an instance of `WrongNumberOfRowsException` is an unchecked exception. "},{"id":50,"href":"/docs/build/sections/dependencies/","title":"Dependencies","section":"Build automation","content":" # Dependencies Maven (like Gradle) acts both as a [build automation tool]() and as a [package manager](). As a package manager, Maven (like Gradle) relies by default a [software repository]() called Maven Central. This repository contains more than 260.000 artifacts (more than 6 million when counting versions), with over a trillion downloads in 2023. An artifact on Maven Central is identified by its [coordinates](). ## Finding a library's coordinates The coordinates of a library are often provided as part of its documentation. For instance, this is the case of Google's [Guava](https://github.com/google/guava?tab=readme-ov-file#adding-guava-to-your-build) library. Alternatively, [this website](https://mvnrepository.com/) can be used to search for the coordinates of an artifact on Maven Central (as well as 1990 other repositories). For instance, [here](https://mvnrepository.com/artifact/com.github.haifengl/smile-core/3.1.0) are the coordinates for the latest version of the [Smile](https://haifengl.github.io/index.html) library for machine learning. ## Local repository {#localRepo} By default, Maven _caches_ project dependencies (as [jars]()) in a hidden directory with path `/.m2` (or `\\.m2` on Windows). In Maven's terminology: - this directory is called the **local repository**, - an artifact is **installed** when it is added the local repository. When a project is build, Maven searches for each dependency in the local repository. If the corresponding artifact is not installed, then it is downloaded (e.g. from Maven central) and installed. Gradle proceeds in a similar way (but the cache is under `/.gradle`). **_Note._** The local repository can contain different versions of the same artifact. **_Note._** By default, when installing an artifact, Maven also installs _all its missing dependencies, transitively_. Gradle proceeds in a similar way. **_Warning._** Maven (like Gradle) does not support cyclic dependencies, i.e. an artifact cannot depend on itself (directly or transitively). Exercise Does this imply that the dependencies of an artifact form a tree? Solution No. A tree is a rooted acyclic graph, but the converse does not hold. To display the dependency graph of a project (unraveled as a tree), run: ```bash mvn dependency:tree ``` If a project depends (transitively) on two versions of the same artifact, then the [\"closest\" version](https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html#transitive-dependencies) (in the dependency graph) is chosen (or the first declared in case of a tie). **_Note._** If a project depends on a `SNAPSHOT` version, then the installed artifact is automatically updated on a regular basis (by default once per day), by both Maven and Gradle. ## Declaring a dependency ### Maven A dependency can be declared by adding the following to the `pom.xml` file, inside the `` tag: ```xml XXX XXX XXX ``` In addition, the attribute `test\u003c\\scope\u003e` can be added to indicate that the dependency is needed for unit tests only ([other scopes](https://maven.apache.org/guides/introduction/introduction-to-dependency-mechanism.html#dependency-scope) can be specified). **_Example._** Here is how to declare dependencies on Guava, Smile and JUNIT 5, while specifying that the latter is only needed for unit tests: ```xml com.google.guava guava 33.1.0-jre com.github.haifengl smile-core 3.1.0 org.junit.jupiter junit-jupiter-api 5.10.2 test ``` ### Gradle {#gradleDep} There are several alternative syntaxes to declare a dependency with Gradle (these may depend on the project's configuration). **_Example._** If you chose the [board game](http://localhost:44407/docs/project/sections/board_game/) as your project, then you can declare a dependency in the file `core/build.gradle` as follows. Within: ```groovy dependencies { ... } ``` add a line: ```groovy implementation group: XXX, name: XXX, version: XXX ``` For instance: ```groovy implementation group: 'com.google.guava', name: 'guava', version: '33.1.0-jre' ``` To specify that the dependency is only needed for unit tests, replace `implementation` with `testImplementation`. ## Using an external library Once a dependency is declared, the classes and interfaces of the corresponding library can be used in the source code of the project, with a regular `import` statement. **_Example._** Guava provides a convenient class `ImmutableList` for lists that cannot be modified. It can be used as follows: ```java import com.google.common.collect.ImmutableList; public class MyClass { String name; ImmutableList values; public MyClass(String name, ImmutableList values){ this.name = name; this.values = values; } ... } ``` **_Hint._** Import statements like the one above can be automatically generated by your IDE. "},{"id":51,"href":"/docs/objects/sections/tostring/","title":"Displaying objects","section":"Objects and classes","content":" # Displaying objects ## The class `Object` Java has a native class called `Object` with [11 instance methods](https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html). Every Java class implicitly extends `Object`, _including user-defined classes_. Therefore any Java class _inherits_ these methods. ## The method `toString` [toString](https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#toString) is one of the methods of the class `Object`. Here is (part of) its specification: ```java /** Returns a string representation of the object. * In general, the toString method returns a string that * \"textually represents\" this object. */ public String toString(); ``` This is the preferred way to display information about an object. For instance, the debugger of your IDE probably relies on this method to display a string that represents an object. This method is also called by many (native or not) methods and operators. For instance, the following program ```java Unicorn myUnicorn = new Unicorn(\"green\"); System.out.println(myUnicorn); String message = \"Hello \" + myUnicorn; ``` is equivalent to ```java Unicorn myUnicorn = new Unicorn(\"green\"); System.out.println(myUnicorn.toString()); String message = \"Hello \" + myUnicorn.toString(); ``` ### Overriding toString The default implementation of `toString` (in the class `Object`) displays very little information about the object: ```java public String toString() { return getClass().getName() + \"@\" + Integer.toHexString(hashCode()); } ``` **_Warning._** The output of `hashCode()` in this example is _not_ the reference (a.k.a. \"memory address\") of the object. So a common practice consists in [overriding](http://localhost:44407/docs/objects/sections/methods/#overriding) `toString`. For instance, here is a possible implementation of the method `toString` within a class `Unicorn`: ```java public class Unicorn { String color; int health; @Override public String toString() { return \"Unicorn{\" + \"color=\" + color + \", \" + \"health=\" + health + \"}\"; } } ``` **_Hint._** Your IDE can generate such a method. ### Recursion {#recursion} A naive implementation of `toString` (e.g. generated by an IDE) may have unexpected effects. Exercise Consider an implementation of our game where units (on each side of the board) are grouped by column. This implementation may use a class `Column` to represent a column and the adjacent one(s), as follows: ```java public class Column { Unit[] units; // null if this is the left-most column Column leftAdjacentColumn; // null if this is the right-most column Column rightAdjacentColumn; public Column(Unit[] units){ this.units = units; } @Override public String toString() { return \"Column{\" + \"left=\" + leftAdjacentColumn +\", \" + \"right=\" + rightAdjacentColumn +\", \" + \"units=\" + units + \"}\"; } } ``` Then a board may be created as follows: ```java Unit[] a1 = new Unit[]{ new Unicorn(\"green\") }; Column c1 = new Column(a1); Unit[] a2 = new Unit[]{ new Butterfly(\"yellow\") }; Column c2 = new Column(a2); c1.rightAdjacentColumn = c2; c2.leftAdjacentColumn = c1; System.out.println(c1); ``` There is an issue with this program. Can you identify it? Solution The program does not terminate, because `toString` is (implicitly) recursive, and each of the two columns refers to the other. "},{"id":52,"href":"/docs/unittests/sections/junit/","title":"in Java","section":"Unit tests","content":" # Unit tests in Java Several frameworks are available in Java for unit tests. Popular frameworks include: - [JUnit 4](https://junit.org/junit4/) - [JUnit 5](https://junit.org/junit5/) - [TestNG](https://testng.org/) - [Spock](https://spockframework.org/) In this section, we focus on Junit 5. ## Install Junit 5 with Maven Junit 5 can be used in a Maven project by declaring the following [dependency](http://localhost:44407/docs/build/sections/dependencies/) and [plugin](http://localhost:44407/docs/build/sections/building/#installPlugin) ```xml ... org.junit.jupiter junit-jupiter 5.10.2 test ... ... org.apache.maven.plugins maven-surefire-plugin 3.2.5 ... ``` For the latest versions, search [Maven Central](https://mvnrepository.com). ## Layout ### Maven Recall that in a [Maven project](http://localhost:44407/docs/build/sections/layout/), by default: - source code for unit tests is located in the directory `src/test/java`, - resources for unit tests (e.g. data) are located in the directory `src/test/resources`. **_Note._** You can create sub-directories (in these directories) to organize your tests and resources. ### Gradle Junit 5 can be used with Gradle in a similar way, but the directories for unit tests and related resources and (usually) specified manually. **_Hint._** If you chose the [board game](http://localhost:44407/docs/project/sections/board_game/) as your project, then you can write JUnit 5 tests under `core/src/test/java`. You will also find (dummy) unit tests in the directory `core/src/test/java/dummy`. ## Writing unit tests With Maven, any (public or protected) Java class in `src/test/java` (or a subdirectory) can contain JUnit tests. A **Junit 5 test** is a (public or protected) _instance method_ : - with `void` return type, - annotated with `org.junit.jupiter.api.Test`. In addition, the method usually contains one or several calls to static methods of JUnit's [Assertions](https://junit.org/junit5/docs/5.0.1/api/org/junit/jupiter/api/Assertions.html) class, like `assertEquals` or `assertThrows`. The test succeeds iff _all_ these calls return `true`. For instance, the following class contains a single (successful) test: ```java import org.junit.jupiter.api.Test; import static org.junit.jupiter.api.Assertions.assertEquals; public class MyTests { @Test void myTest(){ String myString = \"foo\"; assertEquals(true, myString.contains(\"oo\")); } } ``` **_Warning._** The method `assertEquals` takes the expected value as first argument, and the actual one as second argument. This has an incidence on logs in case of test failure (\"expected\" : XXX, \"actual: \"YYY\"); **_Hint._** A string can be passed to `assertEquals` as third argument, in order to display an additional message in case of failure. **_Hint._** Most methods of the class [Assertions](https://junit.org/junit5/docs/5.0.1/api/org/junit/jupiter/api/Assertions.html) are syntactic sugar (thus not strictly necessary). For instance ```java assertTrue() ``` is a shortcut for ```java assertEquals(true, ) ``` **_Warning._** By default, the execution of a test method is interrupted as soon as an assertion fails. So following instructions (for instance other assertions) will _not_ be executed. ### Checking exceptions The assertion `assertThrows` allows checking whether the execution of a piece of code method throws an exception of a given type. For instance the following unit test succeeds: ```java @Test void testException(){ assertThrows( ArithmeticException.class, () -\u003e { int x = 2 / 0; } ); } ``` ### Prior and/or subsequent code The annotation `@BeforeAll` (resp. `@AfterAll`) can be used to indicate that a (static) method must be executed (only _once_) before (resp. after) all unit tests in the class, regardless of test successes or failures. This can be used for costly operations, or for opening (resp. closing) a resource, like an connection or an input (resp. output) stream. For instance ```java import org.junit.jupiter.api.AfterAll; import org.junit.jupiter.api.BeforeAll; import org.junit.jupiter.api.Test; import java.sql.Connection; public class SQLTests { Connection myConnection; @BeforeAll static void openConnection(){ ... } @Test void test1(){ ... } @Test void test2(){ ... } @AfterAll static void closeConnection(){ ... } } ``` Similarly the annotation `@BeforeEach` (resp. `@AfterEach`) can be used to indicate that a method must be executed before (resp. after) _each_ unit test in the class. This can be convenient to avoid copy-pasting code. For instance ```java import org.junit.jupiter.api.BeforeEach; import org.junit.jupiter.api.Test; public class BoardgameTests { Snapshot testSnapshot; @BeforeEach void createTestSnapshot(){ testSnapshot = new DummySnapshot(); } @Test void test1(){ ... } @Test void test2(){ ... } } ``` ### Disabling tests A unit test can be disabled with the annotation `@Disabled`. As a result, it will be ignored by Maven, Gradle, and (to some extent) your IDE. For instance: ```java import org.junit.jupiter.api.Disabled; import org.junit.jupiter.api.Test; public class MyTests { @Test @Disabled void test1(){ ... } @Test void test2(){ ... } } ``` ## Running unit tests ### from the command line For a Maven project, the command ```bash mvn test ``` executes all phases that precede the `test` phase (e.g. `compile` and `test-compile`) in Maven's [default lifecycle](http://localhost:44407/docs/build/sections/building/#phases), and then executes all unit tests under `src/test/java`. **_Note._** The source code of unit tests (and related resources) is by default _excluded_ form the output of the `package` phase (e.g. from the jar produced by Maven). **_Note._** A unit test failure will prevent execution of Maven phases that are posterior to `test`. For instance ```bash mvn package ``` does _not_ produce the expected jar if a test fails. However, if needed, it is possible to execute a posterior Maven phase while skipping the unit tests, with the option `-DskipTests`. For instance: ```bash mvn package -DskipTests ``` ### within an IDE IDEs provide several ways to run unit tests, either: - in isolation, or - all tests within a class, or - all tests within a package (including subpackages). For instance, with IntelliJ: - click on the green arrow to run a single unit test, - click on the double green arrow to run all unit tests defined in the current class, - right click on a folder and select \"Run Tests\" to run all tests in this package. ![](/img/test/intellij.png) **_Note._** Within an IDE, a unit test can (and most often should) be run in _debug_ mode. For instance, with IntelliJ, right-click on the green arrow and select 'Debug'. "},{"id":53,"href":"/docs/env/sections/os/","title":"Operating system","section":"Development environment","content":" # Operating system (OS) Your computer does _not_ bind you to one OS. You can run _multiple_ OSs on the _same_ computer by: - partitioning your disk, or - booting from an external drive, or - using virtualisation. Depending on what you are developing, one operating system may be more convenient than another. We review below some of the benefits and drawbacks of developing under Windows, macOS and Linux. ## Windows ### Benefits and drawbacks Here are some benefits of using Windows as your OS _for software development_: - it comes pre-installed on most PCs, - it is compatible out-of-the-box with most hardware, - it provides a fully integrated development suite for the **.NET framework** (C#, F#, Visual Basic), and to a lesser extent C/C++. And some drawbacks: - for general-purpose development, Windows is _not friendly to new programmers_ (compared to Linux or macOS), - the usage of an (OS-wise) package manager is (still) not the norm, - it sometimes favors backwards compatibility over compliance with modern standards. ### When to use Windows (and when not) Windows is the OS of choice for developing software meant to run on Windows only, or cross-platform software written in one of the .NET languages (mostly C#). C# is notably used for _game development_ (e.g. for Unity) and _graphical interfaces_ (although Javascript-based graphical frameworks may have become more popular lately). Another interesting feature of C# (compared to Java) is the Language Integrated Query framework, which provides a tight integration with database engines. [Visual studio](https://visualstudio.microsoft.com/) (_not_ VSCode!) offers a fully integrated development suite for the .NET languages, and is also commonly used for C/C++. For other programming languages, using Windows may require _extra efforts_ or _precautions_ (compared to Linux or macOS), especially for new developers. In particular, _manual software installation/upgrade/removal_ can be complex and error-prone. _Writing scripts_ (e.g. for two programs to interact) can also be more involved, especially given the fact that Windows has three shells (the Windows shell, the Windows Power Shell and Power Shell), or four if counting WSL. Besides, additional care must be taken to write _platform-independent_ code. Here are for instance two frequent sources of errors made by students: 1. **_Path names:_** Windows uses `\\` as a path separator, as opposed to the `/` used by other OSs (or in web URIs). In Java, a path can be safely written with `/`. At run time (i.e. when the program is executed), this symbol will be interpreted based on the underlying OS (i.e. as `\\` on Windows, and as `/` on other OSs). However, a path written with `\\` will be interpreted as such (therefore the program will throw an exception on OSs other than Windows). 2. **_Line breaks:_** many text editors for Windows encode a line break as _two_ ascii characters (`\\r\\n`), against a _single_ character (`\\n`) on most modern systems. This is often transparent for regular users, because many text editors (or even git) use detection and normalization procedures for line breaks. However, this may be a source of bugs for developers, for instance when generating code, or when writing a script to configure a virtual environment (e.g. a Docker image). ### For this course You should be able to complete all assignments and write your project using Windows (even if your collaborators use other OSs). However, you may need to pay _extra attention_, for instance to path names (as explained above). Installing and configuring the necessary software may also be more complex (again, we recommend using a [package manager]( http://localhost:44407/docs/env/sections/install/#package) when possible). If you do not manage to set up your working environment for this course (see the [requirements](http://localhost:44407/docs/env/sections/requirements/)) in a short amount of time, then consider using a Linux distribution instead (see the [dedicated section](#linux_install) below for using Linux alongside Windows). ## macOS Here are some benefits of using macOS as your OS _for software development_: - it comes pre-installed with an Apple computer, - it is POSIX-compliant (since 2001), thus offering easier _interoperability_ with Linux/BSD/Android/IOS - the homebrew package manager is relatively mature. And some drawbacks: - some software may not be available, - your working environment is not easily customizable. ### When to use macOS (and when not) MacOS is rarely used on hardware other than Apple computers. It is often a good choice for new developers. In particular, homebrew offers an easy way to install programs needed for general-purpose development (compilers, interpreters, other package managers, etc.), and its software repository is reasonably comprehensive in that regard (albeit smaller than repositories used by Linux distributions). A number of more experienced developers also work with macOS, notably for web development (Node.js/Javascript) or data science related projects (Python). A Linux distribution may be more convenient in some situations, e.g. when developing a program meant to run on a server, or when working with Docker containers. ### For this course If you have a Apple laptop, then you should not need an OS other than macOS for this course (even if your collaborators use other OSs). ## Linux Here are some benefits of using Linux as your OS _for software development_: - it is used by most web servers servers, - it is relatively lightweight, - for developers, it has an important (and high-quality) online community support, - (OS) package managers are mature and easy to use, - your working environment can be easily customized and/or configured. And some drawbacks: - Linux rarely comes pre-installed on a computer, - there sometimes _too much choice_ of programs or distributions, - Linux distributions are (still) not as friendly to desktop users as Windows or macOS, - Hardware support (e.g. for peripherals) is (still) more limited than for Windows. ### When to use Linux (and when not) Linux is often the OS of choice for developing programs meant to run on web servers. It is also a good choice for writing cross-platform software. Linux (together with macOS) is also a good environment to learn the basics of programming, due to native compatibility with a wide range of technologies for general-purpose development (e.g. Docker). Software installation, configuration, upgrade and removal is also made easier by mature package managers. Besides, the Linux **shell** is a versatile yet relatively simple tool that can ease process management or interaction between programs. Linux is arguably _not_ the best choice for developing Desktop applications that target a specific OS (such as Windows or macOS), or in some specific domains such as game development. ### For this course You should be able to complete all assignments and write your project using a Linux distribution (even if your collaborators use other OSs). In particular, if you face important issues when setting up your working environment (git, JDK, Maven, Gradle, etc. ) on Windows, we recommend using a Linux distribution instead (because it may save you time). Keep in mind however that this will not solve issues related to the configuration of your IDE. Not that you can use Linux (for development) and Windows (for other purposes) on the _same_ computer. ### Which distribution to choose You can use any (reasonably mainstream) all-purposes Linux distribution for this course (and other courses). The choice may seem overwhelming at first sight, but most distributions are forks of a few popular ones (Debian, Fedora, Arch, ...), and are relatively similar to each other. Besides, Linux environments are highly customizable: for instance, the choice of a distribution does not bind you to its default desktop environment. Available software is also very similar from one distribution to another: regardless of the distribution, you will have access to openJDK, git, Maven, etc. via a package manager. Distributions that are more desktop-oriented can be more friendly to newcomers (especially non-developers), but also come with unnecessary software. Two popular distributions in this category (for new users) are Linux Mint and Zorin OS. Both are forks of Ubuntu, which is itself a fork of Debian. For a (slightly) more lightweight distribution, MX Linux is currently a popular choice. It is also based on Debian. ### How to install a Linux distribution {#linux_install} Most distributions provide detailed instructions on their web page. Regardless of the distribution, you have are (at least) three possible options: 1. **_Virtual machine (such as VirtualBox)._** This is the simplest option in terms of installation. But also the most expensive computationally, so only suited to a relatively powerful computer. Performance is also suboptimal. A virtual machine is often good way to test a distribution before properly installing it. 2. **_Bootable drive._** You can store your Linux distribution on an external hard drive, and boot on Linux when the hard drive is connected to your computer. Compared to the third option below, this may affect the performance of disk access. 3. **_Partition (with dual boot)._** You can dedicate a certain amount of space to a Linux distribution your hard drive. A minimum of 30 GB is often recommended, but this can be adjusted later on. When starting your computer, it will let you choose which OS to boot on. This is the best option in terms of performance. **_Note._** For the third option (dual boot), the installation procedure has become more involved on some recent computers, due to encrypted disks or so-called \"secure boot\". So make sure that the instructions that you follow are up-to-date. "},{"id":54,"href":"/docs/intro/sections/bibliography/","title":"Bibliography","section":"This course","content":" # Bibliography ## Java's syntax In each chapter of this course, you will find Java code snippets that illustrate how to perform certain operations. However, this documentation is _far from exhaustive_ (on purpose). So when it comes to syntax, the first two sources of complementary material for this course are: - the **Javadoc** of the libraries (standard and auxiliary) used in your project/assignments. Your IDE is often the [fastest way]() to navigate through it, - the web. ## Books You will find a [reading list](https://www.unibz.it/en/services/library/new-rc/) for this course in the catalogue of the Unibz's library. All books can be accessed via the library (either physically or digitally). Among these books, we highlight the following two: ### Main textbook **Java: How to Program, Early Objects** (11th edition) by Paul Deitel and Harvey Deitel Pearson, 2018 ![](/img/bib/early-objects.jpg) This is a general introductory book to Java and object oriented programming. It covers most of the topics seen in this course. ### Good practices {#effectiveJava} **Effective Java** (3rd edition) by Joshua Bloch Addison-Wesley Professional, 2017 ![](/img/bib/effective_java.jpg) This is a reference book for best practices and common pitfalls when programming in Java. "},{"id":55,"href":"/docs/build/sections/building/","title":"Building","section":"Build automation","content":" # Building ## Cleaning The command ```bash mvn clean ``` attempts to delete all content generated during a previous build (in particular, `.class` files). **_Example._** Let us assume that `MyClass.java` is compiled into `MyClass.class`, and then renamed `MyNewClass.java`. In this scenario, `mvn clean` allows eliminating the file `MyClass.class` from the `target` directory. ## The default lifecycle {#phases} Maven's **default lifecycle** is a _sequence_ of [23 operations](https://maven.apache.org/guides/introduction/introduction-to-the-lifecycle.html#default-lifecycle) (called **phases**) that can be executed during a build. These include (in order): - `validate`: checks if all the information needed for the build is present - `compile`: compiles the source code of the project - `test-compile`: compiles the source code of the unit tests of the project - `test`: runs the unit tests - `package`: packages the compiled code in its distributable format (such as a [jar](http://localhost:44407/docs/build/sections/packaging/#jar)) - `install`: installs the package into the [local repository](http://localhost:44407/docs/build/sections/dependencies/#localRepo) (for use as a dependency in other local projects) Each phase can be executed via command-line with `mvn `. For instance: ```bash mvn package ``` **_Warning._** Executing any of these phases triggers the execution of _all phases that precede it_. For instance, executing the `test` phase triggers the execution of `validate`, `compile` and `test-compile` (among others). ## Goals and plugins A build phase (like `package`) consists of so-called **goals**. A goal can be declared, configured and associated to a specific phase via a so-called **plugin**. In a POM: - a plugin is specified within the `` tag, and - plugins are declared within: ```xml ... ``` For instance, here is the plugin called `maven-jar-plugin`, as it is [inherited](http://localhost:44407/docs/build/sections/pom/#pomInherit) from the Super POM: ```xml ... org.apache.maven.plugins maven-jar-plugin 2.4 default-jar package jar ... ``` This plugin assigns the goal `jar` to the phase `package`. Intuitively, this specifies that the phase `package` must produce a `jar` file (as opposed to other formats like `war` or `ear`). In order to make this jar executable (and specify the main class of the application), we can add information to this inherited plugin, in the `pom.xml` file _of the project_, as follows: ```xml ... org.apache.maven.plugins maven-jar-plugin true org.example.Main ... ``` The [effective POM]() in this example contains: ```xml ... org.apache.maven.plugins maven-jar-plugin 2.4 default-jar package jar true org.example.Main ... ``` A plugin can contain several goals, and these may or may not be assigned to a specific phase. Besides, a goal can be executed independently from a phase, with the command: ```bash mvn myplugin:myGoal ``` For instance, the [javafx maven plugin](https://github.com/openjfx/javafx-maven-plugin) has a goal `run` to start a JavaFX application. It can be executed with: ```bash mvn javafx:run ``` ## Installing a plugin {#installPlugin} Maven plugins are available for a variety of tasks, like code analysis, Javadoc generation, parser generation, etc. An plugin is a [Maven artifact](http://localhost:44407/docs/build/sections/artifact/). Similarly to a [dependency](http://localhost:44407/docs/build/sections/dependencies/), an external plugin can be downloaded from Maven Central and installed into the [local repository](http://localhost:44407/docs/build/sections/dependencies/#localRepo) , as follows: ```xml ... XXX XXX XXX ... ... ``` However, as illustrated above, additional XML attributes may be needed to configure the plugin. These are often specific to a plugin. ## Useful plugins ### The assembly plugin The assembly plugin allows building a über jar (i.e. including dependencies), as opposed to the `maven-jar-plugin`, which can build a thin jar. This is a simple way to distribute an end-user application (as opposed to a library). ```xml org.apache.maven.plugins maven-assembly-plugin 3.7.1 package single org.example.MainClass jar-with-dependencies src ``` In this example, the execution of the goal (called `single`) is attached to the phase `package`, so the über jar can be produced like a regular jar, with: ```bash mvn package ``` ### The source plugin The source plugin can package source code as a jar. This allows: - distributing a Java library alongside its source code, and/or - installing the library in the local repository together with the source (and navigate through it with an IDE). ```xml org.apache.maven.plugins maven-source-plugin 3.3.1 attach-sources verify jar-no-fork ``` In this example, the execution of the goal (called `jar-no-fork`) is attached to the phase `verify`. ### The Javadoc plugin ```xml org.apache.maven.plugins maven-javadoc-plugin 3.6.3 17 ``` This plugin has [many goals](https://maven.apache.org/plugins/maven-javadoc-plugin/), which are often executed independently (i.s. not bound to a phase). For instance: ```bash mvn javadoc:javadoc ``` generates Javadoc for the project in the folder `target/site`. "},{"id":56,"href":"/docs/objects/sections/comparing/","title":"Cast and equality","section":"Objects and classes","content":" # Cast and Equality ## Cast Java (as well as C# and C++) provides mechanisms to change the type associated with an object _o_, using either a _supertype_ of _o_ (this is an **upcast**), or a _subtype_ of _o_ (this is a **downcast**). ### Upcast _Explicit_ upcasts are uncommon, but may still be useful in some scenarios, e.g. to [disambiguate two method calls](https://stackoverflow.com/questions/5361999/whats-the-need-to-use-upcasting-in-java). _Implicit_ upcasts on the other hand are very frequent, when the type of an object cannot be determined at compile time. **_Example._** Consider the following classes: ![](/img/diagrams/plantuml/downcast_simple.svg) Now consider the following program, where the method `getUnits` produces an array of units that depends on the player's input. The type of objects in this array (`Unicorn` or `Butterfly`) cannot be determined at compile time. Thanks to the implicit upcast, they can nonetheless be treated as (underspecified) units. ```java Unit[] units = getUnits(); for (Unit unit: units){ System.out.println(unit.health); } ``` ### Downcast Downcasting in Java is frequent for objects whose type cannot be determined at compile time. However, this may not be safe. For instance, in the above example, downcasting a unit from `Unit` to `Unicorn` may cause a `ClassCastException` (at runtime), because this unit is a instance of `Butterfly`. This is why downcasting is often used in combination with the `instanceof` operator. For instance the above example can be modifed as follows: ```java Unit[] units = getUnits(); for (Unit unit: units){ if(unit instanceof Unicorn){ ((Unicorn) unit).regen(); } } ``` Here the operation `(Unicorn) unit` is a downcast. The output of this operation has type `Unicorn`, thus allowing the call to the method `regen`. ## Object equality {#equals} As we saw in a [previous chapter](http://localhost:44407/docs/objects/sections/classes/#constructor), a constructor in Java creates an object in memory and returns a (fresh) _reference_ to that object. Since two objects have different locations in memory, their respective references must differ, _even if the objects are identical_. **_Example._** Consider (a simplified version of) the class `City` that we saw [earlier](http://localhost:44407/docs/objects/sections/classes/). ```java public class City { String name; int zipCode; public City(String name, int zipCode){ this.name = name; this.zipCode = zipcode; } } ``` The following program will output `false`: ```java City city1 = new City(\"Florence\", 50100); City city2 = new City(\"Florence\", 50100); System.out.println(city1 == city2); ``` However, in some scenarios, it may be useful to compare the objects themselves, rather than their references. Java provides a native method called `equals` for this purpose. Like the method `toString` that we saw [earlier](http://localhost:44407/docs/objects/sections/tostring/), the `equals` is an instance method of the native Java class `Object`, which is an (implicit) superclass of every other class. So every (user-defined of native) class inherits `equals`. Here is the source code of `Object.equals`: ```java public boolean equals(Object obj) { return (this == obj); } ``` In other words, by default, this method behaves like the `==` operator. In order to use this method to check whether two objects are equal, it has to be [overriden](http://localhost:44407/docs/objects/sections/methods/#overriding). For instance, here is a prototypical implementation of the method `equals` within our class `City`: ```java @Override public boolean equals(Object o) { if (this == o) { // same reference return true; } if (o == null || getClass() != o.getClass()) return false; // o is null or has a different type } City downcastObject = (City) o; return zipCode == downcastObject.zipCode \u0026\u0026 name.equals(downcastObject.name); } ``` **_Hint._** Your IDE can generate such a method. Note in this example: - the (safe) downcast from `Object` to `City`, and - the recursive call to `equals` (because `String` is not a primitive type). ### Recursion {#recursion} **_Warning._** Similarly to what we saw with the method [toString](http://localhost:44407/docs/objects/sections/tostring/#recursion), beware of naive (recursive) implementations of `equals` if your program can create an object that refers to itself (directly or indirectly). ### Built-in implementations Several native Java classes have their own implementation of `equals`. We will encounter several of them during this course, notably for the class `String` and for the implementations of the interface `Set`. ### The method `hashCode` The method `equals` is usually overridden together with another method of the class `Object`, called `hashCode`. In particular, this is needed for the method `equals` of the class `HashSet` to behave correctly. We will explore this topic later in this course, when introducing the notion of hashmap. "},{"id":57,"href":"/docs/errors/","title":"Errors","section":"Docs","content":" # Errors We all make mistakes when writing code. Developing efficient strategies to identify mistakes is an essential part of programming. ## Compile time vs runtime errors In (pre)compiled languages (like Java, C/C++, C#, Python, Rust, Go, etc.), a distinction is generally made between **compile time errors** and **runtime errors**. - A compile time error prevents a program from compiling. It can be thought of as a syntactic error. - A runtime error (a.k.a. **bug**) occurs during the execution of a program. It may depend on the _input_ of the program. **_Hint._** Compile time errors tend to be (much) easier to fix than bugs, especially in large projects. Besides, an IDE can identify some compile time errors (and highlight them) before the program is even compiled. So it is often a good practice to write your code in such a way that a maximal number of errors can be identified _at compile time_. **_Note._** For interpreted languages (like Javascript, Lua, etc.), the term \"compile time error\" is meaningless. However, a distinction can still be made between errors that can be detected at runtime only, and errors that can be preemptively identified (e.g. highlighted by an IDE). ## Error messages A precise error message can significantly simplify debugging. As a toy example, consider the following Java program: ```java public class City { String name; int zipCode; public City(String name, int zipCode) { this.name = name; this.zipCode = zipCode; } } ``` ```java {linenos=true} public class MyClass{ void myMethod(City[] cities){ City firstCity = cities[0]; if(firstCity.zipCode \u003e= 20000) { System.out.println(firstCity.name.length()); } } } ``` Exercise In this program, there are several reasons why the method `MyClass.myMethod` may fail at runtime. Can you identify them? Solution - the input array may be null, - the input array may be empty, - the first city in this array may have a zip code $\\ge$ 20 000 and no name. In the above example, if we execute the following, ```java myMethod(null); ``` then we obtain this error message: ``` java.lang.NullPointerException: Cannot load from object array because \"cities\" is null at MyClass.myMethod(MyClass.java:5) ``` Note that this message provides a clear indication of: - the file (`MyClass.java`), method in this file (`MyClass.myMethod`) and line of code (5) that caused the error, - the type of error (`NullPointerException`), - the cause of the error (the variable `city` has value `null`). **_Hint._** A `NullPointerException` in Java often indicates an attempt to access an object (or array) via a pointer (e.g. a variable) whose value is `null`. Similarly, if the method is called with an empty array, ```java myMethod(new City[]{}); ``` we get the following error message: ``` java.lang.ArrayIndexOutOfBoundsException: Index 0 out of bounds for length 0 at MyClass.myMethod(MyClass.java:5) ``` Exercise Which type of error will the following call to `myMethod` produce? ```java myMethod(new City[]{ new City(30100, null) }); ``` Solution ``` java.lang.NullPointerException: Cannot invoke \"String.length()\" because \"firstCity.name\" is null at MyClass.myMethod(MyClass.java:7) ``` ## Invalid inputs Consider the following method: ```java int least(int x, int y){ return x \u003c= y ? x : y; } ``` Observe that: - any arguments for this method (i.e. any pair of integers in this example) are a valid input, - its execution only depends on its arguments, i.e. if the method is called twice with the same arguments, then it has the same behavior. However, this is not the case of all methods. If one of these two condition does not hold, then it may be useful to write _your own_ error messages, in anticipation. This may benefit: - users of the program, and - collaborators (including your future self!) who will maintain (debug, extend, etc.) the program. **_Example._** For instance, consider a method ```java boolean isSolvable (int[][] grid); ``` that takes as input a grid of sudoku, and returns `true` iff it is solvable, meaning that this grid admits a unique solution. A _valid input_ for this problem may be a 9 x 9 array of integers with values between `0` and `9` (where `0` indicate the absence of value). However, Java does not provide such a precise data type. The method could produce an (informative) error message if the input array: - is not `9 x 9`, or - contains a value `\u003c 0` or `\u003e 9`. ## Controlled environment Anticipating all types of invalid inputs (and producing error messages for these) may induce a lot of boilerplate code. If you have _control_ over the input a method, then this may not be necessary. In particular, this may be the case for some **auxiliary methods** (i.e. which are not [visible]() to other classes or components). **_Example (continued)._** Consider the method `boolean isSolvable (int[][] grid)` described above. Let us assume that it is [private](), and called only by a method `generateGrid` that generates a grid pseudo-randomly. It may be safe to assume that the implementation of `generateGrid` only produces `9 x 9` arrays with values between `0` and `9`. In this scenario, there is probably no need to implement error messages in `isSolvable`. "},{"id":58,"href":"/docs/env/sections/requirements/","title":"Requirements for this course","section":"Development environment","content":" # Requirements for this course For this course, you will need: - Git Version 2.2 or higher - A Java Development Kit (JDK) for Java 17 (e.g. openJDK) - Maven Version 3.6 or higher In addition, if you choose the board game as project, you will need: - Gradle Version 7.2 or higher Again, we recommend using a [package manager](http://localhost:44407/docs/env/sections/install/#packageManager) to install these programs if possible. **_For Windows users_**. Maven is not available on the winget repository. But you can find it on the Chocolatey repository, or follow [manual installation instructions](https://phoenixnap.com/kb/install-maven-windows). You will also need: - an [IDE]() - a [text editor]() (possibly your IDE) - a [terminal emulator]() (possibly your IDE) "},{"id":59,"href":"/docs/input/sections/serialize/","title":"Serialization","section":"I/O and serialization","content":" # Serialization **Serializing** an object (resp. data structure) means converting it into a form that can be stored or transmitted, and such that the object (resp. data structure) can be later reconstructed (a.k.a. **deserialized**). ## in Java Java provides a native mechanism to serialize an object (including information about the type of the object). The serialization format is _not_ (meant to be) human-readable. The process is _JVM independent_, meaning that an object can be serialized on one platform and deserialized on another. ### Transient In Java, an instance attribute can be marked with the keyword `transient` (a.k.a. \"volatile\"). For instance: ```java public class MyClass { String serializedAttribute; transient int transientAttribute; ... } ``` Transient attributes are _excluded_ from the serialization process (meaning that a serialized object contains no value for its transient attribute). **_Warning._** When an object is _deserialized_ (i.e. converted back to an object), [default values](https://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.12.5) are assigned to each of its transient attributes: `null` for a reference, `0` for an `int`, `false` for a `boolean`, etc. ### Serializable In Java: - a value with primitive type (e.g. `int`) is **serializable**, - an array is **serializable** if its elements are serializable, - an object is **serializable** if: - its class implements the interface `Serializable`, and - each of its attributes is serializable or marked as `transient`. **_Note._** Implementing the interface `Serializable` does not require implementing any method. **_Example._** Instances of the following class are not serializable, because `Country` does not implement `Serializable`. ```java public class Country { String name; public Country(String name) { this.name = name; } } ``` Instances of the following class are not serializable either, because the attribute `country` has type `Country`, which does not implement `Serializable`. ```java public class City implements Serializable { String name; int zipCode; Country country; public City(String name, int zipCode, Country country) { this.name = name; this.zipCode = zipCode; this.country = country; } } ``` However, if we replace ```java Country country; ``` with ```java transient Country country; ``` then instances of the class `City` become serializable, because: - the attribute `name` has type `String`, which implements `Serializable`, and - the attribute `zipCode` has a primitive type, and - the attribute `country` is now declared as transient. **_Note._** Most native implementations of the Java interfaces `Collection` (`ArrayList`, `LinkedList`, `HashSet`, `TreeSet`, etc.) and `Map` (`HashMap`, `TreeMap`, etc.) also implement `Serializable`. ## `serialVersionUID` If a class implements the interface `Serializable`, it is recommended to add a field: `private static final long serialVersionUID` (annotated with `@Serial`) and initialize it. For instance: ```java public class City implements Serializable { @Serial private static final long serialVersionUID = 0; ... } ``` The value is irrelevant, but is meant to be updated if the (instance) attributes of the class are modified. For an explanation, we refer to [this page](https://www.baeldung.com/java-serial-version-uid). ## Serialization (and deserialization) methods The class `ObjectOutputStream` allows serializing an object, with the method: ```java void writeObject(Object x) throws IOException ``` Similarly, the class `ObjectInputStream` allows deserializing an object (i.e. loading it back into memory), with the method: ```java Object readObject() throws IOException, ClassNotFoundException ``` **_Note._** The return type of `readObject` is `Object`, so the returned object needs to be cast to its appropriate data type. **_Example._** Let us continue with the example above (assuming that the attribute `City.country` is marked as `transient`). A instance of `City` can be serialized to a file as follows: ```java String path = \"path/to/file.ser\"; Country italy = new Country(\"Italy\"); City bologna = new City(\"Bologna\", 40100, italy); try (ObjectOutputStream out = new ObjectOutputStream(new FileOutputStream(path))) { out.writeObject(bologna); } catch (IOException e) { throw new RuntimeException(e); } ``` And deserialized as follows: ```java City deserializedBologna; try (ObjectInputStream in = new ObjectInputStream(new FileInputStream(path))) { deserializedBologna = (City) in.readObject(); } catch (IOException | ClassNotFoundException e ) { throw new RuntimeException(e); } // Ouputs 'Deserialized city: { name: Bologna, zipCode: 40100, country: null }' System.out.printf( \"Deserialized city: { name: %s, zipCode: %d, country: %s }\", deserializedBologna.name, deserializedBologna.zipCode, deserializedBologna.country ); ``` Observe that the attribute `country` after deserialization has value `null` (because it is marked as `transient`). "},{"id":60,"href":"/docs/git/sections/branches/","title":"Branches","section":"git","content":" # Branches ## Listing branches The command ```bash git branch ``` allows you to list all local branches (for the current repository). ## Creating a branch To create a new branch, run ```bash git branch ``` Then you can switch to this branch with ```bash git checkout ``` Alternatively, you can perform both operations with a single command: ```bash git checkout -b ``` ## Deleting a branch You can delete a (local) branch _other than the current branch_ with ```bash git branch -d ``` ## Merging a branch To merge a branch `` into a branch ``, switch first to the receiving branch: ```bash git checkout ``` Then run ```bash git merge ``` If possible, a fast-forward merge will be performed. Otherwise a regular merge will be attempted. If this cannot be done (due to merge conflicts), then you will be asked to fix the merge conflicts. After fixing the conflicts, you can finalize the merge with ```bash git commit ``` "},{"id":61,"href":"/docs/objects/sections/classesasobjects/","title":"Classes as objects","section":"Objects and classes","content":" # Classes as objects Some object-oriented languages (like Java, C# or C++) provide ways to access or manipulate classes (almost) as if they were objects. ## Static attributes and methods ### Static attributes {#staticAttributes} Java (as well as C# and C++) supports attributes that do not depend on a specific object, but on a _class_ instead. These are often called **static attributes** (or sometimes **class attributes** or **class variables**), as opposed to the attributes that we have seen so far, called **instance attributes** (or **member variables**). Static attributes are marked with the keyword `static`. **_Example._** Consider a version of our game where characteristics for each unit type (e.g. default health, etc.) can be declared manually, in a text file. The path to this file could be stored as a static attribute, as follows: ```java public class Unicorn { static String configFile = \"units/unicorn.txt\"; int health; public Unicorn(){ health = getHealthFromConfigFile(configFile); } public regen(){ health++; } } ``` Each instance of `Unicorn` carries its own value for the attribute `health`. But the value of `configFile` is _unique_. For instance, the following program creates in memory a _unique_ string for `configFile`, which is carried by the class. ```java Unicorn u1 = new Unicorn(); Unicorn u2 = new Unicorn(); ``` ### Static methods Similarly to a static attribute, a **static method** does not depend on a specific object, as opposed to an [instance method](http://localhost:44407/docs/objects/sections/methods/). **_Example_** (continued). We can add to our class `Unicorn` a static method that checks whether the configuration file exists: ```java public class Unicorn{ ... static boolean configFileExists() { return Files.exists(Paths.get(configFile)); } } ``` (note that the method `getHealthFromConfigFile` also may also be static, if its execution is identical for all instances of `Unicorn`). Remember that an instance method can be called outside of the class where it is declared, using an instance of the class followed by `.`: ```java Unicorn myUnicorn = new Unicorn(); myUnicorn.regen(); ``` A static method can (syntactically) be called in the same way, for instance: ```java Unicorn myUnicorn = new Unicorn(); boolean valid = myUnicorn.configFileExists(); ``` However, this is often _discouraged_, because this syntax can be misleading (in this example, `configFileExists` can be mistaken for an instance method). Alternatively, since the method depends on the class (rather than an instance), the call can be prefixed with the class name. This syntax is often _preferred_, because it leaves no ambiguity. For instance: ```java boolean valid = Unicorn.configFileExists(); ``` Note that there may be several instances of a same class in memory during the execution of a program, or no instance at all. This is why a static method _cannot_ reference an instance method or attribute. For instance, adding the following static method to our class would cause a compilation error, because `health` is an instance attribute. ```java public class Unicorn { static void reduceHealth(){ health--; } } ``` ### Inheritance Two static methods with the same name and signature can be declared in a class and a superclass. In Java's terminology, this is _not_ called [method overriding](http://localhost:44407/docs/objects/sections/methods/#overriding), but instead **method hiding**. An important difference is that [dynamic dispatch](http://localhost:44407/docs/objects/sections/methods/#dispatch) (a.k.a. runtime polymorphism) does _not_ apply to this case (the method to be called is determined at compile time, rather than run time). **_Example_** (continued). Let us extend our example with a subclass of Unicorn that **hides** the static method `configFileExists`. ```java public class EvilUnicorn extends Unicorn { static boolean configFileExists(){ return false; } } ``` Now consider the following program, where the method `getUnicorns` produces an array of unicorns that depend on the player's input. The specific type of objects in this array (`Unicorn` or `EvilUnicorn`) cannot be determined at compile time. ```java Unicorn[] unicorns = getUnicorns(); for (Unicorn unicorn: unicorns){ System.out.println(unicorn.configFileExists()); } } ``` In this example, the method of the superclass (i.e. `Unicorn.configFileExists`) will be executed for each object in the array, regardless of its type. This is another reason why calling a static method via an instance (rather than via a class name) is often discouraged. In this example, writing `Unicorn.configFileExists()` would make it clear that this loop serves no purpose (the same method is executed `unicorns.length` times). ## Reflection Java (as well as C#) offers a mechanism called **reflection** to intuitively treat classes analogously to objects. Precisely, each class of a program (e.g. the class `Unicorn`) is associated with an object that represents it. This object is itself an instance of the Java class called `Class`. It can be accessed either: - via an instance of the class: ```java Unicorn myUnicorn = new Unicorn(); Class unicornClass = myUnicorn.getClass(); ``` - or via the qualified name of the class (assuming for instance that the file `Unicorn.java` is in the folder `/src/main/java/org/units`): ```java Class unicornClass = Class.forName(\"org.units.Unicorn\"); ``` The instance methods of the class `Class` are listed [here](https://docs.oracle.com/javase/8/docs/api/java/lang/Class.html). Among others, they allow: - listing the attributes of the class, - retrieving its immediate superclass, or the interfaces that it implements, - creating a new instance of this class, - etc. Reflection is a powerful feature. It is rarely used in everyday code, but can be helpful in specific situations. Notably, it is used (internally) by numerous [Java frameworks](https://en.wikipedia.org/wiki/List_of_Java_frameworks) such as Spring, Jackson or JUnit. "},{"id":62,"href":"/docs/env/sections/ide/","title":"IDE","section":"Development environment","content":" # Integrated development environment (IDE) An IDE is an application that consists of a source code editor with additional functionalities such as a debugger or build automation. For this course, you can use any IDE (or enhanced code editor) for Java with at least the following features: - a debugger - navigation to variable/class/interface declaration and usage, - variable/class/interface renaming, - Maven integration, - Gradle integration if you choose the board game as your project. We give a brief overview of the most popular choices (for Java). ## Eclipse, Netbeans and Intellij IDEA All three of these editors have similar functionalities, and any of these three can be used for this course. All three were designed with Java in mind, and thus offer advanced integration with a variety of Java frameworks. Each of them also supports other programming languages, but the list varies from one editor to the other. As of today, Intellij IDEA (IntelliJ for short) is probably the most popular Java-centric editor. This is a **closed-source** project, thus offering more limited customization than the other two. Eclipse is an open-source project with a large ecosystem. It is known for its community support and its advanced plugin system, which led to the development of a variety of extensions over the years (including support for C/C++, Python, etc.). Note that for performance reasons, Eclipse comes with its own Java Virtual Machine (JVM), which in some (rare) cases may not behave like other JVMs. Netbeans is also an open-source project. Notably, Netbeans provides a graphical tool to design Graphical User Interfaces (GUIs) for the Java Swing framework. However, we do _not_ recommended using it for an _advanced_ GUI (multiple windows, etc.), because the generated code can be very difficult to maintain or debug. ## Visual Studio Code (VSCode) **_Warning_**. VSCode and Visual Studio are two _independent programs_, and serve different purposes. In particular, Visual Studio does _not_ support Java (anymore). **_Note._** VSCode is often categorized as a code editor rather than an IDE. For this course, VSCode (together with some plugins) can serve as a Java IDE, so we will refer to it as an IDE for simplicity. VSCode is a (mostly) open-source project developed by Microsoft. Precisely, _Code-OSS_ is a (fully) open source editor, and VSCode is a distribution of Code-OSS with additional features. VSCode has probably become the most popular code editor among developers. For instance, VSCode is used by 74% of respondents of the 2023 StackOverflow developer survey. The success of VSCode is often explained by its rich repository of (community-developed) plugins. This may in turn be explained by the fact that VScode is based on Electron, and thus allows writing plugins in Javascript. Note that VSCode was not developed as a Java code editor, but as a general-purpose editor with a focus on web development (Node.js/Javascript). However, VSCode can serve as a Java IDE (at least to some extent) thanks to some plugins. For this course, you may use the [extension pack for Java](https://marketplace.visualstudio.com/items?itemName=vscjava.vscode-java-pack). If you choose the board game as your project, you may also need a plugin for Gradle, such as [this one](https://marketplace.visualstudio.com/items?itemName=vscjava.vscode-gradle). In some cases, using VSCode may require a little bit more configuration than a Java-centric IDE. "},{"id":63,"href":"/docs/errors/sections/errors/","title":"Java errors","section":"Errors","content":" # Java errors Aside from exceptions, a Java program can throw a so-called `Error`. According to the Javadoc for the class `Error`: \u003e An Error [...] indicates serious problems that a reasonable application should not try to catch. Most such errors are abnormal conditions. For instance, some subclasses or `Error` are `OutOfMemoryError` and `StackOverflowError`. "},{"id":64,"href":"/docs/recursion/","title":"Recursion","section":"Docs","content":" # Recursion ## Warmup {#printFiles} Exercise In this exercise, we assume that a folder can only contain files or other folders. Write (in pseudocode) a method `void printFiles(String folder)` that: - takes as input a path to an (existing) folder, and - prints a path to each file contained recursively in this folder (in any order). For instance, in the following example, ```bash └── foo ├── fred.txt └── bar ├── thud.txt └── waldo.txt ``` `printFiles(\"foo\")` could print: - foo/fred.txt - foo/bar/thud.txt - foo/bar/waldo.txt `printFiles(\"foo/bar\")` could print: - foo/bar/thud.txt - foo/bar/waldo.txt You can assume that the following methods are available: - `void print(String string)` prints the input string, - `boolean isFile(String path)` returns true iff `path` is a path to a file, - `Set content(String path)` takes a path to a folder, and returns a path to each file or folder that it contains (non-recursively). E.g. `content(\"foo\")` returns `{ \"foo/fred.txt\", \"foo/bar\" }`. Possible solution ```java void printFiles(String folder){ foreach child in content(folder){ if(isFile(child)){ print(child) } else { printFiles(child) } } } ``` ## Recursive method **_Definition._** A method is **recursive** if it calls itself, directly or indirectly. For instance (in pseudocode): - the following method is recursive: ```perl myMethod() { ... myMethod() ... } ``` - the following two methods are recursive: ```perl myMethod1() { ... myMethod2() ... } myMethod2() { ... myMethod1() ... } ``` ## Usage {#methodology} In theory, a recursive algorithm can be rewritten using loops only (and conversely). However, in practice, some problems are easier to _solve_ recursively. In particular, this is the case of many problem that involve tree-like structures (e.g. a folder, a JSON or XML document, an algebraic expression, etc.), and more generally graphs. The following methodology can be used to solve a variety of problems: **_Methodology._** To solve a problem recursively: - **_(Base case)._** If the input $I$ is minimal (e.g. of size 0 or size 1), then solve the problem directly. - **_(Inductive case)._** Otherwise: 1. Decompose $I$ into _smaller_ inputs $I_1$, .., $I_k$. 2. Solve the problem (recursively) for $I_1$, .., $I_k$. 3. Combine the results (if needed). In other words, in the inductive case, solve the problem for $I$ _under the assumption_ that it can be solved for $I_1$, .., $I_k$. ### Example: binary trees {#binaryTrees} **_Definition._** An **ordered tree** is a tree where the children of each node are totally ordered. **_Definition._** A **binary tree** is an ordered tree where each node has exactly two (possibly null) children. **_Example._** This is a binary tree: ![](/img/binaryTrees/unlabeled/generic/tree.svg) Exercise Let us represent a node in a binary tree as an instance of the following class: ![](/img/diagrams/plantuml/nodeWithIntLabel.svg) Write (in pseudocode) a method `int sum(Node root)` that takes as input the root of a binary tree, and returns the sum of all values in the tree. For instance, for the following tree, the method should return 13: ![](/img/binaryTrees/labeled/int/tree.svg) Possible solution ```java int sum(Node root){ // base case if (root == null){ return 0 } // inductive case return root.value + sum(root.leftChild) + sum(root.rightChild) } ``` Exercise Let us represent a binary tree as above, but where nodes have no label: ![](/img/diagrams/plantuml/node.svg) Write (in pseudocode) a method `int height(Node root)` that takes as input the root of such a tree, and returns the number of nodes in the longest branch of this tree. For instance, for the following tree, the method should return 4: ![](/img/binaryTrees/unlabeled/height/tree.svg) Possible solution ```java int height(Node root){ //base case if (root == null){ return 0 } // inductive case return 1 + max( height(root.leftChild), height(root.rightChild) ) } ``` ### Processing order Exercise Let us represent a binary tree as above, but where nodes are labeled with a character. ![](/img/diagrams/plantuml/nodeWithChar.svg) Consider the following recursive algorithm: ```java {linenos=true} traverse(Node root){ // inductive case only (do nothing in the base case) if (root != null){ print(root.label) traverse(root.leftChild) traverse(root.rightChild) } } ``` What does this algorithm print for the following input tree? ![](/img/binaryTrees/labeled/char/tree.svg) Solution A B D H E I J C F K L G M Exercise What about the following algorithm (for the same tree)? ```java {linenos=true} traverse(Node root){ // inductive case only (do nothing in the base case) if (root != null){ traverse(root.leftChild) print(root.label) traverse(root.rightChild) } } ``` Solution D H B I E J A K F L C G M Exercise And this algorithm? ```java {linenos=true} traverse(Node root){ // inductive case only (do nothing in the base case) if (root != null){ traverse(root.leftChild) traverse(root.rightChild) print(root.label) } } ``` Solution H D I J E B A K L F M G C **_Definition._** In the above exercises, the three node processing orders are respectively called **pre-order traversal**, **in-order traversal** and **post-order traversal**. These three algorithms can be adapted to solve a variety of problems. **_Hint._** In-order traversal processes nodes in left-to-right order (when projected to a line). Exercise Let us consider once again a binary tree where nodes are labeled with a character. ![](/img/diagrams/plantuml/nodeWithChar.svg) Write (in pseudocode) a method `Node leftMost(Node root, char label)` that returns the leftmost node labeled with `label` in the tree rooted in `root` (or `null` if there is no such node). Possible solution We can adapt the in-order traversal algorithm (above), as follows: ```java Node leftMost(Node root, char label){ // Base case. if(root == null){ return null } // Inductive case. // Explore the left subtree first. Node candidate = leftMost(root.leftChild, label) // If the call succeeded, then we found the leftmost occurrence in the tree. if(candidate != null){ return candidate } // Otherwise the next candidate (from left to right) is the current node. if (root.label == label) { return root } // If both attempts failed, then explore the right subtree. return leftMost(root.rightChild, label) } ``` ## Syntax A recursive method often has the following structure (in pseudocode): ```java myMethod(Type input) { // base case if() { ... // inductive case } else { ... myMethod(smallerInput_1) ... myMethod(smallerInput_2) ... ... myMethod(smallerInput_k) ... } } ``` **_Observation._** Termination is guaranteed if the input of each recursive call is strictly _smaller_ than the current input. Besides, a recursive method is often an _auxiliary method_. For instance, some problems with an array as input can be solved recursively by dividing the array in sub-segments, as follows (in pseudocode): ```java solveProblem(Type[] array) { if(array.length != 0){ // the initial segment is the whole array solveProblemRec(array, 0, array.length - 1) } } solveProblemRec(Type[] array, int startIndex, int endIndex) // base case (segment of length 1) if(startIndex == endIndex) { ... // inductive case } else { // middle index (rounded down) int middleIndex = (startIndex + endIndex) / 2 ... // recursive call on the left subsegment solveProblemRec(array, startIndex, middleIndex) ... // recursive call on the right subsegment solveProblemRec(array, middleIndex + 1, endIndex) ... } } ``` It is also frequent for a recursive method to return _multiple_ values. For instance, in a binary tree, return the set of labels that appear in a tree as well as the number of nodes. In Java 14 or later, this can be easily achieved by returning a [record](http://localhost:44407/docs/objects/sections/quasi-objects/#record). For instance: ```java record Result(Set labels, int numberOfNodes){}; Result myMethod(Node root) { // base case if(root == null) { return new Result(new HashSet\u003c\u003e(), 0); // inductive case } else { // recursive calls Result leftResult = myMethod(root.leftchild); Result rightResult = myMethod(root.rightchild); // build the union of all labels Set allLabels = leftResult.labels; allLabels.addAll(rightResult.labels); allLabels.add(root.label); return new Result( allLabels, leftResult.numberOfNodes + rightResult.numberOfNodes + 1 ); } } ``` "},{"id":65,"href":"/docs/git/sections/sharing/","title":"Synchronization: remote, push, pull","section":"git","content":" # Synchronization: remote, push, pull ## List remotes To list the remote(s) associated to your repository (name and address of each remote), you can run ```bash git remote -v ``` ## Upload {#push} If the current branch is already shared with a remote, you can upload it with ```bash git push ``` Otherwise, you can share this branch (and its commits) with ```bash git push -u ``` To delete a _remote_ branch, run ```bash git push -d ``` Alternatively, you can delete a remote branch using the web interface of your hosting service. ## Download If your current branch is shared with your remote, you can update your local copy with ```bash git pull ``` **_Warning._** When pulling, git will try to perform a fast-forward merge of the remote branch into your local copy. If you follow the [basic workflow](http://localhost:44407/docs/git/sections/collaboration/#workflow) presented earlier, then this fast-forward merge should succeed. If it does not, then git will suggest you a command to perform a classical merge instead. "},{"id":66,"href":"/docs/git/sections/backtracking/","title":"Backtracking","section":"git","content":" # Backtracking We already saw how a file can be unstaged (with `git reset`) _before it is committed_. If the file was committed by mistake, then there are at least three scenarios. ## Reset If the commits that contain the file have _not_ been shared yet with a remote, then these commits can be cancelled locally. The command ```bash git reset ``` moves the pointer for the current branch \"back in time\" to the commit ``. This has the effect of deleting all posterior commits. ## Revert If the commits that contain the file have been shared with a remote, then `git revert` is often recommended by default. This command does not affect the history of a branch (as opposed to `git reset`). Instead, if adds a commit to the history that reverts the _k_ last commits on the current branch. For instance ```bash git revert HEAD ``` adds a commit that reverts the latest one. And ```bash git revert HEAD~3.. ``` adds a commit that reverts the 3 latest ones. ## Rewriting history In some (rare) scenarios, one may need to rewrite the history of a branch that has already been shared. For instance, sensitive information (passwords, etc.) or a large dataset may have been committed by mistake. [Dedicated tools](https://docs.github.com/en/authentication/keeping-your-account-and-data-secure/removing-sensitive-data-from-a-repository) may be used in such scenarios. "},{"id":67,"href":"/docs/objects/sections/clone/","title":"Duplicating objects","section":"Objects and classes","content":" # Duplicating objects In some scenarios, it may be useful to duplicate an object. In Java, as we saw earlier, copying the value of a variable with reference type does _not_ copy the object that it references. For instance, the following program outputs \"yellow\": ```java Unicorn unicorn = new Unicorn(\"green\"); Unicorn shallowCopy = unicorn; unicorn.color = \"yellow\"; System.out.println(shallowCopy.color); ``` The need to duplicate objects may notably appear in a program that rely on _concurrency_. Exercise In our game, the \"view\" component is in charge of rendering the game visually. This component exposes a method called `drawSnapshot` that takes as input a [game snapshot](http://localhost:44407/docs/interfaces/sections/java_interfaces/#snapshotExample) and draws this snapshot on screen. The backend calls this method whenever a snapshot must be drawn. However, the backend may send these snapshots _faster_ than they can be displayed (due to the duration of on-screen animations). To deal with this scenario, the \"view\" **buffers** the snapshots that it receives (displaying a new snapshot only after all previously submitted ones have been displayed). For the sake of this exercise, you can think of this buffer as an array with type `Snapshot[]`. Now consider the following method `deleteUnit(int x, int y)`, executed by our backend each time it receives the instruction to delete a unit: ```java public class Backend implements EventHandler { Snapshot currentSnapshot; ... public void deleteUnit(int x, int y){ if(\u003c\"there is a unit on the tile x, y\"\u003e){ removeUnitFromTile(x, y); drawSnapshot(currentSnapshot); shiftUnitsInColumn(x); drawSnapshot(currentSnapshot); performUnitMerges(); drawSnapshot(currentSnapshot); ... } } } ``` where the auxiliary methods `removeUnitFromTile`, `shiftUnitsInColumn` and `performUnitMerges` may modify the object `currentSnapshot`. Observe that the method `deleteUnit` calls `drawSnapshot` three times. Now let us assume that the buffer of the \"view\" is nonempty when this method is executed, so that the 3 snapshots are added to the buffer, before any of them can be rendered on screen. How many of these 3 snapshots will be drawn on screen? Solution Only the third snapshot will be drawn (three times), because the buffer contains three references to the same object. ## Shallow, deep and hybrid copy Copying a _reference_ to an object can be viewed as the shallowest possible form of copy. As we saw [already](http://localhost:44407/docs/objects/sections/classes/#javaByValue), this is what happens in Java when a variable with reference type is passed as argument. At the other end of the spectrum is a so-called **deep copy**, where all attributes of the copied object are duplicated, _recursively_. In this case, the copy or any object that it references (recursively) can be modified without affecting their original counterparts. Between these two extremes: - a **shallow copy** creates a new object (with fresh attributes), but does not copy referenced objects recursively, - a **hybrid copy** is anything between a shallow copy and a deep copy. ## in Java ### Copy constructor A copy can be performed in Java with a so-called **copy constructor**. This is an additional constructor that takes an instance of the class as input, and returns a copy of this instance. For example: ```java public class Hero { int health; // standard constructor public Hero(){ this.health = 10; } // copy constructor public Hero(Hero original){ this.health = original.health; } } ``` In order to perform a deep(er) copy, a copy constructor may call another copy constructor. For example: ```java public class Snapshot { Hero firstHero; Hero secondHero; Board board; int remainingActions; // standard constructor public Snapshot(Hero firstHero, Hero secondHero, Board board, int remainingActions){ // some code here ... } // copy constructor public Snapshot(Snapshot original){ this.firstHero = new Hero(original.firstHero); this.secondHero = new Hero(original.secondHero); this.board = new Board(original.board); this.remainingActions = original.remainingActions; } } ``` **_Warning._** Similarly to what we saw with the methods [toString](http://localhost:44407/docs/objects/sections/tostring/#recursion) or [equals](http://localhost:44407/docs/objects/sections/comparing/#recursion), beware of recursive implementations of copy constructors, if your program can create an object that refers to itself (directly or indirectly). ### The method `clone` Java also provides a native method called [clone]() to duplicate objects. Like the methods [toString](http://localhost:44407/docs/objects/sections/tostring/) and [equals](http://localhost:44407/docs/objects/sections/comparing/) that we saw earlier, `clone` is an instance method of the native Java class `Object`, which is an (implicit) superclass of every other class. Overriding `clone` can be more concise than using a copy constructor (especially for a class with a large number of attributes). **_Warning._** Overriding `clone` can be _error-prone_, especially in presence of a class hierarchy (see [Effective Java](http://localhost:44407/docs/intro/sections/bibliography/#effectiveJava), Item 13 for further insight). Notably, the overriding class must implement the `Cloneable` interface, and an implementation of `clone` usually calls `super.clone` recursively (even for a class whose only superclass is `Object`). For these reasons, overriding `clone` is sometimes discouraged, in favor of conceptually simpler solutions (like copy constructors). "},{"id":68,"href":"/docs/input/sections/json/","title":"JSON Serialization","section":"I/O and serialization","content":" # JSON serialization A number of (external) libraries allow transforming Java objects into JSON objects and conversely. For instance [Jackson](https://github.com/FasterXML/jackson-databind), [Gson](https://github.com/google/gson), [JSON-java](https://github.com/stleary/JSON-java), [JSON-B](https://javaee.github.io/jsonb-spec/) and [JSON-P](https://javaee.github.io/jsonp/). In this section, we focus on Jackson. **_Note._** Jackson was initially designed for JSON, but extensions of Jackson allow manipulating [other formats](https://github.com/FasterXML/jackson-dataformats-text/tree/2.18): XML, TOML, YAML, CSV and Java property files. ## Install Jackson can be used within a Maven project, by declaring the following [dependency](http://localhost:44407/docs/build/sections/dependencies/) ```xml com.fasterxml.jackson.core jackson-databind 2.17.0 ``` And similarly for Gradle: ```groovy implementation group: 'com.fasterxml.jackson.core', name: 'jackson-databind', version: 2.17.0 ``` For the latest version, search [Maven Central](https://mvnrepository.com/artifact/com.fasterxml.jackson.core/jackson-databind). Installing this dependency will transitively install: - [jackson-annotations](https://github.com/FasterXML/jackson-annotations) - [jackson-core](https://github.com/FasterXML/jackson-core) ## Basic syntax Many tutorials can be found online about Jackson: for instance [Jackson in N minutes](https://github.com/FasterXML/jackson-databind/) on the GitHub page of the `jackson-databind` library. We focus here on some simple features of the library. An `ObjectMapper` can be used to map a Java object (or array or value) to some JSON string, and conversely. ```java ObjectMapper mapper = new ObjectMapper(); // Indent the output JSON strings when applicable mapper.enable(SerializationFeature.INDENT_OUTPUT); ``` ### Convert a value #### Serialize ```java // Outputs 15 System.out.println(mapper.writeValueAsString(15)); // Outputs \"abcd\" System.out.println(mapper.writeValueAsString(\"abcd\")); ``` #### Deserialize ### Convert an array or collection #### Serialize ```java // Outputs [2,3] System.out.println(mapper.writeValueAsString(new int[]{2, 3})); // Outputs either [2,3] or [3,2] System.out.println(mapper.writeValueAsString(Set.of(2, 3))); Map studentToAge = Map.of( \"Alice\", 20, \"Bob\", 19 ); /* Outputs { \"Alice\" : 20, \"Bob\" : 19 } */ System.out.println(mapper.writeValueAsString(studentToAge)); Map"},{"id":69,"href":"/docs/env/sections/text_editor/","title":"Text editor","section":"Development environment","content":" # Text editor A text editor allows you to edit plain (i.e. non-formatted) text. A text editor can open any file produced with a text editor (and more), _regardless of the file's extension_. In this sense, Microsoft Word is _not_ a text editor (neither are Apple Pages or LibreOffice Writer). Most operating systems comes with one or several text editor(s) pre-installed, such as Notepad++ (Windows), TextEdit (macOS), gedit (default Ubuntu), etc. ## Usage Your IDE is an (enhanced) text editor, so you can use it as such. But it some scenarios, it can be useful to use a lighter program, for instance for: - editing the configuration file of a program, - modifying a small script (or even a single command-line instruction) copy-pasted from the web, - etc. Among other reasons: - opening an IDE can take time, - if your IDE has autosave enabled, you may accidentally add unrelated files to your current project, - etc. ## Advanced text editors For most purposes, a basic text editor should be sufficient. But depending on your workflow, you may want to try a more advanced one. ### VSCode We already introduced VSCode in the section dedicated to [IDEs](). ### vi and emacs We also bring to your attention two _keyboard-centric_ editors called _vi_ and _emacs_. Both were developed in the 70's (before the mouse became a widespread peripheral) but are still commonly used today (in some form) by developers. We do _not_ recommend learning vi or emacs at this (early) stage of your studies, because it often requires time, and you arguably have more fundamental thing to learn. But you may give them a try at some point of your career, because they may significantly improve your productivity. #### vi/vim/neovim _vi_ was initially released 1978, as part of the first BSD distribution. The original program is rarely used today, but _vim_ (for \"vi improved\"), released in 1991, and neovim, released in 2015 are still popular among developers. For instance, 22% (resp. 12%, non-exclusive) of respondents to the 2023 Stack Overflow developer survey use vim (resp. neovim) as a code editor. vi/vim/neovim is a so-called _modal_ editor, meaning that users can switch between different modes. In one mode, pressing a standard key inserts the corresponding character on screen, whereas in another mode, pressing the same key has a different functionality (navigation, copy, paste, etc.). These functionalities are referred to as _vi keybindings_ or _vi motions_, and allow performing a variety of text editing operations in an efficient way. vi keybindings are commonly used in applications other than vi/vim/neovim, with dedicated plugins. For instance, most code editors/IDEs (VSCode, IntelliJ IDEA, emacs, etc.), terminal emulators or even web browsers have plugins for vi keybindings. **_Note._** Vim and neovim are very customizable, with comprehensive collections of (community-developed) plugins, which allows using them as IDEs. We do _not_ recommend trying this at this stage of your studies, because configuration may require a very significant time investment (significantly more than VSCode for instance). The original vi still comes pre-installed on many operating systems (Windows, macOS, Linux, ...), and may be the default text editor opened by terminal-based applications (e.g. git) on your system. If this is the case (and if you do not know the vi keybindings), we recommend _changing_ this setting. #### Emacs Emacs was initially written in 1976. The most popular version is GNU Emacs, released in 91, was notably co-developed by Richard Stallman. Emacs is partly responsible for popularizing (sequences of) combinations of keys (e.g. `Ctrl+`), as opposed to modal editors like vi. GNU Emacs has more than 10 000 built-in commands, and also provides a (limited) mouse interface. 5% of respondents to the 2023 Stack Overflow developer survey use emacs as a code editor. Emacs is also very customizable, with a comprehensive collections of (community-developed) plugins (probably more comprehensive than vim), and dedicated software repositories. Notably, Emacs tends to serve as a unique user interface for a variety of tasks (code editing, terminal emulation, email management, web browsing, playing music/videos, etc.). **_Note._** Emacs can be used as an IDE, but for the same reason as for vim or neovim, we do _not_ recommend trying this at this stage of your studies. "},{"id":70,"href":"/docs/env/sections/eval/","title":"Evaluation environment","section":"Development environment","content":"\n## Evaluation environment\n\nThe evaluation environment for your project is a virtual machine (with Ubuntu 20) deployed on Microsoft Azure.\nYou are not supposed to develop on this machine, but your project must run in this environment to be evaluated.\n\nEach student gets his or her own _clone_ of the original machine.\nMaven, Gradle, git and a Java 17 JDK are already installed.\nYou will also be granted administrator rights, so that you can install additional software (if any) needed to run your project.\n\nYou can log in to this machine via ssh (using a terminal), or via RDP (using an RDP client).\n\nHere is a (non-exhaustive) list of RDP clients:\n\n- Windows:\n\n  - [Windows Remote Desktop](https://4it.com.au/kb/article/how-to-start-remote-desktop-rdp-from-the-command-prompt/) (built in), also called MSTSC\n  - [Royal TS](https://www.royalapps.com/ts/win/features)\n\n- macOS:\n\n  - [Microsoft Remote Desktop](https://apps.apple.com/it/app/microsoft-remote-desktop/id1295203466?mt=12)\n  - [Royal TS](https://www.royalapps.com/ts/win/features)\n\n- Linux:\n  - [Remmina](https://remmina.org/)\n  - [rdesktop](https://www.rdesktop.org/)\n\nThe registration link is shared on the [Microsoft Team](https://teams.microsoft.com/l/team/19%3a5nIIq-TkfyJLi3capYBYZG42U0vNmUBTv31Ac7Gqf641%40thread.tacv2/conversations?groupId=b394eaa9-e55c-42ed-be0f-5be013ff2f03\u0026tenantId=92513267-03e3-401a-80d4-c58ed6674e3b) for this course.\nAfter logging in (with your Unibz credentials), you should see the following:\n\n![](/img/env/vm_start.png)\n\nToggling the button (bottom-left) will start your own clone of the virtual machine (this may take a few minutes).\n\nOnce your machine is running, click on the 3 dots (bottom right) and select \"show RDP information\".\nThis will give you the string (host name and port) needed by your RDP client to connect to the machine.\n\nThe credentials for logging in to the machine are also shared on the [Microsoft Team](https://teams.microsoft.com/l/team/19%3a5nIIq-TkfyJLi3capYBYZG42U0vNmUBTv31Ac7Gqf641%40thread.tacv2/conversations?groupId=b394eaa9-e55c-42ed-be0f-5be013ff2f03\u0026tenantId=92513267-03e3-401a-80d4-c58ed6674e3b) for this course.\n\nOnce connected:\n\n- you can select a keyboard layout (English, German or Italian) from the drop-down menu at the top right of the screen,\n\n  ![](/img/env/keyboard_layouts_vm.png)\n\n- you can use the super key (a.k.a. \"Windows key\") or click on \"Activities\" (top left) to display the application menu below.\n  To **launch a terminal**, click on the terminal icon in this menu or press Ctrl + Alt + t.\n\n  ![](/img/env/apps_vm.png)\n"},{"id":71,"href":"/docs/objects/sections/quasi-objects/","title":"Quasi-objects","section":"Objects and classes","content":" # Quasi-objects ## Enumerated types Most imperative languages allow the creation of so-called **enumerated types**. An enumerated type is a datatype for a finite set or enumerated values. For instance, if our game only allows \"blue\", \"green\" and \"red\" as unit colors, then we may create a dedicated type that only allows these three values. ### In Java An enumerated type in Java is a set of constants. These constants are effectively [static](http://localhost:44407/docs/objects/sections/classesasobjects/#staticAttributes), meaning that they depends on the class or interface where the enumerated type is declared (similarly to a [static attribute](http://localhost:44407/docs/objects/sections/classesasobjects/#staticAttributes)). The _name_ of an enumerated type can generally be used like a regular reference type. For instance ```java public class Unit { enum UnitColor {BLUE, GREEN, RED} int health; UnitColor color; public Unit(int health, UnitColor color){ this.health = health; this.color = color; } ... } ``` **_Note._** In the above example, the enumerated type `UnitColor` could equivalently be represented with an integer. For instance, `0` for blue, `1` for green and `2` for red. However, with such an encoding, a conditional statement (e.g. `if` or `switch`) that checks the color of a unit would also need to handle the case of values `\u003c 0` or `\u003e 2`. So (besides readability), a benefit of the enumerated type in this case is that it restricts possible inputs to _valid_ ones. **_Hint._** Enumerated types in Java are significantly more expressive than their counterparts in some other languages. Notably, a Java `enum` can have its own [constructor and methods](https://docs.oracle.com/javase/tutorial/java/javaOO/enum.html). ## Records {#record} A **record** is an _immutable_ object (meaning that it cannot be modified). ### in Java Records were introduced in Java 14 (2020). They are a convenient way to avoid boilerplate code. Records provide a concise syntax for \"lightweight\" classes that are only meant to hold data. For instance, here is the full implementation of a record `City`: ```java public record City(String name, int zipCode) {} ``` This record has an implicit constructor, and implements `equals`, `hashcode` and `toString` in the expected way. For instance: ```java City florence = new City(\"Florence\", 50100); City florenceAgain = new City(\"Florence\", 50100); // Outputs true. System.out.println(florence.equals(florenceAgain)); ``` The attributes of a record _cannot_ be modified. For instance, the following program does not compile: ```java City florence = new City(\"Florence\", 50100); florence.zipCode = 50121; ``` A record is often declared inside a class or interface. For instance, in our game: ```java public class Board { public record TileCoordinates(int X, int Y){}; ... } ``` Records are convenient for methods that need to return more than one value. For instance: ```java TileCoordinates getOngoingMove(); ``` ## Strings ### Interning Many modern languages (such as Java, C#, Python, Ruby, JavaScript, Go, etc.) support a technique called **interning**, in order to manage strings in memory. This consists in storing only one copy of each distinct string created during the execution of a program. These strings are stored in a shared **pool**, and each of them is an immutable object. Some benefits are faster string comparisons, lower memory footprint, etc. ### in Java In Java, a string is an object. Like for regular objects, comparing two variables of type `String` with `==` compares their references: ```java String myString = new String(\"foo\"); String sameString = new String(\"foo\"); // Outputs false, because the two variables hold different references. System.out.println(myString == sameString); ``` A string can be explicitly interned (i.e. added to the shared pool) with the (instance) method `intern`. This method: - tries to add the string to the pool, and then - returns a reference to the (only) version of the string contained in the pool. For instance, consider the following program: ```java // Creates a string \"foo\", String myString = new String(\"foo\") // adds it to the pool, myString = myString.intern(); // Creates another string \"foo\", String sameString = new String(\"foo\"); // Outputs false. System.out.println(myString == sameString); // Tries to add \"foo\" to the pool once again. // Because the pool already contains a version of \"foo\", returns a reference to it. sameString = sameString.intern(); // Outputs true, because the two variables now hold the same reference. System.out.println(myString == sameString); ``` A string that is initialized without constructor (i.e. directly with \" \") _is interned_. For instance ```java String myString = \"foo\"; String sameString = \"foo\"; // Outputs true, because of (implicit) interning System.out.println(myString == sameString); ``` In order to support interning, string in Java are _immutable_. In particular, the instance methods of the class `String` (like `substring`, etc.) do _not_ modify a string. Instead, some of them may return (a reference to) a _different_ object. For instance: ```java String foo = new String(\"foo\"); String copy = foo; // Outputs true, because the two variables hold the same object reference. System.out.println(copy == foo); foo = foo.replace('o','O'); // Outputs false, because the method 'replace' returns a reference // to another object. System.out.println(copy == foo); ``` The class `String` overrides the method [equals](http://localhost:44407/docs/objects/sections/comparing/#equals) so that it implements string comparison in the expected way. For instance: ```java String myString = new String(\"foo\"); String sameString = new String(\"foo\"); // Outputs false. System.out.println(myString == sameString); // Outputs true. System.out.println(myString.equals(sameString)); ``` **_Hint._** By default, you can always use `equals` to compare the values of two strings. This is less error-prone than `==` (albeit less efficient if the two strings differ). ## Java boxed types {#boxedTypes} Java has 8 primitive types: `byte`, `short`, `int`, `long`, `float`, `double`, `boolean` and `char`. For each primitive type, Java has a so-called **boxed** or (**wrapper**) type: `Byte`, `Short`, `Integer`, `Long`, `Float`, `Double`, `Boolean` and `Character`. These types can be used in Java collections (`Set`, `List`, etc.), whereas primitive types cannot. Some boxed types also offer additional functionalities, via instance methods (e.g. an `Integer` can represent a positive numbers up to \\(2^{32} - 1\\) ). Constructors for boxed types are deprecated. Instead, instances can be created via so-called **autoboxing**, for instance: ```java Integer myInteger = 2; Character myCharacter = 'a'; ``` Several Java operators (like `+`, `==`, `\u003c=`, etc.) are also overloaded so that they behave with boxed types as they would with primitive types. For instance: ```java Integer i = 1; i += 1; Integer j = 2; // Outputs true System.out.println(i == j); ``` Like strings, instances of boxed types are _immutable_. This can affect performance. For instance: ```java for (Integer i = 0; i \u003c 1000000 ; i++){ ... } ``` may create up to 1 million objects in memory. This is one of the reasons why it is usually recommended to use primitive types whenever possible (see for instance [Effective Java](http://localhost:44407/docs/intro/sections/bibliography/#effectiveJava), Item 61). Some boxed types are (partially) interned, analogously to strings. "},{"id":72,"href":"/docs/abstractdatatypes/sections/sorting/","title":"Sorting","section":"Abstract data types","content":" # Sorting Sorting a collection (of values or objects) is needed in a variety of scenarios. ## Sorting criterion In order to sort a collection of values (resp. objects), we need a _sorting criterion_, i.e. a way to compare two values (resp. objects). Some data types come with a natural way to compare two values. For instance, two real numbers can be compared w.r.t. $\\le$. **_Observation._** Some data type have several natural sorting criteria. For instance, strings may be sorted alphabetically from left to right (in English, Hindi, Russian, etc.) or from right to left (in Arabic, Hebrew, Persian, etc.). \u003e **_Question._** \u003e What about objects, i.e. \u003e which sorting criterion can be used to sort a collection of people, cities, sets, lists, trees, etc.? \u003e **_Answer._** \u003e Any [total preorder](http://localhost:44407/docs/background/sections/order/#preorder) (i.e. a total, reflexive and transitive binary relation) can be used to sort a collection. Exercise Which of the following are total preorders (i.e. can be used as a sorting criterion)? 1. Compare two real numbers w.r.t. to their absolute value. 2. Compare two people w.r.t. to their age. 3. Compare two people w.r.t. to their age _and_ size, i.e. $\\qquad \\qquad p_1 \\preceq p_2$ iff $\\big(p_1.{\\text{age}} \\le p_2.{\\text{age}}$ and $p_1.{\\text{size}} \\le p_2.{\\text{size}}\\big)$. 4. Compare two people w.r.t. to their age _or_ size, i.e. $\\qquad \\qquad p_1 \\preceq p_2$ iff $\\big(p_1.{\\text{age}} \\le p_2.{\\text{age}}$ or $p_1.{\\text{size}} \\le p_2.{\\text{size}}\\big)$. 5. Compare two people w.r.t. to their age, and then their size (if they have the same age). 6. Compare two points w.r.t. to their X coordinate, and then their Y coordinate (if they have the same X coordinate). 7. Compare two trees w.r.t. to their number of nodes. 8. Compare two sets w.r.t. to set inclusion. 9. Compare two lists of integers by first sorting them, and then comparing them lexicographically. Solution - 3. is a partial preorder, - 4. is not transitive, and - 8. is a partial order. The others are total preorders. ## Properties of sorting algorithms [Sorting algorithms](https://en.wikipedia.org/wiki/Sorting_algorithm) have been extensively studied. We will _not_ cover them this semester (with one exception), because this is part of another course of the bachelor. We only highlight some of their properties. ### Stability {#stable} **_Definition._** A sorting algorithm is **stable** if it preserves the initial order (in the input collection) of two elements that are equivalent w.r.t. to the sorting criterion. **_Example._** Consider an array `[u1, u2]` of type `Unit[]`, where (the objects referenced by) `u1` and `u2` both have health `2`. And let us sort the elements of this array by health. - A _stable_ sorting algorithm outputs `[u1, u2]`. - A _non-stable_ sorting algorithm may output `[u1, u2]` or `[u2, u1]`. ### In place **_Definition._** A sorting algorithm is **in place** if it does not use additional data structures. ## in Java ### Comparing Java provides several native ways to define a total preorder. We highlight here two of them. #### Comparable A class `T` can implement the interface `Comparable`. **_Example._** We can create a class `City` that implements `Comparable` as follows: ```java public class City implements Comparable { ... } ``` The interface `Comparable` specifies a single method ```java int compareTo (T otherObject); ``` This method should define a [total preorder](http://localhost:44407/docs/background/sections/order/#preorder) $\\preceq$ over instances of `T`, as follows. Let $o_1$ be the current object (i.e. the instance used to call the method), and let $o_2$ be the other object (i.e. the argument of the method `compareTo`). Then this method should return: - a negative integer if $o_1 \\prec_o o_2$ (i.e. if $o_1 \\preceq_o o_2$ and $o_2 \\not\\preceq_o o_1$), - `0` if $o_1 =_o o_2$ (i.e. if $o_1 \\preceq_o o_2$ and $o_2 \\preceq_o o_1$), - a positive integer otherwise. **_Example (continued)._** Here is an implementation of the method `compareTo` where cities are compared by zip code: ```java public class City implements Comparable { public String name; public int zipCode; public City(String name, int zipCode) { this.name = name; this.zipCode = zipCode; } @Override public int compareTo(City otherCity) { return zipCode \u003c otherCity.zipCode ? -1 : zipCode == otherCity.zipCode ? 0 : 1; } } ``` **_Hint._** Some native Java classes already implement `Comparable`, in the expected way. For instance `Integer`, `String` (left to right alphabetical order), etc. **_Hint._** Comparator methods are also available for primitive types (like `int`, or `bool`). For instance, `Integer` has a static method `compare(int x, int y)` that behaves like `compareTo`. So the method `compareTo` in the example above can be simplified as follows: ```java public class City implements Comparable { ... @Override public int compareTo(City otherCity) { return Integer.compare(zipCode, otherCity.zipCode); } } ``` **_Warning._** The method `compareTo` is implicitly used by some of Java's native data structures (e.g. `TreeSet`). So it is usually recommended to implement `compareTo` in such a way that it \"complies\" with `equals` (and `hashCode`). This means that $\\qquad \\qquad $`o1.compareTo(o2)` should return `0` iff `o1.equals(o2)` returns `true`. If you want to use a sorting criterion that does _not_ satisfy this constraint (or if you want to use alternative sorting criteria for the same class), then we recommend using a `Comparator` instead (explained below). #### Comparator A `Comparator` in Java is intuitively a total preorder. The Java interface `Comparator` specifies one method that must be implemented by each instance, with signature: ```java int compare(T o1, T o2) ``` The return value (negative integer, `0` or positive integer) has the same meaning as the one of `Comparable.compareTo`. **_Example (continued)._** We can create another comparator for our class `City`, which uses the city' name rather than zip code. ```java public class CityNameComparator implements Comparator { @Override public int compare(City c1, City c2) { return c1.name.compareTo(c2.name); } } ``` The interface `Comparator` also provides convenient (default) methods. For instance, the method [thenComparing](https://docs.oracle.com/javase/8/docs/api/java/util/Comparator.html#thenComparing-java.util.Comparator-) returns the [lexicographic product](http://localhost:44407/docs/background/sections/order/#lexProduct) of two comparators. ### Sorting Java provides several methods to sort an array or collection. We highlight here a few of them. #### Sorting an array For an array of type `T[]`, the static method `Arrays.sort(T[] array)` can be called as follows: **_Example._** ```Java int[] integers = new integer[]{2,1,3,2}; Arrays.sort(integers) // Outputs [1,2,2,3] System.out.println(Arrays.toString(array)); ``` This method sorts the array using the so-called \"natural ordering\" for type `T`. The \"natural ordering\" is: - the one expected for primitive types (like `int`), boxed types (like `Integer`) and a few other native types (like `String` or `Date`); a list can be found [here](https://docs.oracle.com/javase/tutorial/collections/interfaces/order.html), - the one defined by `T.compareTo` if `T` implements `Comparable`, - _underspecified_ if `T` is a class that does not implement `Comparable`. The method `Arrays.sort(T[] array, Comparator\u003c? super T\u003e c)` is similar, but it uses the input comparator to sort the array. **_Example(continued)._** ```Java City trento = new City(\"Trento\", 38121); City bologna = new City(\"Bologna\", 40100); City[] cities = new City[]{trento, bologna}; // After this, the array 'cities' contains [bologna, trento] Arrays.sort(cities, new CityNameComparator()); ``` **_Property._** Both methods guarantee _stable_ sorting. For instance: ```Java City trento1 = new City(\"Trento\", 38122); City bologna = new City(\"Bologna\", 40100); City trento2 = new City(\"Trento\", 38121); City[] cities = new City[]{trento1, bologna, trento2}; // After this, the array 'cities' contains [bologna, trento1, trento2] Arrays.sort(cities, new CityNameComparator()); ``` **_Note._** For an array with primitive type (like `int[]`), these two methods use (a version of) the [Quicksort](https://en.wikipedia.org/wiki/Quicksort) algorithm, even though Quicksort is _not_ stable. Stability is irrelevant for these types: for instance, permuting the elements of the array `[5,5]` yields the same array. However, for an array with (arbitrary) reference type (like `City[]`), these methods use (a version of) the [MergeSort](https://en.wikipedia.org/wiki/Merge_sort) algorithm, which is stable. #### Sorting a list The class `Collections` provides a method `Collection.sort(List list)`, whose behavior is analogous to `Arrays.sort`. In particular, it also guarantees stable sorting. Like `Arrays.sort`, it comes in two flavors (with and without comparator). **_Example(continued)._** ```Java City bologna = new City(\"Bologna\", 40100); City trento = new City(\"Trento\", 38122); List cities = new LinkedList(); cities.add(bologna); cities.add(trento); // After this, the list 'cities' contains [trento, bologna], // due to the way 'City' implements 'compareTo'. Collections.sort(cities); // After this, the list 'cities' contains [bologna, trento], Collections.sort(cities, new CitynameComparator()); ``` The interface `List` also provides a default method `sort` that takes a comparator as argument. So in the above example, we could have used: ```java cities.sort(new CitynameComparator()); ``` instead of ```java Collections.sort(cities, new CitynameComparator()); ``` ### Usage Exercise Consider the following class: ```java public class Hero { String name; int health; public Hero(String name, int health){ this.name = name; this.health = health; } } ``` Write a Java method `void printHeroesOcc(Hero[] heroes)` that takes as input an array of type `Hero[]`, and prints the number of occurrences of each hero in this array, where two heroes are considered identical if they have the same name and health. **_Constraint._** For this exercise, you _cannot_ use an associative array (a.k.a. Java `Map`). Possible solution Create a comparator (compare first by health, then by name): ```Java public class HeroComparator implements Comparator { @Override public int compare(Hero h1, Hero h2) { if(h1.health \u003c h2.health) { return -1; } if(h1.health \u003e h2.health) { return 1; } return h1.name.compareTo(h2.name); } ``` Sort the array and iterate over it to count the number of occurrences of each hero: ```Java void printHeroesOcc(Hero[] heroes) { if (heroes.length == 0) { return; } Comparator comparator = new HeroComparator(); // sort the input array w.r.t. to the comparator Arrays.sort(heroes, comparator); // keeps track of the last hero seen so far Hero previousHero = heroes[0]; // occurrences of the last hero seen so far int occ = 1; // iterate over the array, starting fom the second hero for (int i = 1; i \u003c heroes.length; i++) { // if the current hero and the previous one have the same // name and amount of health if (comparator.compare(previousHero, heroes[i]) == 0) { occ++; } else { printHero(previousHero, occ); previousHero = heroes[i]; occ = 1; } } printHero(previousHero, occ); } private void printHero(Hero hero, int occ) { System.out.println(hero.name + \",\" + hero.health + \": \" + occ); } ``` **_Note._** The solution to the exercise above relies on sorting the input array. But the same problem could be solved with an [associative array](http://localhost:44407/docs/abstractdatatypes/sections/map/), as follows: - override `equals` and `hashCode` in the class `Hero`, - compute a `Map` that maps each hero to its number of occurrences in the input array, - iterates over the entries of this map and print them. When it comes to running time, the latter solution is more efficient _on average_ (assuming a hashmap), but less efficient _in the worst case_. "},{"id":73,"href":"/docs/input/","title":"I/O and serialization","section":"Docs","content":"\n# I/O and serialization\n\nThis chapter mostly focuses on Java.\n\nIt provides (mostly syntactic) information about:\n\n- [navigating](http://localhost:44407/docs/input/sections/files/#navigation) or [manipulating](http://localhost:44407/docs/input/sections/files/#manipulation) files and directories,\n- [reading](http://localhost:44407/docs/input/sections/read/#read) from and [writing](http://localhost:44407/docs/input/sections/read/#write) to a test file,\n- [property files](http://localhost:44407/docs/input/sections/property/),\n- serializing (and deserializing) a Java object, either [natively](http://localhost:44407/docs/input/sections/serialize/), or as a [JSON object](http://localhost:44407/docs/input/sections/json/) (via Jackson).\n"},{"id":74,"href":"/docs/git/sections/ignore/","title":"Ignoring files","section":"git","content":"\n# Ignoring files\n\nYou can add a file named `.gitignore` to the root folder of your repository.\n\nIt specifies files that _cannot_ be staged.\n\nThis is commonly used to exclude from a repository:\n\n- compiled code (e.g. files with the extension `.class` in Java),\n- dependencies (e.g. the content of the `/node_modules` folder in a Node.js project),\n- IDE-generated files (e.g. the `.idea/` folder for IntelliJ),\n- OS-generated files (e.g. `.DS_Store/` folders for macOS),\n- etc.\n\nThe `.gitignore` file uses a dedicated syntax to specify which files should be excluded.\n\nFor instance the pattern `*.class` excludes all files with the extension `.class`.\n\nHere is a quick [tutorial](https://www.atlassian.com/git/tutorials/saving-changes/gitignore) about the syntax of `.gitignore` files.\n\n[This repository](https://github.com/github/gitignore/tree/main) also contains a large collection of `.gitignore` patterns, for different programming languages, operating systems, programs, etc.\nFor instance\n[Java](https://github.com/github/gitignore/blob/main/Java.gitignore),\n[VSCode](https://github.com/github/gitignore/blob/main/Global/VisualStudioCode.gitignore),\n[IntelliJ](https://github.com/github/gitignore/blob/main/Global/JetBrains.gitignore),\n[Windows](https://github.com/github/gitignore/blob/main/Global/Windows.gitignore),\n[macOS](https://github.com/github/gitignore/blob/main/Global/macOS.gitignore),\n[Linux](https://github.com/github/gitignore/blob/main/Global/Linux.gitignore),\netc.\n"},{"id":75,"href":"/docs/env/sections/terminal/","title":"Terminal","section":"Development environment","content":" # Terminal Using a terminal can be necessary during development, in order to execute a program that does not have a graphical user interface (GUI). But even when a GUI is available, a Command Line Interface (CLI) can still be the _preferred way_ to interact with some programs. Possible benefits are: - efficiency (thanks to autocompletion, there is very little to type), - automation (via scripting), - more transparency (a GUI may add a layer of obfuscation), - stability over time (GUIs tend to change from one version of a program to another), - reproducibility (the same command performs the same action, with a limited reliance on memory), - customizability. # Demonstration The following demo is meant to (quickly) illustrate some benefits of a properly configured terminal, as well a few terminal-based applications. This is _not_ an introduction to bash or Linux core utilities. ## Virtual environment For this demo, we deployed a virtual machine with a pre-configured terminal. The instructions for connecting to this machine are identical to the one for the project [evaluation environment](http://localhost:44407/docs/env/sections/eval/). ## Creating a static website As an exercise, we will create a static website, using a simple framework called [Hugo](https://gohugo.io/). First, in our home folder, let us create a subfolder dedicated to our projects. For instance, we can call this subfolder `workspace`. To create this folder, [open a terminal](http://localhost:44407/docs/env/sections/eval/) and run: ```bash mkdir workspace ``` Then navigate to this folder with the command `cd` (you do not need to type the full name of the directory, just type `cd w`, and press the Tab key for autocompletion): ```bash cd workspace ``` Next, we will (loosely) follow the quick start tutorial for Hugo. Explanations about some of the command below can be found [here](https://gohugo.io/getting-started/quick-start/). Copy-paste the following instruction and press Enter: ```bash hugo new site mySite ``` This will create a project in a fresh folder called `mySite`. Let us navigate to it (again, you can take advantage of autocompletion): ```bash cd mySite ``` Now copy-paste the following commands to declare this folder as a git repository and download a graphical theme for our website: ```bash git init git submodule add https://github.com/theNewDynamic/gohugo-theme-ananke.git themes/ananke echo \"theme = 'ananke'\" \u003e\u003e hugo.toml ``` ## Navigation At any moment, you can run the command: ```bash pwd ``` to display the current directory. With this command, you can check that you are indeed in the folder `mySite`. To get a overview of the content of the current folder, run: ```bash ll ``` To get a recursive overview of the content of this folder, run: ```bash tree ``` In order to navigate to a certain subfolder in this tree, we can take advantage of the [fuzzy finder](https://github.com/junegunn/fzf). For instance, let us assume that we want to move to some folder called `socials`, but we forgot its exact path. Run: ```bash c ``` This will display the paths to all directories in this tree. You can type characters to restrict your search, and use the up down arrow keys to select your destination. For instance, type the three character `soc`. The best matches are displayed at the bottom of the list. To select one of them, navigate up and down with the arrow keys and press Enter. **_Note_.** Thanks to fuzzy search, the characters that you type do not need to be contiguous in a path. For instance, when you typed `soc`, all paths containing these three letters (in that order, but not necessarily contiguous) were retained. Now let us navigate back to the `mySite` folder. Here we can use [zoxide](https://github.com/ajeetdsouza/zoxide), which uses our path navigation history to guess our destination. Run: ```bash z mySite ``` (or possibly fewer letters). Similarly, to go back to the `socials` subfolder that we previously went to: ```bash z socials ``` Alternatively, you can switch between your current location and the previous one (thanks to zoxide still) with: ```bash zz ``` ## Starting the web server Navigate (back) to the `mySite` folder (you should know how to do this by now), and run: ```bash hugo server ``` This will start a local development server for our website. To visualize the site, open Firefox (from the app menu), and use the address displayed in the terminal (it should be `http://localhost:1313/`) To stop the server (or any Linux process running in a terminal), go back to the terminal an press Ctrl+C. Next, we will add content to our website, while keeping the server running. To restart the server, we can use our command history. Type the first letters of the command that we used above to start the serve (e.g. `hu`). By pressing the up and down arrow keys, you can scroll through the commands that you already typed and start with these letters. Scroll until you find the command `hugo server`, and press Enter to restart the server. In order to keep the server running, we will execute our next command in another terminal. You can create a new one by clicking on the boxed \"+\" icon: ## Adding content Navigate to the (immediate) subfolder `content` of `mysite`. Then create a subfolder named `posts`: ```bash mkdir posts ``` Navigate to this new folder. Then create a new text file called `myPost.md`. You can for instance do this with the command: ```bash gedit myPost.md ``` which will open the file with the test editor \"gedit\". **_Note._** If you only type `ge` followed by Tab, the shell will suggest you a list of programs whose name starts with these letters. You can scroll through them by pressing Tab again, or add a letter to disambiguate your search. In the text editor, copy-paste the following content: ```text +++ title = 'My First Post' date = 2024-01-14T07:07:07+01:00 +++ ## Introduction This is **bold** text, and this is *emphasized* text. ### Subsection This is a [link](https://gohugo.io) to the Hugo website. ``` In this file, everything below the header (title/date) is written in [Markdown](https://www.markdownguide.org/basic-syntax/). Save the file, and check with Firefox that your first post has been added to your website (to see your changes, you may need to force Firefox to clear its cache: in \"Settings | Privacy \u0026 Security | Cookiesand Site Data\", click on the \"Clear Data\" button). ## Aliases The command `c` that we used above is actually an alias for a more complex command, namely `cd $(find * -type d | fzf)` We declared this alias in the file `~/.zshrc` (remember that `~` is a shortcut for your home folder). Let us open this file to see the declaration of this alias. Navigate to your home folder, for instance with: ```bash cd ``` And list its content: ```bash ll ``` The file `.zshrc` should be there. Open this file with gedit: ```bash gedit .zshrc ``` **_Note._** Again, you can take advantage of autocompletion here. For instance, press `ged` followed by Tab followed by `.z` followed by Tab. Towards the end of this file, you will see the declaration of the alias: ```bash alias c='cd $(find * -type d | fzf)' ``` Let us create another useful alias. Ubuntu has a convenient command called `xdg-open` that opens a file with the default application associated to this file's extension (this is the equivalent of a double-click in a graphical file browser). Let us set a simpler name than `xdg-open` to execute this command. For instance `o` (like \"open\"). First, let us check that the name `o` is not used already for another command. Open a new terminal and run: ```bash o ``` You should get a \"command not found\" message, which confirms that this command is free. Now let us add the following line to the `.zshrc` file: ```bash alias o='xdg-open' ``` Save the file and open a new terminal. You can now use the `o` command to open any file. To see this, let us navigate back to the `socials` folder that we were previously in (e.g. type `z so`, then up arrow key and then Enter). If you list the files in this folder (with `ll`), you will see that they have the `.svg` extension. To open one of these files, you can type `o ` and the first letters of the name of the file, then Tab for autocompletion. This will open the file with the default image viewer application on this machine. ## Scripts If you want to use an alias to execute a (possibly complex) _sequence_ of commands, then the preferred way is to write a script. For instance, we could write a script that navigates to the `mySite` folder and then starts the hugo server. And we may use the alias `ws` (like \"website\") to call this script (you can check that it is free). Navigate to the `~/bin` folder, and create a text file called `ws` (for instance with gedit, as we did above for the post). In this file, copy-paste the following: ```bash #! /bin/bash cd ~/workspace/mySite hugo server start ``` Observe that these are the two instructions for the two tasks that we want to execute. Save the file, and make it executable by running: ```bash sudo chmod u+x ws ``` To test your script, close all running instances of hugo (if any), e.g. with Ctrl + C, as explained above. Now regardless of your location, you can type `ws` to start the web server. **_Note._** Linux shells (such as bash or zsh) support the same language for commands and scripts. This is a full-fledged programming language (with conditional statements, loops, etc.), where an instruction can also be a command. ## Terminal-based applications To conclude the demo, we introduce a few convenient applications that run in a terminal. These may save you time (compared to similar applications that rely on a GUI). ### ripgrep [ripgrep](https://github.com/BurntSushi/ripgrep) allows you to search files that contain certain words or regular expressions (your IDE offers a similar functionality). For instance, let us assume that we want to search for all files under `mySite` that contain the string \"Canada\". Navigate to the `mySite` folder. Then run: ```bash rg Canada ``` This will display the path to each (text) file that contains this word (in this example, there is only one match), and the corresponding line numbers. ### ranger [ranger](https://github.com/ranger/ranger) is a popular terminal-based file browser. To open it, type: ```bash ranger ``` You can navigate within the current directory with the up and down arrow keys, and in the directory tree (from child to parent and conversely) with the left and right arrow keys. Note that it also displays previews of text files. To quit ranger, you can press the letter q. ### htop [htop](https://htop.dev/) allows you to monitor processes running on your machine. To open it, type: ```bash htop ``` The upper part of the interface displays memory and CPU usage, whereas the lower part displays running process (sorted by CPU usage by default). You can kill a process with F9. To quit htop, you can press the letter q. ### ncdu [ncdu](https://dev.yorhel.nl/ncdu) allows you to visualize the amount of disk space taken by your files and programs. To open it, type: ```bash ncdu ``` The folders and files in the current folder are sorted by disk space, and you can navigate the directory tree using the arrow keys (like with ranger). To quit ranger, you can press the letter q. "},{"id":76,"href":"/docs/objects/sections/encapsulation/","title":"Encapsulation","section":"Objects and classes","content":" # Encapsulation **Encapsulation** is a (vague) principle in object-oriented programming that refers to _\"bundling\"_ data with the code that operates on it, and _restrict visibility_ of this code and data to other components of a system. \u003e From [Wikipedia](): \u003e \"Essentially, encapsulation prevents external code from being concerned [...]\" Each component hides its internal logic by exposing only data and methods that other components may need. **_Example._** As we saw [earlier](http://localhost:44407/docs/objects/sections/clone/), in our game, the \"view\" component (which is in charge of rendering the game on screen) may _buffer_ the game snapshots that it receives from the backend, if these snapshots are received faster than they can be displayed. As a buffer, this component uses a structure called a **queue**. This queue is _not exposed_ to other components, because they do not need to _see_ it, and (most importantly) should not _modify_ it. In other words, this queue is an implementation detail, _internal_ to the \"view\" component. Encapsulation can have many benefits. Among others: 1. **_Easier debugging._** If our queue is internal to the \"view\" component, then we know that it cannot be responsible for the malfunction of another component. 1. **_Easier collaboration_**. Alice may refactor the implementation of the \"view\" component, knowing that this will not affect Bob, who is currently working on the backend. This is why a common practice in object-oriented programming consists in _hiding all attributes and methods_ of a new class by default, and make accessible only the ones that need to be (in particular, this is likely to be the default behaviour of your IDE). Encapsulation also largely dictates how _libraries_ are structured. For instance, when you create a `String` in Java, you do not have access to the internal representation of the string object. ## in Java Each attribute or method of a class can have an **access modifier**, which specifies which other classes can access it. For instance, the keywords `private` and `protected` below are access modifiers. ```java private int myAttribute; protected int myMethod(){ return 1; } ``` **_Definition._** There are four levels of access in Java: - `private` restricts access to the _current class_, - \"package-private\" relaxes `private` by also allowing access from the _folder_ of the current class (in Java, a folder for source code is called a **package**), _excluding subfolders_, - `protected` relaxes \"package-private\" by also allowing access from the _subclasses_ of the current class, - `public` does not restrict access. **_Warning._** There is no keyword for the \"package-private\" level. Instead, this is the default level for an attribute or method _without_ access modifier. For instance, in the example below, the attribute `myAttribute` is package-private: ```java int myAttribute; ``` Here is a recap table from the [Oracle tutorials](https://docs.oracle.com/javase/tutorial/java/javaOO/accesscontrol.html): | keyword | class | package | subclasses | world | | ----------- | ----- | ------- | ---------- | ----- | | `private` | yes | no | no | no | | none | yes | yes | no | no | | `protected` | yes | yes | yes | no | | `public` | yes | yes | yes | yes | **_Warning._** A method declared in an [interface](http://localhost:44407/docs/interfaces/sections/java_interfaces/) is (implicitly) public. **_Warning._** If a method _m1_ overrides (or implements) a method _m2_, then _m1_ must be at least as accessible as _m2_. Exercise The following program does not compile. Can you see why, and how to fix this? ```bash ├── Run.java └── units ├── Unit.java └── impl └── Unicorn.java ``` ```java public abstract class Unit { static String configFolder = \"path/to/config\"; } ``` ```java public class Unicorn extends Unit { String name; public Unicorn (String name){ this.name = name; } public static String getConfigFilePath (){ return configFolder + \"/unicorn.properties\"; } } ``` ```java public class Run { void testUnicorn(){ Unicorn myUnicorn = new Unicorn(\"Storm\"); myUnicorn.name = \"Tornado\"; } } ``` Solution - `Unicorn.getConfigFilePath` tries to access the package-private attribute `Unit.configFolder` (it should be made protected of public), - `Run.getConfigFilePath`, tries to access the package-private attribute `name` of `myUnicorn` (it should be made public). **_Hint._** Your IDE may suggest how to fix such compilation errors. To improve encapsulation, it is good practice to _restrict access_ whenever possible (i.e. without compromising compilation). **_Hint_.** As a rule of thumb, in Java: - use `private` by default for all attributes and methods that you create, and - if the program does not compile, then use your IDE to relax access. Exercise Encapsulation in this program can be improved. Can you see how? ```bash ├── Run.java └── units ├── Unit.java └── impl └── Unicorn.java ``` ```java public abstract class Unit { public int health; public Unit(int health) { this.health = health; } public void attack(Unit defender){ int copy = health; health -= defender.health; defender.health -= copy; } } ``` ```java public class Unicorn extends Unit { public Unicorn (){ super(1); } @Override public void attack(Unit defender){ regen(); super.attack(defender); } public void regen(){ health += 1; } } ``` ```java public class Run { void testUnicorn(){ Unicorn u1 = new Unicorn(); Unicorn u2 = new Unicorn(); u1.attack(u2); } } ``` Solution - `Unit.health` can be made protected, - the constructor of `Unit` can be made protected, - `Unit.attack` can be made protected, - `Unicorn.regen` can be made private. **_Note._** The constructor of an _abstract_ class can always be made protected (since it can only be called in the constructor of a subclass). ## Getters and setters {#getterSetter} For attributes, the notion of \"access\" can be refined. An attribute may be: - neither visible nor modifiable, or - only visible, or - only modifiable, or - both visible and modifiable. This can be achieved with private attributes and so-called \"getter\" and \"setter\" methods. For instance, in the following class, the attribute `health` has public visibility but is not modifiable. ```java public class Unicorn { private int health; public int getHealth(){ return health; } } ``` Conversely, in the following class, the attribute `health` can be modified but is not visible. ```java public class Butterfly { private int health; public void setHealth(int health){ this.health = health; } } ``` **_Hint._** Getter and setter methods can be automatically generated by your IDE. ## To go further: inheritance violates encapsulation ### Composition **_Example_** (from [Effective Java](http://localhost:44407/docs/intro/sections/bibliography/#effectiveJava), Item 18). Consider a class `MyHashSet` that extends Java's `Hashset` functionality by keeping track of the number of objects _added_ to the set (as opposed to the output of `HashSet.size()`, which returns the numer of elements _remaining_ in the set). This class `myHashSet` may have an attribute `int counter` (initialized to `0`) that keeps track of the number of elements added to the set so far. And it may be implemented by overriding `add` and `addAll` in the expected way, i.e.: ```java @Override public boolean add(E e){ counter++; return super.add(e); } @Override public boolean addAll(Collection\u003c? extends E\u003e c){ counter += c.size(); return super.addAll(c); } ``` However, this implementation of `addAll` would count every insertion twice, because the implementation of `HashSet.addAll` calls `HashSet.add`. A design pattern called **composition** can be used to avoid such unintended effects. Intuitively, instead of extending the original class, use an instance `Hashset set` of it as a (private) attribute of the new class. However, this requires re-implementing all methods of the original class (albeit in a straightforward way), for instance: ```java public boolean isEmpty(){ return set.isempty(); } ``` ### Prevent overriding or inheritance As show by the example above, in order to improve encapsulation, one may want in some scenarios to forbid overriding a method or extending a class. In Java, this can be enforced with the keyword `final`, for instance: ```java public final class NonExtensibleClass { ... } ``` ```java public class MyClass{ public final void nonOverridableMethod(){ ... } } ``` "},{"id":77,"href":"/docs/git/sections/resources/","title":"To go further","section":"git","content":"\n# To go further\n\nHere is a brief selection of resources about git (among many):\n\n- a (short) [video](https://www.youtube.com/watch?v=hZS96dwKvt0) that goes beyond the content of this chapter,\n- the [Atlassian git tutorials](https://www.atlassian.com/git),\n- the [GitHub training material](https://githubtraining.github.io/training-manual/#/01_getting_ready_for_class),\n- [guidelines](https://cbea.ms/git-commit) about how to write an informative (yet readable) commit message.\n\n## Misc\n\nHere is a link to git's very [first commit](https://github.com/git/git/commit/e83c5163316f89bfbde7d9ab23ca2e25604af290).\n"},{"id":78,"href":"/docs/objects/sections/quiz/","title":"Quiz","section":"Objects and classes","content":" # Quiz To answer the quiz (and check your answers), [click here](https://forms.gle/P2GgesHngYRZAGSh7) or scan this code: ![](/img/qr_codes/quiz2_400.svg) ## Boxed type ```java public class City { int population; public City (int population){ this.population = population; } } ``` ```java int myInteger = 1; Integer myBoxedInteger = 1; Integer myBoxedCopy = myInteger; City myCity = new City(5000); myMethod(myInteger, myBoxedInteger, myBoxedCopy, myCity); System.out.println( myInteger + \", \"+ myBoxedInteger + \", \"+ myBoxedCopy + \",\" + myCity.population); void myMethod(int integer, Integer boxedInteger, Integer boxedCopy, City city) { integer += 1; boxedInteger += 1; boxedCopy += 1; city.population += 1; } ``` This Java program outputs: - 1, 1, 1, 5000 - 1, 1, 1, 5001 - 1, 2, 1, 5000 - 1, 2, 1, 5001 - 1, 2, 2, 5000 - 1, 2, 2, 5001 - 2, 2, 2, 5000 - 2, 2, 2, 5001 - I do not know the answer ## Objects and references ```java public class City { String name; Country country; public City(String name, Country country) { this.name = name; this.country = country; } } ``` ```java public class Country { String name; City capital; public Country(String name, City capital) { this.name = name; this.capital = capital; } } ``` ```java Country italy = new Country(\"Italy\", null); City florence = new City(\"Florence\", italy); City rome = new City(\"Rome\", italy); italy.capital = rome; System.out.print(italy.capital.name + \", \"); System.out.print(florence.country.capital.name + \", \"); System.out.print(rome.country.capital.name + \", \"); System.out.print(rome.country.capital.country.capital.name); ``` This Java program: - does not terminate - outputs null, null, null, null - outputs null, null, Rome, null - outputs null, null, Rome, Rome - outputs Rome, null, null, null - outputs Rome, null, Rome, null - outputs Rome, null, Rome, Rome - outputs Rome, Rome, Rome, Rome - I do not know the answer ## Copy constructor ```java public class City { String name; Country country; public City(String name, Country country) { this.name = name; this.country = country; } public City (City original) { this.name = original.name; this.country = original.country; } } ``` ```java public class Country { String name; City capital; public Country(String name, City capital) { this.name = name; this.capital = capital; } public Country(Country original){ this.name = original.name; this.capital = new City(original.capital); } } ``` ```java Country italy = new Country(\"Italy\", null); City rome = new City(\"Rome\", italy); italy.capital = rome; Country littleItaly = new Country(italy); littleItaly.name = \"littleItaly\"; littleItaly.capital.name = \"littleRome\"; System.out.print(littleItaly.capital.name+ \", \"); System.out.print(littleItaly.capital.country.name+ \", \"); System.out.print(littleItaly.capital.country.capital.name); ``` This Java program: - does not terminate - outputs Rome, Italy, Rome - outputs Rome, littleItaly, Rome - outputs littleRome, Italy, Rome - outputs littleRome, littleItaly, Rome - outputs littleRome, littleItaly, littleRome - I do not know the answer ## `toString` ```java public class City { String name; Country country; public City(String name, Country country) { this.name = name; this.country = country; } @Override public String toString() { return \"City{\"+ \"name=\" + name + \", \"+ \"country=\" + country + \"}\"; } } ``` ```java public class Country { String name; City capital; public Country(String name, City capital) { this.name = name; this.capital = capital; } @Override public String toString() { return \"Country{\"+ \"name=\" + name + \", \"+ \"capital=\" + capital + \"}\"; } } ``` In this program, the method `City.toString()`: - can output the empty string - always outputs the empty string - never outputs the empty string - is recursive - is not recursive - may not terminate - always terminates - never terminates ## Static attribute ```java public class MyClass { static int value; boolean flag; public MyClass(int value, boolean flag){ this.value = value; this.flag = flag; } void print(){ System.out.print(\"[\"+value+\" \"+flag+\"]\"); } void incrementValue(){ value++; } void setFlag(boolean flag){ this.flag = flag; } } ``` ```java MyClass o1 = new MyClass(2, true); MyClass o2 = new MyClass(3, false); o1.print(); myMethod(o1); o1.print(); void myMethod(MyClass object) { object.setFlag(false); object.incrementValue(); object.print(); } ``` This (strange) Java program outputs: - [2 true][3 false ][3 false] - [3 true][4 false ][4 false] - [2 true][3 false ][2 true] - [3 true][4 false ][3 true] - [2 false][3 false ][3 false] - [3 false][4 false ][4 false] - [2 false][3 false ][2 true] - [3 false][4 false ][3 true] - I do not know the answer. "},{"id":79,"href":"/docs/unittests/","title":"Unit tests","section":"Docs","content":" # Unit tests ## Testing software Testing is an integral part of software development. Different terminologies coexists to [categorize](https://en.wikipedia.org/wiki/Software_testing#Testing_types,_techniques_and_tactics) software tests (more or less precise, an with overlapping meanings). Common categories are: - functional vs non-functional test - unit vs integration test - security test - performance test - regression test - etc. A side benefit of many tests is that they help clarifying _what_ a program (resp. component, method) is expected to do. So in a sense, tests are part of the _documentation_ or specification of a system, because they provide precise _examples_ of the expected behavior of the program (resp. component, method). This is why tests are often part of the development process itself. Notably, [test-driven development](http://localhost:44407/docs/unittests/sections/tdd/) consists in developing tests cases _before_ software is fully developed. ## Unit tests A **unit test** is usually understood as: - testing the behavior of a _small_ piece of code (typically a method), - automated (typically integrated to the [build](http://localhost:44407/docs/build/) process), - fast. Besides, most unit tests are concerned with _correctness_ (rather than performance for instance). **_Warning._** The tests used to evaluate assignments in this course are implemented via libraries for unit testing. However, many of them do _not_ qualify as unit tests. In its simplest form, a unit test can be viewed as a pair $\\qquad$ (input, expected output) for a given [computational problem](http://localhost:44407/docs/background/sections/problem/). **_Example._** Consider the following problem: \u003e **_Input:_** a (finite) array of positive integers, representing the successive values of a stock, one value per day. \u003e \u003e **_Output:_** the maximal gain that can be made by buying on a certain day, and selling the same day or later on. Possible unit tests for this problem are: - ( [0, 3], 3 ) - ( [4, 3, 6, 8, 6], 5 ) - ( [2, 4, 9, 1, 3], 7 ) - ( [3, 2], 0 ) - etc. Exercise Consider the following problem: \u003e **_Input:_** a (finite) array of characters, with possibly duplicated characters (and no restriction on the size of the array). \u003e \u003e **_Output:_** the size of the longest (left-to-right) sequence in this array that respects alphabetical order. For instance, for the input $\\qquad$ `[m, q, b, e, e, z, m, e]`, the expected output is `4`. **_Question._** Does there exist a (finite) set of unit tests for this problem that guarantees that an implementation is correct? Solution No. A unit tests for this problem is a pair $(a, i)$, where - $a$ is an array of characters, and - $i$ is a natural number. Take any finite set $\\qquad (a_1, i_1), (a_2, i_2),\\ ..,\\ (a_n, i_n)$ of such unit tests. Because this set if finite, there exists an array of characters $a_0$ that does not appear in this set of tests. Let $i_0$ be the expected output for $a_0$, and let $j$ be any positive integer different from $i_0$. Now consider the method (in pseudocode): ``` int sizeOfLongestNonDecreasingSequence(char[] characters) { if(characters == a_1) { return i_1 } if(characters == a_2) { return i_2 } ... if(characters == a_n) { return i_n } return j; } ``` This algorithm will pass the unit tests, but is incorrect for the input $a_0$. So given any set of unit tests (for this problem), there exists an incorrect algorithm that passes these tests. This (artificial) exercise was only meant to illustrate the following: **_Warning._** In general, no (reasonably small) set of unit tests can ensure that a (non-trivial) method is correct. ## Unit test design Here are a few simple rules of thumb to design unit tests. 1. The input for a unit test is usually _small_ (this makes debugging easier when the test fails). 1. Two tests for the same method should illustrate different types of inputs/scenarios (writing similar tests is a waste of time). 1. Trivial methods do not need unit tests. 1. Priority is often given to so-called \"[happy path](https://en.wikipedia.org/wiki/Happy_path)\" tests (a.k.a \"normal\" scenarios). These are representative of what the tested method is likely to receive as input. 1. In addition to \"happy path\" tests, one _may_ implement tests that deal with corner cases (e.g. empty array, value `0`, etc.). However, an exhaustive coverage of corner cases is often unnecessary, because the methods that call the tested method cannot produce such inputs. 1. A unit test should be _reproducible_. In particular, it should not depend on: - (pseudo)-random values, - external services (web API, etc.) whose behavior cannot be controlled. ## Implementation **_Requirement._** A unit test should itself be _free of bugs_. For this reason, unit tests usually: - rely of widely used libraries for test execution, - mostly consist of simple, _declarative_ code otherwise. In particular, unit tests are a (rare) case where code factorization is _not_ a priority (i.e. unit tests may contain redundant code). ## Unit tests and build automation Unit tests are usually integrated to the standard build automation process of a project. For instance, the `test-compile` and `test` phases of Maven's [default lifecycle](http://localhost:44407/docs/build/sections/building/#phases) are in charge of compiling and executing unit tests respectively. This effectively prevents further phases to be executed if a test fails. ## Regression tests A **regression test** is meant to verify that modifications brought to the code base (e.g. a new feature, code optimization, reorganization, etc. ) do not compromise correctness of functionalities that were already implemented. Some unit tests may act in practice as regression tests. In particular, before sharing code with co-developers (e.g. via the main branch of a git repository), it is good practice to verify that all unit tests as _successful_. Exercise (reminder) Consider a basic collaboration scheme via git, where: - Alice, Bob and Carol collaborate on the same project, - they share code via the `main` branch, - each of them has a personal branch (named `alice`, `bob` and `carol` respectively) where they write code that is not yet ready to be shared with the others. Alice just finished implementing a method, on the branch `alice`. Her code compiles and passes all unit tests. Now she wants to share her code with the other two. Which sequence of git commands should Alice execute? Solution 1. Commit her changes (locally, to the branch `alice`): - `git add .` - `git commit -m \"commit message\"` 2. Update the remote copy of the branch `alice` (for backup only): - `git push` 3. Synchronize the local copy of the branch `main` (because Bob and Carol may have added content to it): - `git checkout main` - `git pull` 4. Merge (locally) the content of `main` into `alice` (and fix the merge conflicts, if any): - `git checkout alice` - `git merge main` 5. Merge (locally) the content of `alice` into `main` (there should be no more conflict). After this step, the local copies of `alice` and `main` will be identical. - `git checkout main` - `git merge alice` 6. Upload the changes: - `git push` 7. Go back to work: - `git checkout alice` "},{"id":80,"href":"/docs/env/","title":"Development environment","section":"Docs","content":"\n# Development environment\n\nThis chapter gives an overview of the tools and environment needed for the assignments and your project.\n\nBuilding automation tools (such as Maven or Gradle) have their dedicated chapter, and so does git.\n"},{"id":81,"href":"/docs/git/","title":"git","section":"Docs","content":" # Git Git is a so-called [distributed version control](https://en.wikipedia.org/wiki/Distributed_version_control) system, originally co-authored by Linus Torvalds to facilitate the development of the Linux kernel. It was first released in 2005, and has become ubiquitous in software development. For instance, [93.87%](https://survey.stackoverflow.co/2022/#section-version-control-version-control-systems) of respondents to the 2022 Stack overflow survey declared using it. Git allows synchronizing the content of a directory (called a **repository**) across several machines. Notably: - each machine contains a copy of the repository _and its full history_, - git allows parallel histories to coexist (in so-called **branches**), and provides ways to reconcile them. **_Warning._** Git is _not_ suited to large datasets (more than 1 GB). ## Scope of this chapter Git has almost 150 commands, each of which may be called with multiple options. But in practice, most users use a handful of these commands on a regular basis. This chapter only provides a basic introduction and a minimal set of commands, which you are likely to need during the development of you project. Additional resources can be found [here](http://localhost:44407/docs/git/sections/resources/). ## Terminology A difficulty when discovering with git may be it terminology. Here is a _very approximative_ map from git concepts to terms that you are familiar with: **_Glossary._** - a **repository**: a directory (more exactly, the root directory of a project) - a **remote**: a server - to **clone**: to copy (a repository) - to **commit**: to save - to **push**: to upload (to a remote) - to **fetch**: to download (from a remote) - a **branch**: an alternative history (in your favorite time-travel novel/series/movie) - to **merge**: to reconcile two branches ## CLI or GUI Many Graphical User Interfaces (GUI) are available for git, and many programs (e.g. probably your IDE) provide some form of git integration. However, git is mostly used (and almost exclusively taught) via its Command Line Interface (CLI). In addition, the documentation and help that you may find online overwhelmingly relies on its CLI. Possible explanations are efficiency (autocompletion, aliases, scripts, etc.), transparency, reproducibility, stability over time, etc. If you you use git via CLI, then we recommend using a modern shell for command autocompletion. In particular, if you are using Windows, consider using [git bash](https://www.atlassian.com/git/tutorials/git-bash) or the [posh-git](https://github.com/dahlbyk/posh-git) extension for Powershell. If you want a flavor of how a terminal can be configured (for git and other purposes), then you can follow the demo in the [dedicated chapter](http://localhost:44407/docs/env/sections/terminal/). ## Hosting service To collaborate via git and/or back up your repositories, you need to use a git hosting service. Popular options are [GitHub](https://github.com/), [Gitlab](https://about.gitlab.com/) or [Bitbucket](https://bitbucket.org/product). The Unibz also offers a self-hosted [Gitlab service](https://gitlab.inf.unibz.it/users/sign_in). "},{"id":82,"href":"/docs/build/","title":"Build automation","section":"Docs","content":" # Build automation **Building** a piece of software means converting source code into a program that can be executed. Building a program may consists of many subtasks: - generating code, - compilation, - linking, - unit tests, - file compression, - generating documentation, - creating an executable or an installer, - integration tests, - deployment, - etc. Each of these subtasks may be performed numerous times during the development of a program. So it is natural to _automate_ the build. A **build automation tool** is meant to facilitate the configuration of these tasks, and execute them automatically, typically as (one or several) \"pipeline(s)\". For instance, Maven is a build automation tool for Java. A Maven project is often build with a single command: ```bash mvn package ``` Other popular build automation tools include: - Make, CMake or Ninja for C/C++, - MSBuild for C#, - Grunt or Gulp for Javascript, - Gradle (multi-language), - sbt for scala - etc. **_Note._** Some subtasks of a build may be performed on a server (e.g. each time a developer [pushes](http://localhost:44407/docs/git/sections/sharing/#push) a git branch), as part of a process called **continuous integration** (CI). Popular frameworks to set up a CI server include [Jenkins]() and [Travis CI](https://en.wikipedia.org/wiki/Travis_CI). CI is beyond the scope of this course. ## in Java: Maven vs Gradle The two most popular build automation tools for Java are Maven and Gradle. Both also act as [package managers](http://localhost:44407/docs/env/sections/install/#package) for Java libraries. Maven is slightly older (2004 vs 2008), and influenced the design of Gradle. ### Maven Maven is (still?) more widely used than Gradle. It also has a gentler learning curve. In particular, Maven relies on a number of implicit _conventions_ (e.g. for directory layout). For a simple project, this often results in a _quicker set up_ than with Gradle (but makes advanced customization more involved). Due to the popularity of Maven, some of these conventions (e.g. directory layout and artifact naming) have also been adopted in other contexts. Additional strengths of Maven are: - excellent integration with IDEs, - a vast ecosystem of plugins. A common criticism of Maven is the use of XML files to specify a project's build, which can be verbose and difficult to parse (for a human being). **_In this course._** For simplicity, this chapter (mostly) focuses on Maven. In addition, the content is restricted to the _bare minimum_ (i.e. what you are likely to need for your project). For a more thorough introduction to Maven, a good entry point is the official [getting started guide](https://maven.apache.org/guides/getting-started/index.html#what-is-a-snapshot-version). ### Gradle Gradle is a _multi-language_ build automation tool. Among others, it offers support for project written in Java and its main derivatives (Groovy, Kotlin and Scala), C/C++ and Javascript. Gradle has been selected by Google as the official build automation tool for Android applications. Gradle has a _more concise syntax_ than Maven (precisely two: one is a Groovy Domain Specific Language (DSL), the other is a Kotlin DSL). Re-building a project can also be _faster_ with Gradle than than with Maven, thanks to more advanced caching strategies. Another strength of Gradle is its _flexibility_ : a build can be easily customized, whereas Maven relies on conventions that can be hard to bypass. Gradle is often considered more difficult to learn than Maven, especially for new programmers. Its syntax is also less stable (older project configurations need to be updated to comply with more recent releases). **_Note._** If you chose the [board game](http://localhost:44407/docs/project/sections/board_game/) as your project, then you will use Gradle (at least by default). The build is already configured. By default, you do not need to modify it, except maybe to [declare dependencies](http://localhost:44407/docs/build/sections/dependencies/#gradleDep). "},{"id":83,"href":"/docs/background/","title":"Background","section":"Docs","content":"\n# Background\n\nThis chapter gathers basic notions that are used throughout other chapters.\n"}]