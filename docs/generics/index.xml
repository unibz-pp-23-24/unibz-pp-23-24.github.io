<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Generic programming on Programming project 2023-24</title>
    <link>https://unibz-pp-23-24.github.io/docs/generics/</link>
    <description>Recent content in Generic programming on Programming project 2023-24</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <atom:link href="https://unibz-pp-23-24.github.io/docs/generics/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Type checking</title>
      <link>https://unibz-pp-23-24.github.io/docs/generics/sections/type_checking/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://unibz-pp-23-24.github.io/docs/generics/sections/type_checking/</guid>
      <description>Type checking # Statically vs dynamically typed languages # A compiled programming language is said to be statically typed if (most) type checks are performed during the compilation of a program, rather than during its execution. Such languages include , C/C++, C#, Go, Java, Kotlin, Typescript, Rust, etc., as well as functional (or functional-like) languages like Haskell or Scala.&#xA;Example. The following Java program does not compile.&#xA;String banana = &amp;#34;banana&amp;#34;; banana += 1; Languages that are not statically typed are called dynamically typed.</description>
    </item>
    <item>
      <title>Generics</title>
      <link>https://unibz-pp-23-24.github.io/docs/generics/sections/generics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://unibz-pp-23-24.github.io/docs/generics/sections/generics/</guid>
      <description>Generics # Terminology. The term generics usually refers to generic methods and generic types. Type variable # A type variable is a variable ranging over types. For instance, in the chapter dedicated to streams, we repeatedly used the variable $T$ to refer to the type of the elements of a stream.&#xA;Generic method # Example # Consider the following interface Unit and its two implementations Butterfly and Unicorn.&#xA;Let us assume a method healthiestButterfly with type</description>
    </item>
    <item>
      <title>Subtype</title>
      <link>https://unibz-pp-23-24.github.io/docs/generics/sections/subtype/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://unibz-pp-23-24.github.io/docs/generics/sections/subtype/</guid>
      <description>Subtype # As we saw in the previous sections, the purpose of generic programming is to write abstract code while enforcing type constraints. As a result, when we write a program that uses a generic type (e.g. a native Java Collection), we need to make sure that our code complies with these type constraints.&#xA;In some situations, this requires reasoning about types and their hierarchy (notably for programs that use callback methods).</description>
    </item>
    <item>
      <title>Variance</title>
      <link>https://unibz-pp-23-24.github.io/docs/generics/sections/variance/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://unibz-pp-23-24.github.io/docs/generics/sections/variance/</guid>
      <description>Variance # Subtype # Notation. If $A$ and $B$ are types, we will use $A \sqsubseteq B$ to denote the fact that $A$ is a subtype of $B$. Subtype and substitution # The Liskov substitution principle intuitively states that If $A \sqsubseteq B$, then it should be possible to replace $B$ by $A$ in a program, without affecting the correctness of type checks. Examples.&#xA;If Integer $\sqsubseteq$ Number, then a method that takes a Number as input should also accept an Integer.</description>
    </item>
    <item>
      <title>Type erasure</title>
      <link>https://unibz-pp-23-24.github.io/docs/generics/sections/erasure/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://unibz-pp-23-24.github.io/docs/generics/sections/erasure/</guid>
      <description>Type erasure in Java # Java compilers rely on an approach called type erasure to compile:&#xA;type parameters (e.g. Box&amp;lt;Integer&amp;gt;), type variables (e.g. Box&amp;lt;T&amp;gt;), and question marks (e.g. Box&amp;lt;? extends Number&amp;gt;). More often than not, when a Java program does not compile, we can understand why without understanding the compilation procedure. However, for generics, some basic understanding of type erasure can help.&#xA;Procedure # Intuitively, type erasure consists in producing a program equivalent to the initial one, but free of generic or parameterized types (i.</description>
    </item>
  </channel>
</rss>
