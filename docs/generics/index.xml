<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Generic programming on Programming project 2023-24</title>
    <link>https://unibz-pp-23-24.github.io/docs/generics/</link>
    <description>Recent content in Generic programming on Programming project 2023-24</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <atom:link href="https://unibz-pp-23-24.github.io/docs/generics/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Type checking</title>
      <link>https://unibz-pp-23-24.github.io/docs/generics/sections/type_checking/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://unibz-pp-23-24.github.io/docs/generics/sections/type_checking/</guid>
      <description>Type checking # Statically vs dynamically typed languages # A compiled programming language is said to be statically typed if (most) type checks are performed during the compilation of a program, rather than during its execution. Such languages include , C/C++, C#, Go, Java, Kotlin, Typescript, Rust, etc., as well as functional (or functional-like) languages like Haskell or Scala.&#xA;Example. The following Java program does not compile.&#xA;String banana = &amp;#34;banana&amp;#34;; banana += 1; Languages that are not statically typed are called dynamically typed.</description>
    </item>
    <item>
      <title>Generics</title>
      <link>https://unibz-pp-23-24.github.io/docs/generics/sections/generics/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://unibz-pp-23-24.github.io/docs/generics/sections/generics/</guid>
      <description>Generics # Terminology. The term generics usually refers to generic methods and generic types. Type variable # A type variable is a variable ranging over types. For instance, in the chapter dedicated to streams, we repeatedly used the variable $T$ to refer to the type of the elements of a stream.&#xA;Generic method # Example # Consider the following interface Unit and its two implementations Butterfly and Unicorn.&#xA;Let us assume a method healthiestButterfly with type</description>
    </item>
    <item>
      <title>Subtype</title>
      <link>https://unibz-pp-23-24.github.io/docs/generics/sections/subtype/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://unibz-pp-23-24.github.io/docs/generics/sections/subtype/</guid>
      <description>Subtype # As we saw in the previous sections, the purpose of generic programming is to write abstract code while enforcing type constraints. As a result, when we write a program that uses a generic type (e.g. a native Java Collection), we need to make sure that our code complies with these type constraints.&#xA;In some situations, this requires reasoning about types and their hierarchy (notably for programs that use callback methods).</description>
    </item>
    <item>
      <title>Type erasure</title>
      <link>https://unibz-pp-23-24.github.io/docs/generics/sections/erasure/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://unibz-pp-23-24.github.io/docs/generics/sections/erasure/</guid>
      <description> Type erasure # </description>
    </item>
  </channel>
</rss>
