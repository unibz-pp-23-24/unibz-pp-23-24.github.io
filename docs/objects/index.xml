<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Objects and classes on Programming project 2023-24</title>
    <link>https://unibz-pp-23-24.github.io/docs/objects/</link>
    <description>Recent content in Objects and classes on Programming project 2023-24</description>
    <generator>Hugo</generator>
    <language>en-us</language>
    <atom:link href="https://unibz-pp-23-24.github.io/docs/objects/index.xml" rel="self" type="application/rss+xml" />
    <item>
      <title>Objects</title>
      <link>https://unibz-pp-23-24.github.io/docs/objects/sections/objects/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://unibz-pp-23-24.github.io/docs/objects/sections/objects/</guid>
      <description>Objects # An object is a way to group data in a meaningful way.&#xA;A simple example: JSON objects # Here is a JSON object (in Javascript syntax) that describes the city of Florence:&#xA;{ name: &amp;#34;Florence&amp;#34;, zipcode: 50100 } A JSON object may contain other objects, as well as arrays (of values, objects or arrays). For instance:&#xA;{ name: &amp;#34;Alice&amp;#34;, age: 26, birthPlace: { name: &amp;#34;Florence&amp;#34;, zipcode: 50100 }, jobs: [ { employer: &amp;#34;Kolping&amp;#34;, start: 2021, end: 2022 }, { employer : &amp;#34;Eurac&amp;#34;, start: 2023 } ] } In JSON:</description>
    </item>
    <item>
      <title>Class and instance</title>
      <link>https://unibz-pp-23-24.github.io/docs/objects/sections/classes/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://unibz-pp-23-24.github.io/docs/objects/sections/classes/</guid>
      <description>Class and instance # A class can be viewed as a blueprint for a set of similar objects.&#xA;For instance, consider the two objects:&#xA;{ name: &amp;#34;Florence&amp;#34;, zipCode: 50100, region: &amp;#34;Tuscany&amp;#34; } { name: &amp;#34;Rome&amp;#34;, zipCode: 00100, region: &amp;#34;Lazio&amp;#34; } Each of these objects describes a city, and they share the same keys (name, zipCode and region). A possible class for these two objects may enforce this structure, and it could be named City.</description>
    </item>
    <item>
      <title>Inheritance</title>
      <link>https://unibz-pp-23-24.github.io/docs/objects/sections/inheritance/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://unibz-pp-23-24.github.io/docs/objects/sections/inheritance/</guid>
      <description>Inheritance # Subclass # In most (class-based) object-oriented languages, a class A can extend another class B. In this case, A is called a subclass of B. The intuitive meaning is inclusion between their respective sets of instances, i.e. every instance of A is also an instance of B (but the converse may not hold).&#xA;This can be paraphrased in English by &amp;ldquo;every A is a B &amp;ldquo;. For instance:</description>
    </item>
    <item>
      <title>Instance methods</title>
      <link>https://unibz-pp-23-24.github.io/docs/objects/sections/methods/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://unibz-pp-23-24.github.io/docs/objects/sections/methods/</guid>
      <description>Instance methods # In most object-oriented languages (like Java), methods are implemented within class declarations.&#xA;An instance method can only be called using an instance of the class where it is declared.&#xA;For instance, in Java, an instance method declared in MyClass can be called by appending . to a variable of type MyClass. The object referenced by the variable is accessible in the method, as well as its attributes.</description>
    </item>
    <item>
      <title>Displaying objects</title>
      <link>https://unibz-pp-23-24.github.io/docs/objects/sections/tostring/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://unibz-pp-23-24.github.io/docs/objects/sections/tostring/</guid>
      <description>Displaying objects # The class Object # Java has a native class called Object with 11 instance methods. Every Java class implicitly extends Object, including user-defined classes. Therefore any Java class inherits these methods. The method toString # toString is one of the methods of the class Object. Here is (part of) its specification:&#xA;/** Returns a string representation of the object. * In general, the toString method returns a string that * &amp;#34;textually represents&amp;#34; this object.</description>
    </item>
    <item>
      <title>Cast and equality</title>
      <link>https://unibz-pp-23-24.github.io/docs/objects/sections/comparing/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://unibz-pp-23-24.github.io/docs/objects/sections/comparing/</guid>
      <description>Cast and Equality # Cast # Java (as well as C# and C++) provides mechanisms to change the type associated with an object o, using either a supertype of o (this is an upcast), or a subtype of o (this is a downcast). Upcast # Explicit upcasts are uncommon, but may still be useful in some scenarios, e.g. to disambiguate two method calls.&#xA;Implicit upcasts on the other hand are very frequent, when the type of an object cannot be determined at compile time.</description>
    </item>
    <item>
      <title>Classes as objects</title>
      <link>https://unibz-pp-23-24.github.io/docs/objects/sections/classesasobjects/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://unibz-pp-23-24.github.io/docs/objects/sections/classesasobjects/</guid>
      <description>Classes as objects # Some object-oriented languages (like Java, C# or C++) provide ways to access or manipulate classes (almost) as if they were objects.&#xA;Static attributes and methods # Static attributes # Java (as well as C# and C++) supports attributes that do not depend on a specific object, but on a class instead. These are often called static attributes (or sometimes class attributes or class variables), as opposed to the attributes that we have seen so far, called instance attributes (or member variables).</description>
    </item>
    <item>
      <title>Duplicating objects</title>
      <link>https://unibz-pp-23-24.github.io/docs/objects/sections/clone/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://unibz-pp-23-24.github.io/docs/objects/sections/clone/</guid>
      <description>Duplicating objects # In some scenarios, it may be useful to duplicate an object.&#xA;In Java, as we saw earlier, copying the value of a variable with reference type does not copy the object that it references. For instance, the following program outputs &amp;ldquo;yellow&amp;rdquo;:&#xA;Unicorn unicorn = new Unicorn(&amp;#34;green&amp;#34;); Unicorn shallowCopy = unicorn; unicorn.color = &amp;#34;yellow&amp;#34;; System.out.println(shallowCopy.color); The need to duplicate objects may notably appear in a program that rely on concurrency.</description>
    </item>
    <item>
      <title>Quasi-objects</title>
      <link>https://unibz-pp-23-24.github.io/docs/objects/sections/quasi-objects/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://unibz-pp-23-24.github.io/docs/objects/sections/quasi-objects/</guid>
      <description>Quasi-objects # Enumerated types # Most imperative languages allow the creation of so-called enumerated types.&#xA;An enumerated type is a datatype for a finite set or enumerated values. For instance, if our game only allows &amp;ldquo;blue&amp;rdquo;, &amp;ldquo;green&amp;rdquo; and &amp;ldquo;red&amp;rdquo; as unit colors, then we may create a dedicated type that only allows these three values.&#xA;In Java # An enumerated type in Java is a set of constants. These constants are effectively static, meaning that they depends on the class or interface where the enumerated type is declared (similarly to a static attribute).</description>
    </item>
    <item>
      <title>Encapsulation</title>
      <link>https://unibz-pp-23-24.github.io/docs/objects/sections/encapsulation/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://unibz-pp-23-24.github.io/docs/objects/sections/encapsulation/</guid>
      <description>Encapsulation # Encapsulation is a (vague) principle in object-oriented programming that refers to &amp;ldquo;bundling&amp;rdquo; data with the code that operates on it, and restrict visibility of this code and data to other components of a system. From Wikipedia: &amp;ldquo;Essentially, encapsulation prevents external code from being concerned [&amp;hellip;]&amp;rdquo;&#xA;Each component hides its internal logic by exposing only data and methods that other components may need.&#xA;Example. As we saw earlier, in our game, the &amp;ldquo;view&amp;rdquo; component (which is in charge of rendering the game on screen) may buffer the game snapshots that it receives from the backend, if these snapshots are received faster than they can be displayed.</description>
    </item>
    <item>
      <title>Mutability</title>
      <link>https://unibz-pp-23-24.github.io/docs/objects/sections/mutability/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://unibz-pp-23-24.github.io/docs/objects/sections/mutability/</guid>
      <description>Mutability # Illustration # Exercise The Java method createUsers below is incorrect.&#xA;Can you see why, and how to fix this?&#xA;public class User { int id; String name; } /* Input: - ids: a nonempty array of user identifiers - names: an array of the same length as &amp;#39;ids&amp;#39; that contains user names Ouput: an array of users of the same lenght as &amp;#39;ids&amp;#39;, such as the i-th user has identifier ids[i] and name names[i] */ User[] createUsers(int[] ids, String[] names){ User[] users = new User[names.</description>
    </item>
    <item>
      <title>Quiz</title>
      <link>https://unibz-pp-23-24.github.io/docs/objects/sections/quiz/</link>
      <pubDate>Mon, 01 Jan 0001 00:00:00 +0000</pubDate>
      <guid>https://unibz-pp-23-24.github.io/docs/objects/sections/quiz/</guid>
      <description>Quiz # To answer the quiz (and check your answers), click here or scan this code:&#xA;Boxed type # public class City { int population; public City (int population){ this.population = population; } } int myInteger = 1; Integer myBoxedInteger = 1; Integer myBoxedCopy = myInteger; City myCity = new City(5000); myMethod(myInteger, myBoxedInteger, myBoxedCopy, myCity); System.out.println( myInteger + &amp;#34;, &amp;#34;+ myBoxedInteger + &amp;#34;, &amp;#34;+ myBoxedCopy + &amp;#34;,&amp;#34; + myCity.population); void myMethod(int integer, Integer boxedInteger, Integer boxedCopy, City city) { integer += 1; boxedInteger += 1; boxedCopy += 1; city.</description>
    </item>
  </channel>
</rss>
